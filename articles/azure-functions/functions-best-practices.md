---
title: Рекомендации по Функциям Azure
description: Ознакомьтесь с рекомендациями и шаблонами для Функций Azure.
ms.assetid: 9058fb2f-8a93-4036-a921-97a0772f503c
ms.topic: conceptual
ms.date: 10/16/2017
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: fa85f636233a067713d127938d674b359bd03696
ms.sourcegitcommit: d6b68b907e5158b451239e4c09bb55eccb5fef89
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74227385"
---
# <a name="optimize-the-performance-and-reliability-of-azure-functions"></a>Оптимизация производительности и надежности Функций Azure

В этой статье описано, как повысить производительность и надежность [бессерверных](https://azure.microsoft.com/solutions/serverless/) приложений-функций.  

## <a name="general-best-practices"></a>Общие рекомендации

Ниже приведены рекомендации по созданию и разработке бессерверных решений с помощью службы "Функции Azure".

### <a name="avoid-long-running-functions"></a>Избегайте длительных функций

Крупные длительные функции могут вызывать непредвиденные проблемы времени ожидания. Дополнительные сведения о времени ожидания для заданного плана размещения см. в разделе время [ожидания приложения-функции](functions-scale.md#timeout). 

Функция может стать большой из-за множества зависимостей Node. js. Импорт зависимостей может также привести к замедлению загрузки, что, в свою очередь, приводит к непредвиденным проблемам времени ожидания. Зависимости можно загрузить явно и неявно. Один модуль, загруженный в коде, может загрузить собственные дополнительные модули. 

По возможности выполняйте рефакторинг крупных функций и перерабатывайте их на более мелкие совместимые наборы функций, которые работают сообща и быстро возвращают ответ. Например, для веб-перехватчика или функции триггера HTTP может потребоваться ответ подтверждения в течение определенного предела времени. для веб-перехватчиков обычно требуется немедленный отклик. Полезные данные триггера HTTP можно передать в очередь для обработки с помощью функции триггера очереди. Такой подход позволяет отложить фактическую работу и вернуть немедленный ответ.


### <a name="cross-function-communication"></a>Взаимодействие функций

[Устойчивые функции](durable/durable-functions-overview.md) и [Azure Logic Apps](../logic-apps/logic-apps-overview.md) используются для управления переходами состояний и обмена данными между несколькими функциями.

Если не используется Устойчивые функции или Logic Apps для интеграции с несколькими функциями, лучше использовать очереди хранилища для обмена данными между функциями. Основная причина заключается в том, что очереди хранилища являются более дешевыми и проще в подготовке, чем другие варианты хранения. 

Размер отдельных сообщений в очереди хранилища ограничен до 64 КБ. Если между функциями нужно передать сообщения большего размера, можно использовать очередь служебной шины Azure, которая поддерживает сообщения размером до 256 КБ на уровне "Стандартный" и 1 МБ на уровне "Премиум".

Если перед обработкой сообщений их нужно отфильтровать, ознакомьтесь со статьями о служебной шине.

Для поддержки обмена крупными сообщениями используются Центры событий.


### <a name="write-functions-to-be-stateless"></a>Создавайте функции без отслеживания состояния 

По возможности функции должны быть без отслеживания состояния и идемпотентными. Свяжите любые необходимые сведения о состоянии со своими данными. Например, с обрабатываемым заказом скорее всего будет связан элемент `state`. Функция может обработать заказ, основываясь на этом состоянии, но в ней самой при этом не отслеживается состояние. 

Идемпотентные функции рекомендуется использовать с триггерами таймера. Например, если у вас есть нечто, что должно выполняться раз в день, напишите его, чтобы оно можно было выполнять в любое время в течение дня с теми же результатами. Функция может выйти из программы, если она не работает в определенный день. Кроме того, если предыдущее выполнение завершилось ошибкой, следующее выполнение должно начаться с прерванного момента.


### <a name="write-defensive-functions"></a>Создавайте защищенные функции

Предположим, что в любое время в функции может возникнуть исключение. Реализуйте в функции возможность продолжения с предыдущей точки сбоя во время следующего выполнения. Давайте рассмотрим сценарий, в котором необходимо сделать следующее:

1. Запрос 10 000 строк в базе данных.
2. Создать сообщение очереди для каждой из этих строк для дальнейшей обработки.
 
В зависимости от того, насколько сложна система, у вас может быть: вовлечение подчиненных служб в неплохое поведение, сбои сети или достигнутые квоты и т. д. Все это может повлиять на вашу функцию в любое время. Функции необходимо подготавливать к таким проблемам.

Как отреагирует ваш код при сбое после вставки 5000 элементов в очередь для обработки? Отслеживайте элементы в наборе, работа с которым завершена. В противном случае их можно вставить позже. Такая двойная Вставка может оказать серьезное воздействие на рабочий процесс, поэтому [функция идемпотентными](functions-idempotent.md). 

Если элемент очереди уже обработан, разрешите холостой цикл выполнения функции.

Воспользуйтесь предоставленными возможностями защиты для компонентов, используемых на платформе Функций Azure. Например, ознакомьтесь с разделом **Обработка подозрительных сообщений очереди** в документации по [триггерам и привязкам очереди службы хранилища Azure](functions-bindings-storage-queue.md#trigger---poison-messages). 

## <a name="scalability-best-practices"></a>Рекомендации по масштабируемости

Существует ряд факторов, влияющих на то, как экземпляры приложения-функции масштабируются. Дополнительные сведения см. в документации по [масштабированию функций](functions-scale.md).  Ниже приведены рекомендации по оптимальному масштабированию приложения-функции.

### <a name="share-and-manage-connections"></a>Управление подключениями и общий доступ к ним

При возможности повторно используйте подключения к внешним ресурсам.  См. раздел [Способы управления подключениями в службе "Функции Azure"](./manage-connections.md).

### <a name="dont-mix-test-and-production-code-in-the-same-function-app"></a>Не используйте тестовый и рабочий код в одном приложении-функции

Функции в приложении-функции совместно используют ресурсы. Например, память. Если приложение-функция используется в рабочей среде, не добавляйте в нее тестовые функции и ресурсы. Это может вызвать непредвиденные затраты во время выполнения кода в рабочей среде.

Следите за тем, что вы загружаете в рабочие приложения-функции. Память усредняется для каждой функции в приложении.

Если у вас есть общая сборка, на которую имеется ссылка в нескольких функциях .NET, поставьте ее в общую общую папку. В противном случае можно случайно развернуть несколько версий одного и того же двоичного файла, которые ведут себя по-разному в разных функциях.

Не используйте подробный журнал в рабочем коде, что отрицательно сказывается на производительности.

### <a name="use-async-code-but-avoid-blocking-calls"></a>Использование асинхронного кода без блокирующих вызовов

Рекомендуется применять метод асинхронного программирования. Но никогда не используйте ссылки на свойство `Result` и не вызывайте метод `Wait` для экземпляра `Task`. Применение этого подхода может привести к нехватке потоков.

[!INCLUDE [HTTP client best practices](../../includes/functions-http-client-best-practices.md)]

### <a name="receive-messages-in-batch-whenever-possible"></a>По возможности получайте сообщения в пакетном режиме

Некоторые триггеры, например триггер концентратора событий, позволяют получать сообщения в пакетном режиме в рамках одного вызова.  Пакетная обработка сообщений обеспечивает более высокую производительность.  Вы можете настроить максимальный размер пакета в файле `host.json`, как описано в [справочной документации по host.json](functions-host-json.md).

Для C# функций можно изменить тип на строго типизированный массив.  Например, вместо `EventData sensorEvent` можно использовать сигнатуру метода `EventData[] sensorEvent`.  Для других языков необходимо явно задать свойство кратности в `function.json` для `many`, чтобы включить пакетную обработку [, как показано ниже](https://github.com/Azure/azure-webjobs-sdk-templates/blob/df94e19484fea88fc2c68d9f032c9d18d860d5b5/Functions.Templates/Templates/EventHubTrigger-JavaScript/function.json#L10).

### <a name="configure-host-behaviors-to-better-handle-concurrency"></a>Настройте поведение узла для обеспечения оптимального параллелизма

Файл `host.json` в приложении-функции позволяет настраивать среду выполнения узла и поведение триггера.  Кроме настройки поведения пакетной обработки, вы можете управлять параллелизмом определенного числа триггеров. Часто настройка этих параметров помогает масштабировать каждый экземпляр согласно требованиям вызванных функций.

Параметры в файле host. JSON применяются ко всем функциям в приложении в рамках *одного экземпляра* функции. Например, если у вас есть приложение-функция с двумя функциями HTTP, а для запросов [`maxConcurrentRequests`](functions-bindings-http-webhook.md#hostjson-settings) задано значение 25, запрос к любому триггеру HTTP будет считаться общим 25 одновременных запросов.  Если это приложение-функция масштабируется до 10 экземпляров, то две функции эффективно допускают 250 параллельных запросов (10 экземпляров * 25 одновременных запросов на экземпляр). 

Другие параметры конфигурации узла находятся в [статье Настройка Host. JSON](functions-host-json.md).

## <a name="next-steps"></a>Дополнительная информация

Для получения дополнительных сведений см. следующие ресурсы:

* [Способы управления подключениями в службе "Функции Azure"](manage-connections.md)
* [Рекомендации по использованию службы приложений Azure](../app-service/app-service-best-practices.md)
