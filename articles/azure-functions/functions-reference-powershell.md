---
title: Справочник разработчика PowerShell для функций Azure
description: Узнайте, как разрабатывать функции с помощью PowerShell.
author: eamonoreilly
ms.topic: conceptual
ms.custom: devx-track-dotnet
ms.date: 04/22/2019
ms.openlocfilehash: dd3978ee1f371d59119e406c5f023718d57ad99b
ms.sourcegitcommit: 628be49d29421a638c8a479452d78ba1c9f7c8e4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "88642220"
---
# <a name="azure-functions-powershell-developer-guide"></a>Руководство разработчика PowerShell для Функций Azure.

Эта статья содержит сведения о том, как вы пишете функции Azure с помощью PowerShell.

Функция Azure PowerShell (функция) представляется в виде скрипта PowerShell, который выполняется при срабатывании. Каждый сценарий функции имеет связанный `function.json` файл, который определяет, как работает функция, например, как она запускается, а также ее входные и выходные параметры. Дополнительные сведения см. в [статье о триггерах и привязке](functions-triggers-bindings.md). 

Как и другие типы функций, функции скриптов PowerShell принимают параметры, соответствующие именам всех входных привязок, определенных в `function.json` файле. `TriggerMetadata`Также передается параметр, содержащий дополнительные сведения о триггере, который запустил функцию.

В этой статье предполагается, что вы уже прочли [руководство для разработчиков по Функциям Azure](functions-reference.md). Кроме того, для создания первой функции PowerShell необходимо завершить работу с [кратким руководством по функциям PowerShell](./functions-create-first-function-vs-code.md?pivots=programming-language-powershell) .

## <a name="folder-structure"></a>Структура папок

Необходимая структура папок для проекта PowerShell выглядит следующим образом. Это значение по умолчанию можно изменить. Дополнительные сведения см. в разделе о [scriptFile](#configure-function-scriptfile) ниже.

```
PSFunctionApp
 | - MyFirstFunction
 | | - run.ps1
 | | - function.json
 | - MySecondFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - myFirstHelperModule
 | | | - myFirstHelperModule.psd1
 | | | - myFirstHelperModule.psm1
 | | - mySecondHelperModule
 | | | - mySecondHelperModule.psd1
 | | | - mySecondHelperModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
 | - profile.ps1
 | - extensions.csproj
 | - bin
```

В корне проекта есть общий [`host.json`](functions-host-json.md) файл, который можно использовать для настройки приложения-функции. У каждой функции есть папка с собственным файлом кода (PS1) и файл конфигурации привязки ( `function.json` ). Имя function.jsродительского каталога файла всегда является именем функции.

Для определенных привязок требуется наличие `extensions.csproj` файла. Расширения привязки, необходимые в [версии 2. x и более поздних версиях](functions-versions.md) среды выполнения функций, определяются в `extensions.csproj` файле с фактическими файлами библиотеки в `bin` папке. При локальной разработке необходимо [зарегистрировать расширения привязки](functions-bindings-register.md#extension-bundles). При разработке функций на портале Azure эта регистрация выполняется автоматически.

В приложениях-функциях PowerShell при необходимости можно использовать, `profile.ps1` который запускается при запуске приложения-функции (в противном случае — как *[холодный запуск](#cold-start)*). Дополнительные сведения см. в разделе [профиль PowerShell](#powershell-profile).

## <a name="defining-a-powershell-script-as-a-function"></a>Определение скрипта PowerShell как функции

По умолчанию среда выполнения Функций ищет функцию в файле `run.ps1`, где `run.ps1` использует тот же родительский каталог, что и соответствующий файл `function.json`.

При выполнении скрипту передается ряд аргументов. Чтобы обрабатывал эти параметры, добавьте `param` блок в начало скрипта, как показано в следующем примере:

```powershell
# $TriggerMetadata is optional here. If you don't need it, you can safely remove it from the param block
param($MyFirstInputBinding, $MySecondInputBinding, $TriggerMetadata)
```

### <a name="triggermetadata-parameter"></a>Тригжерметадата, параметр

`TriggerMetadata`Параметр используется для предоставления дополнительных сведений о триггере. Дополнительные метаданные отличаются от привязки к привязке, но все они содержат `sys` свойство, которое содержит следующие данные:

```powershell
$TriggerMetadata.sys
```

| Свойство   | Описание                                     | Тип     |
|------------|-------------------------------------------------|----------|
| UtcNow     | Когда, в формате UTC, была активирована функция        | Дата и время |
| MethodName | Имя функции, которая была активирована     | строка   |
| рандгуид   | уникальный идентификатор GUID для этого выполнения функции | строка   |

Каждый тип триггера имеет другой набор метаданных. Например, `$TriggerMetadata` для `QueueTrigger` содержит `InsertionTime` ,, и, помимо прочего, `Id` `DequeueCount` . Дополнительные сведения о метаданных триггера очереди см. в [официальной документации по триггерам очереди](functions-bindings-storage-queue-trigger.md#message-metadata). Ознакомьтесь с документацией по [триггерам](functions-triggers-bindings.md) , с которыми вы работаете, чтобы узнать, что входит в метаданные триггера.

## <a name="bindings"></a>Привязки

В PowerShell [привязки](functions-triggers-bindings.md) настраиваются и определяются в function.jsфункции. Функции взаимодействуют с привязками несколькими способами.

### <a name="reading-trigger-and-input-data"></a>Чтение триггера и входных данных

Привязки триггера и ввода считываются как параметры, передаваемые в функцию. Для входных привязок `direction` задано значение `in` в function.json. `name`Свойство, определенное в `function.json` , является именем параметра в `param` блоке. Так как PowerShell использует именованные параметры для привязки, порядок параметров не имеет значения. Однако рекомендуется следовать порядку привязок, определенных в `function.json` .

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)
```

### <a name="writing-output-data"></a>запись выходных данных;

В функциях выходная привязка имеет значение, заданное `direction` `out` в function.json. Запись в выходную привязку можно выполнить с помощью `Push-OutputBinding` командлета, который доступен для среды выполнения функций. Во всех случаях `name` свойство привязки, определенное в, `function.json` соответствует `Name` параметру `Push-OutputBinding` командлета.

Ниже показано, как вызвать `Push-OutputBinding` в скрипте функции:

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Push-OutputBinding -Name myQueue -Value $myValue
```

Можно также передать значение для конкретной привязки через конвейер.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Produce-MyOutputValue | Push-OutputBinding -Name myQueue
```

`Push-OutputBinding` ведет себя по-разному в зависимости от значения, указанного для `-Name` :

* Если указанное имя не может быть разрешено в допустимую выходную привязку, возникает ошибка.

* Если выходная привязка принимает коллекцию значений, `Push-OutputBinding` для отправки нескольких значений можно многократно вызывать несколько раз.

* Если выходная привязка принимает только одноэлементное значение, вызов `Push-OutputBinding` второго раза вызывает ошибку.

#### <a name="push-outputbinding-syntax"></a>Синтаксис `Push-OutputBinding`

Ниже приведены допустимые параметры для вызова `Push-OutputBinding` .

| Имя | Тип | Положение | Описание |
| ---- | ---- |  -------- | ----------- |
| **`-Name`** | Строка | 1 | Имя выходной привязки, которую необходимо задать. |
| **`-Value`** | Объект | 2 | Значение выходной привязки, которое необходимо задать, которое принимается из Бивалуе конвейера. |
| **`-Clobber`** | SwitchParameter | именованная | Используемых При указании параметра устанавливает значение для заданной выходной привязки. | 

Также поддерживаются следующие общие параметры: 
* `Verbose`
* `Debug`
* `ErrorAction`
* `ErrorVariable`
* `WarningAction`
* `WarningVariable`
* `OutBuffer`
* `PipelineVariable`
* `OutVariable` 

Дополнительные сведения см. в разделе [About общиепараметры](https://go.microsoft.com/fwlink/?LinkID=113216).

#### <a name="push-outputbinding-example-http-responses"></a>Push-Аутпутбиндинг пример: HTTP-ответы

Триггер HTTP возвращает ответ, используя выходную привязку с именем `response` . В следующем примере выходная привязка `response` имеет значение "output #1":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #1"
})
```

Поскольку выходным данным является HTTP, которая принимает только одноэлементное значение, возникает ошибка, когда `Push-OutputBinding` вызывается второй раз.

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #2"
})
```

Для выходов, которые принимают только одноэлементные значения, можно использовать `-Clobber` параметр для переопределения старого значения вместо того, чтобы пытаться добавить его в коллекцию. В следующем примере предполагается, что вы уже добавили значение. Используя `-Clobber` , ответ из следующего примера переопределяет существующее значение для возврата значения "output #3":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #3"
}) -Clobber
```

#### <a name="push-outputbinding-example-queue-output-binding"></a>Пример Push-Аутпутбиндинг: Выходная привязка очереди

`Push-OutputBinding` используется для отправки данных в выходные привязки, такие как [выходная привязка хранилища очередей Azure](functions-bindings-storage-queue-output.md). В следующем примере сообщение, записанное в очередь, имеет значение "Output #1":

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #1"
```

Выходная привязка для очереди хранилища принимает несколько выходных значений. В этом случае вызов следующего примера после первой записи в очередь списка с двумя элементами: "Output #1" и "Output #2".

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #2"
```

В следующем примере, когда вызывается после двух предыдущих, в выходную коллекцию добавляется еще два значения:

```powershell
PS >Push-OutputBinding -Name outQueue -Value @("output #3", "output #4")
```

При запись в очередь сообщение содержит следующие четыре значения: "Output #1", "Output #2", "Output #3" и "Output #4".

#### <a name="get-outputbinding-cmdlet"></a>Командлет `Get-OutputBinding`

`Get-OutputBinding`С помощью командлета можно получить значения, заданные в данный момент для выходных привязок. Этот командлет извлекает хэш-таблицу, содержащую имена выходных привязок с соответствующими значениями. 

Ниже приведен пример использования `Get-OutputBinding` для возврата текущих значений привязки.

```powershell
Get-OutputBinding
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
MyOtherQueue                   myData
```

`Get-OutputBinding` также содержит параметр с именем `-Name` , который можно использовать для фильтрации возвращаемой привязки, как показано в следующем примере:

```powershell
Get-OutputBinding -Name MyQ*
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
```

Подстановочные знаки (*) поддерживаются в `Get-OutputBinding` .

## <a name="logging"></a>Logging

Ведение журнала в функциях PowerShell работает как обычное ведение журнала PowerShell. Командлеты ведения журнала можно использовать для записи в каждый выходной поток. Каждый командлет сопоставляется с уровнем ведения журнала, который используется функциями.

| Уровень ведения журнала функций | Командлет ведения журнала |
| ------------- | -------------- |
| Error | **`Write-Error`** |
| Предупреждение | **`Write-Warning`**  | 
| Информация | **`Write-Information`** <br/> **`Write-Host`** <br /> **`Write-Output`**      | Информация | Выполняет запись в журнал на уровне _информации_ . |
| Отладка | **`Write-Debug`** |
| Трассировка | **`Write-Progress`** <br /> **`Write-Verbose`** |

Помимо этих командлетов, все данные, записанные в конвейер, перенаправляются на `Information` уровень ведения журнала и отображаются с форматированием PowerShell по умолчанию.

> [!IMPORTANT]
> Использование `Write-Verbose` `Write-Debug` командлетов или не является достаточным для просмотра подробных сведений и ведения журнала на уровне отладки. Кроме того, необходимо настроить пороговое значение уровня ведения журнала, которое объявляет, какой уровень журналов вы в действительности интересуют. Дополнительные сведения см. в статье [Настройка уровня ведения журнала приложения функции](#configure-the-function-app-log-level).

### <a name="configure-the-function-app-log-level"></a>Настройка уровня ведения журнала приложения функции

Функции Azure позволяют определить пороговый уровень, чтобы упростить управление способом записи функций в журналы. Чтобы задать пороговое значение для всех трассировок, записываемых на консоль, используйте `logging.logLevel.default` свойство в [ `host.json` файле] [host.jsпо ссылке]. Этот параметр применяется ко всем функциям в приложении-функции.

В следующем примере устанавливается пороговое значение для включения подробного ведения журнала для всех функций, но устанавливается пороговое значение включения ведения журнала отладки для функции с именем `MyFunction` :

```json
{
    "logging": {
        "logLevel": {
            "Function.MyFunction": "Debug",
            "default": "Trace"
        }
    }
}  
```

Дополнительные сведения см. в [справочной статье о host.json].

### <a name="viewing-the-logs"></a>Просмотр журналов

Если приложение-функция выполняется в Azure, можно использовать Application Insights для мониторинга. Дополнительные сведения о просмотре журналов функций и обращении к ним см. в статье [мониторинг Функций Azure](functions-monitoring.md).

Если вы используете приложение-функция локально для разработки, ведет журнал по умолчанию в файловой системе. Чтобы просмотреть журналы в консоли, задайте `AZURE_FUNCTIONS_ENVIRONMENT` для переменной среды значение `Development` перед запуском приложение-функция.

## <a name="triggers-and-bindings-types"></a>Типы триггеров и привязок

Существует ряд триггеров и привязок, которые можно использовать с приложением-функцией. Полный список триггеров и привязок [можно найти здесь](functions-triggers-bindings.md#supported-bindings).

Все триггеры и привязки представлены в коде как несколько реальных типов данных:

* Хэш-таблицы
* строка
* byte[]
* INT
* double
* хттпрекуестконтекст
* хттпреспонсеконтекст

Первые пять типов в этом списке являются стандартными типами .NET. Последние два используются только [триггером HttpTrigger](#http-triggers-and-bindings).

Каждый параметр привязки в функциях должен иметь один из этих типов.

### <a name="http-triggers-and-bindings"></a>Триггеры и привязки HTTP

Триггеры HTTP и webhook, а также привязки вывода HTTP используют объекты запроса и ответа для обмена сообщениями HTTP.

#### <a name="request-object"></a>Объект запроса

Объект запроса, переданный в скрипт, имеет тип `HttpRequestContext` , который имеет следующие свойства:

| Свойство  | Описание                                                    | Тип                      |
|-----------|----------------------------------------------------------------|---------------------------|
| **`Body`**    | Объект, содержащий текст запроса. `Body` сериализуется в лучший тип на основе данных. Например, если данные являются JSON, они передаются в виде хэш-таблицы. Если данные являются строкой, они передаются в виде строки. | объект |
| **`Headers`** | Словарь, содержащий заголовки запроса.                | Строка<словаря, строка><sup>*</sup> |
| **`Method`** | Метод HTTP, используемый для запроса.                                | строка                    |
| **`Params`**  | Объект, содержащий параметры маршрутизации запроса. | Строка<словаря, строка><sup>*</sup> |
| **`Query`** | Объект, содержащий параметры запроса.                  | Строка<словаря, строка><sup>*</sup> |
| **`Url`** | URL-адрес запроса.                                        | строка                    |

<sup>*</sup> Во всех `Dictionary<string,string>` ключах регистр не учитывается.

#### <a name="response-object"></a>Объект ответа

Объект ответа, который необходимо отправить обратно, имеет тип `HttpResponseContext` , который имеет следующие свойства:

| Свойство      | Описание                                                 | Тип                      |
|---------------|-------------------------------------------------------------|---------------------------|
| **`Body`**  | Объект, содержащий текст ответа.           | объект                    |
| **`ContentType`** | Короткий рукой для установки типа содержимого для ответа. | строка                    |
| **`Headers`** | Объект, содержащий заголовок ответа.               | Словарь или хэш-таблица   |
| **`StatusCode`**  | Код состояния HTTP ответа.                       | строка или целое число             |

#### <a name="accessing-the-request-and-response"></a>Доступ к запросу и ответу

При работе с триггерами HTTP доступ к HTTP-запросу можно получить так же, как и с любой другой входной привязкой. Он находится в `param` блоке.

Используйте `HttpResponseContext` объект для возврата ответа, как показано ниже:

`function.json`

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "anonymous"
    },
    {
      "type": "http",
      "direction": "out"
    }
  ]
}
```

`run.ps1`

```powershell
param($req, $TriggerMetadata)

$name = $req.Query.Name

Push-OutputBinding -Name res -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "Hello $name!"
})
```

Результат вызова этой функции будет следующим:

```
PS > irm http://localhost:5001?Name=Functions
Hello Functions!
```

### <a name="type-casting-for-triggers-and-bindings"></a>Приведение типов для триггеров и привязок

Для некоторых привязок, таких как привязка больших двоичных объектов, можно указать тип параметра.

Например, чтобы данные из хранилища BLOB-объектов передавались в виде строки, добавьте следующий тип к моему `param` блоку:

```powershell
param([string] $myBlob)
```

## <a name="powershell-profile"></a>Профиль PowerShell

В PowerShell есть понятие профиля PowerShell. Если вы не знакомы с профилями PowerShell, см. раздел [About Profiles](/powershell/module/microsoft.powershell.core/about/about_profiles).

В функциях PowerShell скрипт профиля выполняется при запуске приложения функции. Приложения-функции запускаются при первом развертывании и после бездействия ([холодный запуск](#cold-start)).

При создании приложения-функции с помощью средств, таких как Visual Studio Code и Azure Functions Core Tools, создается значение по умолчанию `profile.ps1` . Профиль по умолчанию хранится [в репозитории основных средств](https://github.com/Azure/azure-functions-core-tools/blob/dev/src/Azure.Functions.Cli/StaticResources/profile.ps1) , который содержит:

* Автоматическая проверка подлинности MSI в Azure.
* Возможность включения Azure PowerShell `AzureRM` псевдонимов PowerShell при желании.

## <a name="powershell-versions"></a>Версии PowerShell

В следующей таблице показаны версии PowerShell, поддерживаемые каждой основной версией среды выполнения функций, и требуемая версия .NET.

| Версия службы "Функции" | Версия PowerShell                               | Версия .NET  | 
|-------------------|--------------------------------------------------|---------------|
| 3. x (рекомендуется) | PowerShell 7 (рекомендуется)<br/>PowerShell Core 6 | .NET Core 3.1<br/>.NET Core 3.1 |
| 2.x               | PowerShell Core 6                                | .NET Core 2.2 |

Текущую версию можно просмотреть, выполнив печать `$PSVersionTable` из любой функции.

## <a name="dependency-management"></a>Управление зависимостями

Функции позволяют использовать [коллекцию PowerShell](https://www.powershellgallery.com) для управления зависимостями. При включенном управлении зависимостями файл requirements.psd1 используется для автоматической загрузки необходимых модулей. Это поведение можно включить, задав `managedDependency` для свойства значение `true` в корневом каталоге [host.jsдля файла](functions-host-json.md), как показано в следующем примере:

```json
{
  "managedDependency": {
          "enabled": true
       }
}
```

При создании нового проекта функций PowerShell управление зависимостями включается по умолчанию с включенным [ `Az` модулем](/powershell/azure/new-azureps-module-az) Azure. Максимальное число модулей, поддерживаемое в настоящее время, равно 10. Поддерживаемый синтаксис — _`MajorNumber`_ `.*` или точная версия модуля, как показано в следующем requirements.psd1 примере:

```powershell
@{
    Az = '1.*'
    SqlServer = '21.1.18147'
}
```

При обновлении файла requirements.psd1 обновленные модули устанавливаются после перезагрузки.

> [!NOTE]
> Управляемым зависимостям требуется доступ к www.powershellgallery.com для скачивания модулей. При локальном запуске убедитесь, что среда выполнения может получить доступ к этому URL-адресу, добавив необходимые правила брандмауэра. 

Следующие параметры приложения можно использовать для изменения способа загрузки и установки управляемых зависимостей. Обновление приложения начинается в пределах `MDMaxBackgroundUpgradePeriod` , а процесс обновления завершается примерно в `MDNewSnapshotCheckPeriod` .

| Параметр приложение-функция              | Значение по умолчанию             | Описание                                         |
|   -----------------------------   |   -------------------     |  -----------------------------------------------    |
| **`MDMaxBackgroundUpgradePeriod`**      | `7.00:00:00` (7 дней)     | Каждый рабочий процесс PowerShell инициирует проверку наличия обновлений модулей на коллекция PowerShell при запуске процесса и каждый `MDMaxBackgroundUpgradePeriod` после этого. Если в коллекция PowerShell доступна новая версия модуля, она устанавливается в файловую систему и становится доступной для рабочих ролей PowerShell. Уменьшение этого значения позволяет приложению-функции получать более новые версии модулей быстрее, но также увеличивает использование ресурсов приложения (сетевой ввод-вывод, ЦП, хранилище). Увеличение этого значения приводит к уменьшению использования ресурсов приложением, но может также задержать доставку новых версий модуля в приложение. | 
| **`MDNewSnapshotCheckPeriod`**         | `01:00:00` (1 час)       | После установки новых версий модулей в файловой системе необходимо перезапустить каждый рабочий процесс PowerShell. Перезапуск рабочих ролей PowerShell влияет на доступность приложения, так как он может прерывать текущее выполнение функции. До тех пор пока все рабочие процессы PowerShell не будут перезапущены, вызовы функций могут использовать либо старые, либо новые версии модулей. Перезапуск всех рабочих ролей PowerShell завершен в `MDNewSnapshotCheckPeriod` . Увеличение этого значения снижает частоту прерываний, но также может увеличить период времени, в течение которого вызовы функций используют старую или новую версию модуля недетерминированно. |
| **`MDMinBackgroundUpgradePeriod`**      | `1.00:00:00` (1 день)     | Чтобы избежать чрезмерного обновления модулей при частых перезапусках рабочих ролей, проверка обновления модулей не выполняется, когда любой рабочий процесс уже инициировал эту проверку в последней `MDMinBackgroundUpgradePeriod` . |

Использование собственных пользовательских модулей немного отличается от того, как это можно сделать обычным образом.

На локальном компьютере модуль устанавливается в одну из глобально доступных папок в `$env:PSModulePath` . При работе в Azure у вас нет доступа к модулям, установленным на вашем компьютере. Это означает, что объект `$env:PSModulePath` для приложения-функции PowerShell отличается от `$env:PSModulePath` в регулярном скрипте PowerShell.

В функциях `PSModulePath` содержит два пути:

* `Modules`Папка, которая находится в корне приложения-функции.
* Путь к `Modules` папке, управляемой рабочим работником языка PowerShell.

### <a name="function-app-level-modules-folder"></a>Папка уровня приложения-функции `Modules`

Чтобы использовать пользовательские модули, можно разместить модули, от которых зависят функции, в `Modules` папке. Из этой папки модули автоматически становятся доступными для среды выполнения функций. Все функции в приложении функции могут использовать эти модули. 

> [!NOTE]
> Модули, указанные в файле requirements.psd1, автоматически загружаются и включаются в путь, поэтому их не нужно включать в папку Modules. Они хранятся локально в `$env:LOCALAPPDATA/AzureFunctions` папке и в `/data/ManagedDependencies` папке при запуске в облаке.

Чтобы воспользоваться функцией пользовательского модуля, создайте `Modules` папку в корне приложения-функции. Скопируйте модули, которые вы хотите использовать в функциях, в это расположение.

```powershell
mkdir ./Modules
Copy-Item -Path /mymodules/mycustommodule -Destination ./Modules -Recurse
```

В `Modules` папке приложение-функция должно иметь следующую структуру папок:

```
PSFunctionApp
 | - MyFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - MyCustomModule
 | | - MyOtherCustomModule
 | | - MySpecialModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
```

При запуске приложения-функции языковой рабочий процесс PowerShell добавляет эту папку в, `Modules` `$env:PSModulePath` чтобы вы могли полагаться на автозагрузку модуля точно так же, как в обычном сценарии PowerShell.

### <a name="language-worker-level-modules-folder"></a>Папка уровня рабочей роли языка `Modules`

Рабочие роли языка PowerShell обычно используют несколько модулей. Эти модули определяются в последней должности `PSModulePath` . 

Текущий список модулей выглядит следующим образом:

* [Microsoft. PowerShell. Archive](https://www.powershellgallery.com/packages/Microsoft.PowerShell.Archive): модуль, используемый для работы с архивами, например `.zip` , `.nupkg` и другими.
* **Среаджоб**: реализация API-интерфейсов задания PowerShell на основе потока.

По умолчанию функции используют самые последние версии этих модулей. Чтобы использовать конкретную версию модуля, вставьте эту конкретную версию в `Modules` папку приложения-функции.

## <a name="environment-variables"></a>Переменные среды

В Функциях [параметры приложения](functions-app-settings.md), такие как строки подключения службы, доступны в виде переменных среды во время выполнения. Доступ к этим параметрам можно получить с помощью `$env:NAME_OF_ENV_VAR` , как показано в следующем примере:

```powershell
param($myTimer)

Write-Host "PowerShell timer trigger function ran! $(Get-Date)"
Write-Host $env:AzureWebJobsStorage
Write-Host $env:WEBSITE_SITE_NAME
```

[!INCLUDE [Function app settings](../../includes/functions-app-settings.md)]

При локальном запуске приложения параметры считываются из файла проекта [local.settings.json](functions-run-local.md#local-settings-file).

## <a name="concurrency"></a>Параллелизм

По умолчанию среда выполнения PowerShell для функций может обрабатывать только один вызов функции за раз. Однако этот уровень параллелизма может быть недостаточно в следующих ситуациях:

* При одновременной обработке большого количества вызовов одновременно.
* При наличии функций, которые вызывают другие функции в одном и том же приложении функции.

Это поведение можно изменить, задав для следующей переменной среды целочисленное значение:

```
PSWorkerInProcConcurrencyUpperBound
```

Эта переменная среды задается в [параметрах приложения](functions-app-settings.md) приложение-функция.

### <a name="considerations-for-using-concurrency"></a>Рекомендации по использованию параллелизма

По умолчанию PowerShell является _отдельным потоковым_ языком сценариев. Однако параллелизм можно добавить с помощью нескольких пространств выполнения PowerShell в одном процессе. Объем созданных пространств выполнения будет соответствовать параметру приложения Псворкеринпрокконкурренциуппербаунд. На пропускную способность влияет объем ресурсов ЦП и памяти, доступный в выбранном плане.

Azure PowerShell использует некоторые контексты и состояния _уровня процесса_ , чтобы помочь сэкономить от чрезмерного ввода. Однако при включении параллелизма в приложении функции и вызове действий, изменяющих состояние, могут возникнуть состояния гонки. Эти состояния гонки трудно отлаживать, поскольку один вызов зависит от определенного состояния, а другой вызов изменил состояние.

Во время параллелизма Azure PowerShell, так как некоторые операции могут занимать значительное количество времени. Однако следует соблюдать осторожность. Если вы считаете, что столкнулись с состоянием гонки, задайте для параметра приложения Псворкеринпрокконкурренциуппербаунд значение `1` и вместо этого используйте [изоляцию уровня языкового рабочего процесса](functions-app-settings.md#functions_worker_process_count) для параллелизма.

## <a name="configure-function-scriptfile"></a>Настройка функции `scriptFile`

По умолчанию функция PowerShell выполняется из `run.ps1` файла, который использует тот же родительский каталог, что и соответствующий `function.json` .

`scriptFile`Свойство в `function.json` можно использовать для получения структуры папок, которая выглядит, как в следующем примере:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.ps1
```

В этом случае `function.json` для `myFunction` включает `scriptFile` свойство, ссылающееся на файл с экспортированной функцией для выполнения.

```json
{
  "scriptFile": "../lib/PSFunction.ps1",
  "bindings": [
    // ...
  ]
}
```

## <a name="use-powershell-modules-by-configuring-an-entrypoint"></a>Использование модулей PowerShell с помощью настройки точки входа

В этой статье показаны функции PowerShell в файле сценария по умолчанию, `run.ps1` созданном шаблонами.
Однако можно также включить функции в модули PowerShell. Вы можете ссылаться на код конкретной функции в модуле, используя `scriptFile` `entryPoint` поля и в function.jsв файле конфигурации.

В этом случае `entryPoint` — это имя функции или командлета в модуле PowerShell, на который ссылается `scriptFile` .

Рассмотрим следующую структуру папок:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.psm1
```

Где `PSFunction.psm1` содержит:

```powershell
function Invoke-PSTestFunc {
    param($InputBinding, $TriggerMetadata)

    Push-OutputBinding -Name OutputBinding -Value "output"
}

Export-ModuleMember -Function "Invoke-PSTestFunc"
```

В этом примере конфигурация `myFunction` включает `scriptFile` свойство, которое ссылается на `PSFunction.psm1` модуль PowerShell в другой папке.  `entryPoint`Свойство ссылается на `Invoke-PSTestFunc` функцию, которая является точкой входа в модуле.

```json
{
  "scriptFile": "../lib/PSFunction.psm1",
  "entryPoint": "Invoke-PSTestFunc",
  "bindings": [
    // ...
  ]
}
```

В этой конфигурации объект `Invoke-PSTestFunc` выполняется точно так же, как и `run.ps1` .

## <a name="considerations-for-powershell-functions"></a>Рекомендации по функциям PowerShell

При работе с функциями PowerShell учитывайте рекомендации в следующих разделах.

### <a name="cold-start"></a>Холодный запуск

При разработке функций Azure в [модели размещения, не поддерживающей сервер](functions-scale.md#consumption-plan), холодный запуск — это реальность. *Холодный запуск* — это период времени, который требуется для запуска приложения-функции для обработки запроса. Холодный запуск чаще всего происходит в плане потребления, так как приложение-функция завершает работу в периоды бездействия.

### <a name="bundle-modules-instead-of-using-install-module"></a>Используйте модули пакета вместо `Install-Module`

Сценарий выполняется при каждом вызове. Избегайте использования `Install-Module` в скрипте. Вместо этого используйте `Save-Module` перед публикацией, чтобы функция не могла тратить время на загрузку модуля. Если холодный запуск влияет на ваши функции, рассмотрите возможность развертывания приложения-функции в [плане службы приложений](functions-scale.md#app-service-plan) со значением *Always on* или в [плане Premium](functions-scale.md#premium-plan).

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения см. в следующих ресурсах:

* [Рекомендации по функциям Azure](functions-best-practices.md)
* [Справочник разработчика по функциям Azure](functions-reference.md)
* [Azure Functions triggers and bindings (Триггеры и привязки в Функциях Azure)](functions-triggers-bindings.md)

[Справочник по host.json]: functions-host-json.md
