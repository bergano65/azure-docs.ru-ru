---
title: Обработка надежных событий в функциях Azure
description: Предотвращение отсутствия сообщений концентратора событий в функциях Azure
services: functions
author: craigshoemaker
manager: gwallace
ms.service: azure-functions
ms.topic: conceptual
ms.date: 09/12/2019
ms.author: cshoe
ms.openlocfilehash: d38ef46abae12886fb04a30f5efc26992cde4443
ms.sourcegitcommit: 4f7dce56b6e3e3c901ce91115e0c8b7aab26fb72
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/04/2019
ms.locfileid: "71955540"
---
# <a name="azure-functions-reliable-event-processing"></a>Обработка надежных событий в функциях Azure

Обработка событий является одним из наиболее распространенных сценариев, связанных с бессерверной архитектурой. В этой статье описывается, как создать надежный обработчик сообщений с помощью функций Azure, чтобы избежать потери сообщений.

## <a name="challenges-of-event-streams-in-distributed-systems"></a>Проблемы потоков событий в распределенных системах

Рассмотрим систему, которая отправляет события с постоянной частотой 100 событий в секунду. В течение нескольких минут экземпляры параллельных функций могут использовать входящие события 100 каждую секунду.

Однако возможны следующие менее оптимальные условия.

- Что делать, если издатель события отправляет поврежденное событие?
- Что делать, если экземпляр функций обнаруживает необработанные исключения?
- Что произойдет, если Подчиненная система переходит в режим «вне сети»?

Как обрабатывать эти ситуации, сохраняя пропускную способность приложения?

Благодаря очередям надежный обмен сообщениями имеет естественное направление. При связывании с триггером функций функция создает блокировку сообщения очереди. Если обработка завершается неудачей, блокировка освобождается, чтобы позволить другому экземпляру повторить попытку обработки. Затем обработка продолжится до тех пор, пока сообщение не будет успешно вычислено или Добавлено в очередь подозрительных сообщений.

Даже если одно сообщение очереди может остаться в цикле повтора, другие параллельные выполнения продолжают выводить из очереди оставшиеся сообщения. В результате общая пропускная способность не зависит от одного неверного сообщения. Однако очереди хранилища не гарантируют упорядочение и не оптимизируются для высоких требований к пропускной способности, необходимых концентраторам событий.

Концентраторы событий Azure, напротив, не включают концепцию блокировки. Для поддержки таких функций, как высокая пропускная способность, несколько групп потребителей и возможность воспроизведения, события концентраторов событий ведут себя так же, как видеопроигрыватель. События считываются из одной точки в потоке на секцию. С помощью указателя можно выполнять чтение вперед или назад из этого расположения, но необходимо выбрать перемещение указателя для обработки событий.

Если при возникновении ошибок в потоке вы решили, чтобы указатель оставался в одном месте, обработка событий блокируется до тех пор, пока указатель не будет расширен. Иными словами, если указатель остановлен, чтобы обработать проблемы с обработкой одного события, необработанные события начинают накапливаться.

Функции Azure избегают взаимоблокировок путем перемещения указателя потока, независимо от успешности или сбоя. Поскольку указатель продолжает походить, ваши функции должны правильно обрабатывать ошибки.

## <a name="how-azure-functions-consumes-event-hubs-events"></a>Как функции Azure используют события концентраторов событий

Функции Azure используют события концентратора событий при циклическом выполнении следующих шагов:

1. Создается и сохраняется указатель в службе хранилища Azure для каждого раздела концентратора событий.
2. При получении новых сообщений (по умолчанию в пакете) узел пытается запустить функцию с пакетом сообщений.
3. Если функция завершает выполнение (с исключением или без него), указатель перемещается и контрольная точка сохраняется в учетной записи хранения.
4. Если условия не позволяют завершить выполнение функции, узел не сможет выполнить указатель. Если указатель не является продвинутым, последующие проверки обрабатывают те же сообщения.
5. Повторите шаги 2 – 4

Это поведение раскрывает несколько важных моментов.

- *Необработанные исключения могут привести к потере сообщений.* Выполнение, результатом которого является исключение, будет по прежнему продвигается указатель.
- *Функции гарантируют доставку по крайней мере один раз.* Коду и зависимым системам может потребоваться [учитывать тот факт, что одно и то же сообщение может быть получено дважды](./functions-idempotent.md).

## <a name="handling-exceptions"></a>Обработка исключений

Как правило, каждая функция должна включать [блок try/catch](./functions-bindings-error-pages.md) на самом верхнем уровне кода. В частности, все функции, использующие события концентраторов событий, должны иметь блок `catch`. Таким образом, при возникновении исключения блок Catch обрабатывает ошибку перед выполнением указателя.

### <a name="retry-mechanisms-and-policies"></a>Механизмы и политики повтора

Некоторые исключения являются временными и не отображаются при попытке выполнить операцию позже. Именно поэтому первый шаг всегда должен повторить операцию. Вы можете написать правила обработки повторных попыток самостоятельно, но они настолько распространены, что доступно несколько средств. Использование этих библиотек позволяет определить надежные политики повтора, которые также могут помочь сохранить порядок обработки.

Внедрение библиотек обработки ошибок в функции позволяет определить как базовые, так и расширенные политики повтора. Например, можно реализовать политику, следующую за рабочим процессом, проиллюстрированным следующими правилами.

- Попробуйте вставить сообщение три раза (возможно, с задержкой между повторными попытками).
- Если результатом всех повторных попыток является сбой, добавьте сообщение в очередь, чтобы обработка могла продолжаться в потоке.
- Поврежденные или необработанные сообщения обрабатываются позже.

> [!NOTE]
> [Polly](https://github.com/App-vNext/Polly) — это пример библиотеки устойчивости и обработки временных ошибок для C# приложений.

При работе с предварительно скомпилированными C# библиотеками классов [фильтры исключений](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/try-catch) позволяют запускать код всякий раз, когда возникает необработанное исключение.

Примеры, демонстрирующие использование фильтров исключений, доступны в репозитории [пакета SDK веб-заданий Azure](https://github.com/Azure/azure-webjobs-sdk/wiki) .

## <a name="non-exception-errors"></a>Ошибки, не связанные с исключениями

Некоторые проблемы возникают, даже если ошибка отсутствует. Например, рассмотрим сбой, который происходит в процессе выполнения. В этом случае, если выполнение функции не завершается, указатель смещения никогда не выполняется. Если указатель не передается, любой экземпляр, который запускается после неудачного выполнения, продолжит считывать те же сообщения. Эта ситуация обеспечивает гарантию "хотя бы один раз".

Гарантия того, что каждое сообщение обрабатывается по крайней мере один раз, означает, что некоторые сообщения могут обрабатываться несколько раз. Приложения функций должны быть осведомлены об этой возможности и должны быть построены на основе [принципов идемпотентности](./functions-idempotent.md).

## <a name="stop-and-restart-execution"></a>Завершение и перезапуск выполнения

Хотя некоторые ошибки могут быть приемлемыми, что происходит, если в вашем приложении возникают серьезные сбои? Может потребоваться отключить активацию событий до тех пор, пока система не достигнет работоспособного состояния. Обработка приостановки возможной сделки часто достигается с помощью шаблона автоматического выключения. Шаблон автоматического выключения позволяет приложению "прерывать канал" процесса события и возобновлять его позже.

Существует две части, необходимые для реализации автоматического прерывания в процессе события:

- Общее состояние по всем экземплярам для отслеживания и мониторинга работоспособности канала
- Главный процесс, который может управлять состоянием канала (открытым или закрытым)

Сведения о реализации могут отличаться, но для общего доступа к состоянию между экземплярами необходим механизм хранения. Вы можете выбрать сохранение состояния в службе хранилища Azure, кэше Redis или любой другой учетной записи, доступной коллекции функций.

[Azure Logic Apps](../logic-apps/logic-apps-overview.md) или [устойчивые сущности](./durable/durable-functions-overview.md) естественным образом подходят для управления рабочим процессом и состоянием цепи. Другие службы могут работать точно так же, но для этого примера используются приложения логики. С помощью приложений логики можно приостанавливать и перезапускать выполнение функции, предоставляя элемент управления, необходимый для реализации шаблона автоматического выключения.

### <a name="define-a-failure-threshold-across-instances"></a>Определение порогового значения сбоя для экземпляров

Для одновременной обработки нескольких экземпляров событий необходимо сохранить общее внешнее состояние, чтобы отслеживать работоспособность канала.

Правило, которое можно выбрать для реализации, может обеспечить соблюдение следующих условий:

- Если в течение 30 секунд во всех экземплярах возникает более 100 удачных попыток, разбейте канал и завершите срабатывание новых сообщений.

Сведения о реализации будут отличаться в зависимости от ваших потребностей, но в целом можно создать систему, которая:

1. Регистрация ошибок в учетной записи хранения (служба хранилища Azure, Redis и т. д.)
1. При занесении в журнал нового сбоя Проверьте число последовательностей, чтобы узнать, соответствует ли порог (например, более 100 за последние 30 секунд).
1. Если пороговое значение достигнуто, выпустите событие в службе "Сетка событий Azure", чтобы система нарушила цепь.

### <a name="managing-circuit-state-with-azure-logic-apps"></a>Управление состоянием цепи с помощью Azure Logic Apps

Следующее описание демонстрирует один из способов создания приложения логики Azure, чтобы остановить обработку приложения-функции.

Azure Logic Apps поставляется с встроенными соединителями для различных служб, применяет согласованность с отслеживанием состояния и является естественным выбором для управления состоянием цепи. После определения необходимости прерывания канала можно создать приложение логики для реализации следующего рабочего процесса:

1. Активация рабочего процесса службы "Сетка событий" и завершение работы функции Azure (с помощью соединителя ресурсов Azure)
1. Отправить электронное письмо с уведомлением, которое содержит параметр для перезапуска рабочего процесса

Получатель электронной почты может исследовать работоспособность канала и при необходимости перезапустить цепь по ссылке в сообщении электронной почты с уведомлением. Когда рабочий процесс перезапускает функцию, сообщения обрабатываются из последней контрольной точки концентратора событий.

При таком подходе сообщения не теряются, все сообщения обрабатываются по порядку, и при необходимости можно разбивать канал.

## <a name="resources"></a>Ресурсы

- [Примеры обработки надежных событий](https://github.com/jeffhollan/functions-csharp-eventhub-ordered-processing)
- [Автоматическое выключение цепи Azure Устойчивые функции](https://github.com/jeffhollan/functions-durable-actor-circuitbreaker)

## <a name="next-steps"></a>Следующие шаги

Для получения дополнительных сведений см. следующие ресурсы:

- [Обработка ошибок службы "Функции Azure"](./functions-bindings-error-pages.md)
- [Автоматическое изменение размера переданных изображений с помощью Сетки событий](../event-grid/resize-images-on-storage-blob-upload-event.md?toc=%2Fazure%2Fazure-functions%2Ftoc.json&tabs=dotnet)
- [Создание функции, интегрируемой с Azure Logic Apps](./functions-twitter-email.md)
