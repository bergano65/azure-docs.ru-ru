---
title: Поиск данных SQL Azure
titleSuffix: Azure Cognitive Search
description: Импорт данных из базы данных SQL Azure или SQL Управляемый экземпляр с помощью индексаторов для полнотекстового поиска в Когнитивный поиск Azure. В этой статье описываются подключения, конфигурация индексатора и прием данных.
manager: nitinme
author: mgottein
ms.author: magottei
ms.devlang: rest-api
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 07/12/2020
ms.openlocfilehash: b1ad4ead83c9e07966f921a5b192f2791838e6ef
ms.sourcegitcommit: 829d951d5c90442a38012daaf77e86046018e5b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2020
ms.locfileid: "91530567"
---
# <a name="connect-to-and-index-azure-sql-content-using-an-azure-cognitive-search-indexer"></a>Подключение к содержимому SQL Azure и его индексирование с помощью индексатора Azure Когнитивный поиск

Прежде чем можно будет выполнить запрос к [индексу Azure когнитивный Поиск](search-what-is-an-index.md), необходимо заполнить его данными. Если данные находятся в базе данных SQL Azure или Управляемый экземпляр SQL, **индексатор когнитивный Поиск Azure для базы данных SQL Azure** (или **индексатор SQL Azure** ) может автоматизировать процесс индексирования, что означает меньше кода для записи и меньшей инфраструктуры.

В этой статье рассматривается механизм использования [индексаторов](search-indexer-overview.md), а также описываются функции, доступные только в базе данных SQL Azure или управляемый экземпляр SQL (например, Интегрированное отслеживание изменений). 

В дополнение к базе данных SQL Azure и Управляемый экземпляр SQL Azure Когнитивный поиск предоставляет индексаторы для [Azure Cosmos DB](search-howto-index-cosmosdb.md), [хранилища BLOB-объектов Azure](search-howto-indexing-azure-blob-storage.md)и [хранилища таблиц Azure](search-howto-indexing-azure-tables.md). Чтобы запросить поддержку других источников данных, отправьте свой отзыв на [форум отзывов Azure когнитивный Поиск](https://feedback.azure.com/forums/263029-azure-search/).

## <a name="indexers-and-data-sources"></a>Индексаторы и источники данных

**Источник данных** определяет, какие данные следует индексировать, какие учетные данные требуются для доступа к данным и какие политики нужны, чтобы эффективно выявлять изменения в данных (новые, измененные или удаленные строки). Он определяется как независимый ресурс, который могут использовать несколько индексаторов.

**Индексатор** — это ресурс, соединяющий один источник данных с целевым индексом поиска. Индексатор используется в следующих случаях.

* однократное копирование данных для заполнения индекса;
* добавление в индекс изменений в источнике данных по расписанию;
* запуск по требованию для обновления индекса при необходимости.

Один индексатор может использовать только одну таблицу или представление, однако можно создать несколько индексаторов, если вы хотите заполнить несколько индексов поиска. Дополнительные сведения см. в статье [Indexer operations (Azure Search Service REST API)](/rest/api/searchservice/Indexer-operations#typical-workflow) (Операции с индексаторами в REST API службы поиска Azure).

Индексатор SQL Azure можно установить и настроить с помощью:

* мастера импорта данных на [портале Azure](https://portal.azure.com);
* [Пакет SDK](/dotnet/api/microsoft.azure.search.models.indexer) Azure когнитивный Поиск для .NET
* [REST API](/rest/api/searchservice/indexer-operations) когнитивный Поиск Azure

В этой статье мы будем использовать REST API для создания **индексаторов** и **источников данных**.

## <a name="when-to-use-azure-sql-indexer"></a>Когда следует использовать индексатор SQL Azure
Уместность использования индексатора Azure SQL зависит от нескольких факторов, связанных с данными. Если данные соответствуют следующим требованиям, вы можете использовать индексатор SQL Azure.

| Критерии | Подробнее |
|----------|---------|
| Источником данных является отдельная таблица или представление | Если данные разбиты по нескольким таблицам, можно создать одно представление данных. Однако при использовании представления вы не сможете использовать интегрированное отслеживание изменений SQL Server для обновления индекса с помощью добавочных изменений. Дополнительные сведения см. в разделе [Запись измененных и удаленных строк](#CaptureChangedRows) ниже. |
| Типы данных совместимы | В индексе Azure Когнитивный поиск поддерживаются большинство типов SQL, но не все. Список см. в разделе [Сопоставление типов данных](#TypeMapping). |
| Синхронизация данных в режиме реального времени необязательна | Индексатор может выполнять повторное индексирование таблицы не чаще, чем раз в пять минут. При частом изменении данных, которые должны быть отражены в индексе в течение нескольких секунд или минут, мы рекомендуем использовать [REST API](/rest/api/searchservice/AddUpdate-or-Delete-Documents) или [пакет SDK для .NET](./search-get-started-dotnet.md), чтобы отправлять обновленные строки напрямую. |
| Возможно добавочное индексирование | Если у вас есть большой набор данных и планируется запускать индексатор по расписанию, Azure Когнитивный поиск должен иметь возможность эффективно определять новые, измененные или удаленные строки. Недобавочное индексирование разрешено только при индексировании по требованию или при индексации менее 100 000 строк. Дополнительные сведения см. в разделе [Запись измененных и удаленных строк](#CaptureChangedRows) ниже. |

> [!NOTE] 
> Когнитивный поиск Azure поддерживает только проверку подлинности SQL Server. Если требуется поддержка для аутентификации Azure Active Directory, проголосуйте за это [предложение UserVoice](https://feedback.azure.com/forums/263029-azure-search/suggestions/33595465-support-azure-active-directory-password-authentica).

## <a name="create-an-azure-sql-indexer"></a>Создание индексатора SQL Azure

1. Создайте источник данных:

   ```
    POST https://myservice.search.windows.net/datasources?api-version=2020-06-30
    Content-Type: application/json
    api-key: admin-key

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "Server=tcp:<your server>.database.windows.net,1433;Database=<your database>;User ID=<your user name>;Password=<your password>;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;" },
        "container" : { "name" : "name of the table or view that you want to index" }
    }
   ```

   Строка подключения может соответствовать любому из следующих форматов:
    1. Вы можете получить строку подключения на [портале Azure](https://portal.azure.com). Используйте вариант `ADO.NET connection string`.
    1. Строка подключения управляемого удостоверения, которая не включает ключ учетной записи в следующем формате: `Initial Catalog|Database=<your database name>;ResourceId=/subscriptions/<your subscription ID>/resourceGroups/<your resource group name>/providers/Microsoft.Sql/servers/<your SQL Server name>/;Connection Timeout=connection timeout length;` . Чтобы использовать эту строку подключения, следуйте инструкциям по [настройке подключения индексатора к базе данных SQL Azure с помощью управляемого удостоверения](search-howto-managed-identities-sql.md).

2. Создайте целевой индекс Azure Когнитивный поиск, если он еще не создан. Создать индекс можно с помощью [портала](https://portal.azure.com) или [API создания индекса](/rest/api/searchservice/Create-Index). Убедитесь, что схема целевого индекса совместима со схемой исходной таблицы. см. раздел [Сопоставление типов данных поиска SQL и Microsoft Azure](#TypeMapping).

3. Создайте индексатор, задав ему имя и связав источник данных с целевым индексом:

   ```
    POST https://myservice.search.windows.net/indexers?api-version=2020-06-30
    Content-Type: application/json
    api-key: admin-key

    {
        "name" : "myindexer",
        "dataSourceName" : "myazuresqldatasource",
        "targetIndexName" : "target index name"
    }
   ```

У индексатора, созданного таким образом, нет расписания. Он автоматически выполняется один раз сразу после создания. Вы можете снова выполнить его в любой момент с помощью запроса на **запуск индексатора** :

```
    POST https://myservice.search.windows.net/indexers/myindexer/run?api-version=2020-06-30
    api-key: admin-key
```

Вы можете настроить несколько аспектов поведения индексатора, например размер пакета и сколько документов можно пропустить, прежде чем выполнение индексатора завершится с ошибкой. Чтобы узнать больше, ознакомьтесь с [API создания индексатора](/rest/api/searchservice/Create-Indexer).

Вам может потребоваться разрешить службам Azure подключаться к вашей базе данных. Сведения о том, как это сделать, см. в разделе [Подключение из Azure](../azure-sql/database/firewall-configure.md).

Для наблюдения за состоянием индексатора и журналом выполнения (количество проиндексированных элементов, ошибки и т. д.) используйте запрос на получение **состояния индексатора**:

```
    GET https://myservice.search.windows.net/indexers/myindexer/status?api-version=2020-06-30
    api-key: admin-key
```

Ответ должен выглядеть так:

```
    {
        "\@odata.context":"https://myservice.search.windows.net/$metadata#Microsoft.Azure.Search.V2015_02_28.IndexerExecutionInfo",
        "status":"running",
        "lastResult": {
            "status":"success",
            "errorMessage":null,
            "startTime":"2015-02-21T00:23:24.957Z",
            "endTime":"2015-02-21T00:36:47.752Z",
            "errors":[],
            "itemsProcessed":1599501,
            "itemsFailed":0,
            "initialTrackingState":null,
            "finalTrackingState":null
        },
        "executionHistory":
        [
            {
                "status":"success",
                "errorMessage":null,
                "startTime":"2015-02-21T00:23:24.957Z",
                "endTime":"2015-02-21T00:36:47.752Z",
                "errors":[],
                "itemsProcessed":1599501,
                "itemsFailed":0,
                "initialTrackingState":null,
                "finalTrackingState":null
            },
            ... earlier history items
        ]
    }
```

Журнал выполнения включает до 50 записей о недавно завершенных запусках, которые сортируются в обратном хронологическом порядке (то есть в ответе первым отображается последний запуск).
Дополнительные сведения об ответе см. [здесь](/rest/api/searchservice/get-indexer-status).

## <a name="run-indexers-on-a-schedule"></a>Запуск индексаторов по расписанию
Вы также можете организовать запуск индикатора по расписанию. Для этого добавьте свойство **schedule** при создании или обновлении индексатора. В примере ниже показан PUT- запрос для обновления индексатора:

```
    PUT https://myservice.search.windows.net/indexers/myindexer?api-version=2020-06-30
    Content-Type: application/json
    api-key: admin-key

    {
        "dataSourceName" : "myazuresqldatasource",
        "targetIndexName" : "target index name",
        "schedule" : { "interval" : "PT10M", "startTime" : "2015-01-01T00:00:00Z" }
    }
```

Параметр **interval** обязателен. Он указывает время между двумя последовательными запусками индексатора. Наименьшее допустимое значение — 5 минут, наибольшее — один день. Значение должно быть отформатировано как значение dayTimeDuration XSD (ограниченное подмножество значения [продолжительности ISO 8601](https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration) ). Используется следующий шаблон: `P(nD)(T(nH)(nM))`. Примеры: `PT15M` для каждых 15 минут, `PT2H` для каждых 2 часов.

Дополнительные сведения об определении расписаний индексаторов для Когнитивного поиска Azure см. [здесь](search-howto-schedule-indexers.md).

<a name="CaptureChangedRows"></a>

## <a name="capture-new-changed-and-deleted-rows"></a>Запись новых, измененных и удаленных строк

Когнитивный поиск Azure использует **добавочное индексирование** , чтобы избежать повторного индексирования всей таблицы или представления при каждом запуске индексатора. Когнитивный поиск Azure предоставляет две политики обнаружения изменений для поддержки добавочного индексирования. 

### <a name="sql-integrated-change-tracking-policy"></a>Интегрированная политика отслеживания изменений SQL
Если база данных SQL поддерживает [Отслеживание изменений](/sql/relational-databases/track-changes/about-change-tracking-sql-server), рекомендуется использовать **встроенную политику отслеживание изменений SQL**. Это наиболее эффективная политика. Кроме того, он позволяет Azure Когнитивный поиск выявление удаленных строк без необходимости добавления в таблицу явного столбца "обратимого удаления".

#### <a name="requirements"></a>Требования 

+ Требования к версии базы данных:
  * SQL Server 2012 SP3 и более поздних версий, если вы используете SQL Server на виртуальных машинах Azure.
  * База данных SQL Azure или SQL Управляемый экземпляр.
+ Только таблицы (представлений нет). 
+ В базе данных [включите отслеживание изменений](/sql/relational-databases/track-changes/enable-and-disable-change-tracking-sql-server) таблицы. 
+ Нет составного первичного ключа (первичный ключ, содержащий более одного столбца) в таблице.  

#### <a name="usage"></a>Использование

Чтобы использовать эту политику, создайте или обновите источник данных следующим образом:

```
    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "connection string" },
        "container" : { "name" : "table or view name" },
        "dataChangeDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
      }
    }
```

При использовании интегрированной политики отслеживания изменений SQL не указывайте отдельную политику обнаружения удаления данных, так как она уже поддерживает выявление удаленных строк. Однако, чтобы автоматически обнаруживать удаления, ключ документа в индексе поиска должен быть таким же, что и основной ключ в таблице SQL. 

> [!NOTE]  
> При использовании [TRUNCATE TABLE](/sql/t-sql/statements/truncate-table-transact-sql) для удаления большого количества строк из таблицы SQL необходимо, чтобы индексатор был [сброшен](/rest/api/searchservice/reset-indexer), чтобы сбросить состояние отслеживания изменений для сбора удалений строк.

<a name="HighWaterMarkPolicy"></a>

### <a name="high-water-mark-change-detection-policy"></a>Политика обнаружения изменений максимального уровня

Политика обнаружения изменений зависит от столбца изменений максимального уровня, записывающего версию или время последнего обновления строки. При использовании представления следует использовать политику максимального уровня. Столбец максимального уровня должен соответствовать следующим требованиям.

#### <a name="requirements"></a>Требования 

* при каждой вставке указывается значение для столбца;
* при всех обновлениях элементов также изменяется значение столбца;
* значение этого столбца растет с каждой вставкой или обновлением;
* Возможно эффективное выполнение запросов со следующими предложениями WHERE и ORDER BY: `WHERE [High Water Mark Column] > [Current High Water Mark Value] ORDER BY [High Water Mark Column]`.

> [!IMPORTANT] 
> Настоятельно рекомендуется использовать тип данных [rowversion](/sql/t-sql/data-types/rowversion-transact-sql) для столбца максимального уровня. В случае использования любого другого типа данных не гарантируется запись всех изменений при наличии транзакций, выполняемых параллельно с запросом индексатора. При использовании **rowversion** в конфигурации с репликами только для чтения необходимо указать индексатор на первичной реплике. Только первичная реплика может использоваться для сценариев синхронизации данных.

#### <a name="usage"></a>Использование

Чтобы использовать политику верхнего предела, создайте или обновите источник данных следующим образом.

```
    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "connection string" },
        "container" : { "name" : "table or view name" },
        "dataChangeDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
           "highWaterMarkColumnName" : "[a rowversion or last_updated column name]"
      }
    }
```

> [!WARNING]
> Если в исходной таблице нет индекса в столбце верхнего уровня, то время ожидания запросов, используемых индексатором SQL, может истекает. В частности, `ORDER BY [High Water Mark Column]` предложение требует эффективного выполнения индекса, если таблица содержит много строк.
>
>

<a name="convertHighWaterMarkToRowVersion"></a>

##### <a name="converthighwatermarktorowversion"></a>конверсигхватермаркторовверсион

Если вы используете тип данных [rowversion](/sql/t-sql/data-types/rowversion-transact-sql) для столбца высокой подложки, попробуйте использовать `convertHighWaterMarkToRowVersion` параметр конфигурации индексатора. `convertHighWaterMarkToRowVersion` выполняет две задачи:

* Используйте тип данных rowversion для столбца верхнего уровня пометки в запросе SQL индексатора. Использование правильного типа данных повышает производительность запросов индексатора.
* Вычтите 1 из значения rowversion перед выполнением запроса индексатора. Представления с числом соединений от 1 до нескольких могут содержать строки с повторяющимися значениями rowversion. Вычитание 1 гарантирует, что запрос индексатора не пропустил эти строки.

Чтобы включить эту функцию, создайте или обновите индексатор со следующей конфигурацией:

```
    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "convertHighWaterMarkToRowVersion" : true } }
    }
```

<a name="queryTimeout"></a>

##### <a name="querytimeout"></a>queryTimeout

Если возникают ошибки времени ожидания, можно использовать параметр конфигурации индексатора `queryTimeout`, чтобы задать время ожидания запроса, превышающее время ожидания по умолчанию, равное 5 минутам. Например, чтобы задать время ожидания, равное 10 минутам, создайте или обновите индексатор, используя приведенную ниже конфигурацию.

```
    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "queryTimeout" : "00:10:00" } }
    }
```

<a name="disableOrderByHighWaterMarkColumn"></a>

##### <a name="disableorderbyhighwatermarkcolumn"></a>disableOrderByHighWaterMarkColumn

Можно также отключить предложение `ORDER BY [High Water Mark Column]`. Однако это не рекомендуется, так как в случае прерывания выполнения индексатора из-за ошибки ему придется повторно обработать все строки при последующем запуске, даже если на момент прерывания почти все из них уже были обработаны. Чтобы отключить предложение `ORDER BY`, используйте параметр `disableOrderByHighWaterMarkColumn` в определении индексатора.  

```
    {
     ... other indexer definition properties
     "parameters" : {
            "configuration" : { "disableOrderByHighWaterMarkColumn" : true } }
    }
```

### <a name="soft-delete-column-deletion-detection-policy"></a>Политика обнаружения обратимого удаления столбца
Строки, удаляемые из исходной таблицы, вероятно, также следует удалить из индекса поиска. Если вы используете интегрированную политику отслеживания изменений SQL, это происходит автоматически. Однако политика отслеживания изменений максимального уровня не затрагивает удаленные строки. Что делать?

Если строки физически удаляются из таблицы, Когнитивный поиск Azure не имеет возможности определить наличие записей, которые больше не существуют.  Тем не менее можно использовать метод обратимого удаления, чтобы логически удалять строки, не удаляя их из таблицы. Добавьте специальный столбец в таблицу или представление и помечайте удаленные строки с помощью этого столбца.

При использовании метода обратимого удаления можно указать соответствующую политику во время создания или обновления источника данных:

```
    {
        …,
        "dataDeletionDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
           "softDeleteColumnName" : "[a column name]",
           "softDeleteMarkerValue" : "[the value that indicates that a row is deleted]"
        }
    }
```

Параметр **softDeleteMarkerValue** должен быть строкой. Используйте строковое представление действительного значения. Например, если имеется столбец целочисленных значений, в котором удаленные строки помечаются значением 1, то следует использовать `"1"`. Если имеется битовый столбец, в котором удаленные строки помечаются логическим значением true, то используйте строковый литерал `True` или `true`, при этом регистр значения не имеет.

<a name="TypeMapping"></a>

## <a name="mapping-between-sql-and-azure-cognitive-search-data-types"></a>Сопоставление типов данных SQL и Azure Когнитивный поиск
| Тип данных SQL | Совместимые типы полей целевого индекса | Примечания |
| --- | --- | --- |
| bit |Edm.Boolean, Edm.String | |
| int, smallint, tinyint |Edm.Int32, Edm.Int64, Edm.String | |
| BIGINT |Edm.Int64, Edm.String | |
| real, float |Edm.Double, Edm.String | |
| smallmoney, money decimal numeric |Edm.String |Когнитивный поиск Azure не поддерживает преобразование десятичных типов в EDM. Double, так как это приведет к потере точности |
| char, nchar, varchar, nvarchar |Edm.String<br/>Collection(Edm.String) |Для заполнения поля Collection(Edm.String) может использоваться строка SQL, если она представляет массив строк JSON: `["red", "white", "blue"]`. |
| smalldatetime, datetime, datetime2, date, datetimeoffset |Edm.DateTimeOffset, Edm.String | |
| uniqueidentifer |Edm.String | |
| geography |Edm.GeographyPoint |Поддерживаются только географические объекты типа POINT с SRID 4326 (значение по умолчанию). |
| rowversion |Недоступно |Столбцы версии строк не могут храниться в индексе поиска, но их можно использовать для отслеживания изменений. |
| time, timespan, binary, varbinary, image, xml, geometry, CLR types |Недоступно |Не поддерживается |

## <a name="configuration-settings"></a>Параметры конфигурации
Индексатор SQL предоставляет несколько параметров конфигурации.

| Параметр | Тип данных | Назначение | Значение по умолчанию |
| --- | --- | --- | --- |
| queryTimeout |строка |Задает время ожидания для выполнения запроса SQL. |5 мин ("00:05:00") |
| disableOrderByHighWaterMarkColumn |bool |Указывает SQL-запросу, используемому политикой верхнего предела, опустить предложение ORDER BY. Ознакомьтесь с [политикой верхнего предела](#HighWaterMarkPolicy). |false |

Эти параметры используются в объекте `parameters.configuration` в определении индексатора. Например, чтобы задать время ожидания запроса, равное 10 минутам, создайте или обновите индексатор, используя приведенную ниже конфигурацию.

```
    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "queryTimeout" : "00:10:00" } }
    }
```

## <a name="faq"></a>ВОПРОСЫ И ОТВЕТЫ

**Вопрос. можно ли использовать индексатор SQL Azure с базами данных SQL, работающими на виртуальных машинах IaaS в Azure?**

Да. Тем не менее необходимо разрешить службе поиска подключаться к базе данных. Дополнительные сведения см. в статье [Настройка подключения из индексатора когнитивный Поиск Azure для SQL Server на виртуальной машине Azure](search-howto-connecting-azure-sql-iaas-to-azure-search-using-indexers.md).

**Вопрос. Можно ли использовать индексатор SQL Azure с локальными базами данных SQL?**

Не напрямую. Мы не рекомендуем и не поддерживаем прямое соединение, так как в таком случае вам придется открыть свои базы данных для интернет-трафика. Клиенты преуспели в этом сценарии, используя технологии моста, такие как фабрика данных Azure. Дополнительные сведения см. [в статье отправка данных в индекс azure когнитивный Поиск с помощью фабрики данных Azure](../data-factory/v1/data-factory-azure-search-connector.md).

**Вопрос. можно ли использовать индексатор SQL Azure с базами данных, отличными от SQL Server, работающих в IaaS в Azure?**

Нет. Мы не поддерживаем этот сценарий, так как мы не проверяли работу индексатора с базами данных не из SQL Server.  

**Вопрос. можно ли создать несколько индексаторов, работающих по расписанию?**

Да. Но на одном узле одновременно может выполнять обработку только один индексатор. Если вам требуется, чтобы одновременно работали несколько индексаторов, вы можете расширить службу поиска, добавив несколько модулей поиска.

**Вопрос. влияет ли работа индексатора на рабочую нагрузку запроса?**

Да. Индексатор выполняется на одном из узлов службы поиска, и ресурсы этого узла распределяются между выполнением индексирования, обслуживанием трафика запросов и другими запросами API. Если вы запускаете ресурсоемкие рабочие нагрузки для индексирования и запросов и сталкиваетесь с высокой частотой 503 ошибок или увеличением времени ответа, рассмотрите возможность [масштабирования службы поиска](search-capacity-planning.md).

**Вопрос. Можно ли использовать вторичную реплику в [отказоустойчивом кластере](../azure-sql/database/auto-failover-group-overview.md) в качестве источника данных?**

Это зависит от нескольких условий. Для полной индексации таблицы или представления можно использовать вторичные реплики. 

Для добавочного индексирования Azure Когнитивный поиск поддерживает две политики обнаружения изменений: Интегрированное отслеживание изменений SQL и верхняя маркировка воды.

В репликах только для чтения база данных SQL не поддерживает Интегрированное отслеживание изменений. Таким образом необходимо использовать политику максимального уровня. 

Стандартно рекомендуется использовать тип данных rowversion для столбца максимального уровня. Однако использование rowversion зависит от `MIN_ACTIVE_ROWVERSION` функции, которая не поддерживается в репликах только для чтения. Таким образом необходимо направить индексатор на первичную реплику при использовании rowversion.

При попытке использовать rowversion с репликой только для чтения появится следующая ошибка: 

"Использование столбца rowversion для отслеживания изменений не поддерживается во вторичных репликах доступности (только для чтения). Обновите источник данных и укажите соединение с первичной репликой доступности. Свойство "обновление текущей базы данных" имеет значение "READ_ONLY" ".

**Вопрос. Можно ли использовать другой столбец, не rowversion, для отслеживания изменений максимального уровня?**

Не рекомендуется. Только **rowversion** обеспечивает надежную синхронизацию данных. Но в зависимости от логики приложения это может быть безопасно, если:

+ Вы можете убедиться, что при запуске индексатора нет необработанных транзакций в индексируемой таблице (например, все обновления таблицы выполняются в виде пакета по расписанию, а Когнитивный поиск расписание индексатора Azure настроено так, чтобы не перекрываться с расписанием обновления таблицы).  

+ Вы периодически выполняете полное повторное индексирование, чтобы обнаружить все пропущенные строки.