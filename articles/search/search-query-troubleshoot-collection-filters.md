---
title: Устранение неполадок фильтров коллекции OData — Поиск Azure
description: Устранение ошибок фильтра коллекции OData в запросах поиска Azure.
ms.date: 06/13/2019
services: search
ms.service: search
ms.topic: conceptual
author: brjohnstmsft
ms.author: brjohnst
manager: nitinme
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: fbd43cc13d3b7377668aad2fadc874ae47422ee1
ms.sourcegitcommit: bb8e9f22db4b6f848c7db0ebdfc10e547779cccc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2019
ms.locfileid: "69647956"
---
# <a name="troubleshooting-odata-collection-filters-in-azure-search"></a>Устранение неполадок фильтров коллекции OData в службе поиска Azure

Для [фильтрации](query-odata-filter-orderby-syntax.md) по полям коллекции в службе поиска Azure можно использовать [ `any` операторы и `all` ](search-query-odata-collection-operators.md) вместе с **лямбда-выражениями**. Лямбда-выражение — это вложенный фильтр, применяемый к каждому элементу коллекции.

Не все функции выражений фильтров доступны внутри лямбда-выражения. Доступные функции различаются в зависимости от типа данных поля коллекции, которое необходимо отфильтровать. Это может привести к ошибке при попытке использовать функцию в лямбда-выражении, которое не поддерживается в этом контексте. Если при попытке записи сложного фильтра по полям коллекции возникают такие ошибки, эта статья поможет вам устранить проблему.

## <a name="common-collection-filter-errors"></a>Распространенные ошибки фильтра коллекции

В следующей таблице перечислены ошибки, которые могут возникнуть при попытке выполнить фильтр коллекции. Эти ошибки возникают при использовании функции выражений фильтров, которые не поддерживаются внутри лямбда-выражения. Каждая ошибка дает некоторые рекомендации о том, как можно переписать фильтр, чтобы избежать ошибки. В таблице также содержится ссылка на соответствующий раздел этой статьи, где содержатся дополнительные сведения о том, как избежать этой ошибки.

| Сообщение об ошибке | Такая | Дополнительные сведения см. на странице |
| --- | --- | --- |
| Функция "несоответствие" не имеет параметров, привязанных к переменной диапазона ". Внутри лямбда-выражений ("Any" или "ALL") поддерживаются только ссылки на связанные поля. Измените фильтр так, чтобы функция "не совпала" находилась за пределами лямбда-выражения, и повторите попытку. | Использование `search.ismatch` или`search.ismatchscoring` в лямбда-выражении | [Правила фильтрации сложных коллекций](#bkmk_complex) |
| Недопустимое лямбда-выражение. Обнаружена проверка на равенство или неравенство в лямбда-выражении, которое выполняет итерацию по полю коллекции типа (EDM. String). Для Any используйте выражения вида "x EQ y" или "search.in (...)". Для "ALL" используйте выражения в форме "x Ne y", "not (x EQ y)" или "not search.in (...)". | Фильтрация по полю типа`Collection(Edm.String)` | [Правила фильтрации коллекций строк](#bkmk_strings) |
| Недопустимое лямбда-выражение. Обнаружена неподдерживаемая форма сложного логического выражения. Для Any используйте выражения, которые имеют вид "or of and", также известный как Дисжунктиве обычная форма. Например: "(a и b) или (c и d)", где a, b, c и d являются подвыражениями сравнения или равенства. Для "ALL" используйте выражения, которые имеют вид "and of or", также известный как был соединительным обычная форма. Например: "(a или b) и (c или d)", где a, b, c и d являются подвыражениями сравнения или неравенства. Примеры выражений сравнения: "x gt 5", "x Le 2". Пример выражения равенства: "x EQ 5". Пример выражения неравенства: "x Ne 5". | Фильтрация по полям типа `Collection(Edm.DateTimeOffset)`, `Collection(Edm.Double)`, `Collection(Edm.Int32)`или`Collection(Edm.Int64)` | [Правила фильтрации сравниваемых коллекций](#bkmk_comparables) |
| Недопустимое лямбда-выражение. Обнаружено неподдерживаемое использование Geo. Distance () или Geo. intersects в лямбда-выражении, которое выполняет итерацию по полю коллекции типа (EDM. GeographyPoint). Для Any убедитесь, что вы сравниваете Geo. Distance () с помощью операторов "lt" или "Le" и убедитесь, что любое использование Geo. intersects () не имеет отрицания. Для "ALL" убедитесь, что вы сравниваете Geo. Distance () с помощью операторов "gt" или "GE" и убедитесь, что любое использование Geo. intersects () имеет отрицание. | Фильтрация по полю типа`Collection(Edm.GeographyPoint)` | [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints) |
| Недопустимое лямбда-выражение. Сложные логические выражения не поддерживаются в лямбда-выражениях, которые выполняют итерации по полям типа Collection (EDM. GeographyPoint). Для Any необходимо объединить подвыражения с "или"; "and" не поддерживается. Для "ALL" необходимо объединить подвыражения с "и"; "или" не поддерживается. | Фильтрация по полям типа `Collection(Edm.String)` или`Collection(Edm.GeographyPoint)` | [Правила фильтрации коллекций строк](#bkmk_strings) <br/><br/> [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints) |
| Недопустимое лямбда-выражение. Обнаружен оператор сравнения (один из "lt", "Le", "gt" или "GE"). В лямбда-выражениях, которые просматривают поля коллекции типа (EDM. String), допускаются только операторы равенства. Для Any используйте выражения вида "x EQ y". Для "ALL" используйте выражения в форме "x Ne y" или "not (x EQ y)". | Фильтрация по полю типа`Collection(Edm.String)` | [Правила фильтрации коллекций строк](#bkmk_strings) |

<a name="bkmk_examples"></a>

## <a name="how-to-write-valid-collection-filters"></a>Написание допустимых фильтров коллекции

Правила записи допустимых фильтров коллекции различаются для каждого типа данных. В следующих разделах описываются правила, в которых показаны примеры поддерживаемых функций фильтров, а какие нет:

- [Правила фильтрации коллекций строк](#bkmk_strings)
- [Правила фильтрации логических коллекций](#bkmk_bools)
- [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints)
- [Правила фильтрации сравниваемых коллекций](#bkmk_comparables)
- [Правила фильтрации сложных коллекций](#bkmk_complex)

<a name="bkmk_strings"></a>

## <a name="rules-for-filtering-string-collections"></a>Правила фильтрации коллекций строк

В лямбда-выражениях для коллекций строк можно использовать `eq` только операторы сравнения и. `ne`

> [!NOTE]
> `lt` Поиск Azure не поддерживает / `le` операторыдля/ строк, вне зависимости от лямбда-выражения или за его пределами. `gt` / `ge`

Текст `any` может проверяться на равенство только в том случае, если текст `all` может проверяться на неравенство.

Можно `or` также объединить несколько выражений `any`, используя в теле, и через `and` в теле `all`. Поскольку функция эквивалентна объединению проверок равенства с `or`, она также разрешена `any`в теле. `search.in` И наоборот, `not search.in` допускается в теле `all`.

Например, следующие выражения разрешены:

- `tags/any(t: t eq 'books')`
- `tags/any(t: search.in(t, 'books, games, toys'))`
- `tags/all(t: t ne 'books')`
- `tags/all(t: not (t eq 'books'))`
- `tags/all(t: not search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' or t eq 'games')`
- `tags/all(t: t ne 'books' and not (t eq 'games'))`

Хотя эти выражения не допускаются:

- `tags/any(t: t ne 'books')`
- `tags/any(t: not search.in(t, 'books, games, toys'))`
- `tags/all(t: t eq 'books')`
- `tags/all(t: search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' and t ne 'games')`
- `tags/all(t: t ne 'books' or not (t eq 'games'))`

<a name="bkmk_bools"></a>

## <a name="rules-for-filtering-boolean-collections"></a>Правила фильтрации логических коллекций

Тип `Edm.Boolean` поддерживает `ne` только операторы и. `eq` Таким образом, не имеет смысла разрешать сочетание таких предложений, которые проверяют ту же переменную диапазона, `and` с / `or` момента, когда это всегда приведет к таутологиес или противоречию.

Ниже приведены некоторые примеры фильтров для логических коллекций, которые разрешены:

- `flags/any(f: f)`
- `flags/all(f: f)`
- `flags/any(f: f eq true)`
- `flags/any(f: f ne true)`
- `flags/all(f: not f)`
- `flags/all(f: not (f eq true))`

В отличие от коллекций строк, логические коллекции не имеют ограничений на то, какой оператор можно использовать в лямбда-выражении. И, `ne` и `all` могут`any` использоваться в теле или. `eq`

Следующие выражения не допускаются для логических коллекций:

- `flags/any(f: f or not f)`
- `flags/any(f: f or f)`
- `flags/all(f: f and not f)`
- `flags/all(f: f and f eq true)`

<a name="bkmk_geopoints"></a>

## <a name="rules-for-filtering-geographypoint-collections"></a>Правила фильтрации GeographyPointных коллекций

Значения типа `Edm.GeographyPoint` в коллекции не могут сравниваться напрямую друг с другом. Вместо этого они должны использоваться в качестве параметров `geo.distance` функций и. `geo.intersects` Функция `geo.distance` , в свою очередь, должна сравниваться со значением расстояния с помощью одного из операторов `lt`сравнения `le`, `gt`, или `ge`. Эти правила также применяются к полям EDM. GeographyPoint, не относящимся к коллекции.

Как и коллекции строк `Edm.GeographyPoint` , коллекции имеют некоторые правила для использования геопространственных функций и объединения в различных типах лямбда-выражений.

- Операторы сравнения, которые можно использовать с функцией `geo.distance` , зависят от типа лямбда-выражения. Для `any`можно использовать только `lt` или `le`. Для `all`можно использовать только `gt` или `ge`. Можно инвертировать выражения, включающие `geo.distance`, но необходимо изменить оператор сравнения (`geo.distance(...) lt x` он станет `not (geo.distance(...) ge x)` и `geo.distance(...) le x` станет `not (geo.distance(...) gt x)`).
- В теле `all` `geo.intersects` функции функция должна быть инвертирована. И наоборот, в теле `any` `geo.intersects` функции не следует инвертировать отрицание.
- В тексте `any`геопространственных выражений можно комбинировать с помощью `or`. В тексте `all`такие выражения можно комбинировать с помощью `and`.

Указанные выше ограничения существуют по тем же причинам, что и ограничения на равенство и неравенство в коллекциях строк. Более подробные сведения по этим причинам см. в статье Знакомство с [фильтрами коллекции OData в службе поиска Azure](search-query-understand-collection-filters.md) .

Ниже приведены некоторые примеры фильтров для `Edm.GeographyPoint` коллекций, которые разрешены:

- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: not (geo.distance(l, geography'POINT(-122 49)') ge 10) or geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') ge 10 and not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

Следующие выражения не разрешены для `Edm.GeographyPoint` коллекций:

- `locations/any(l: l eq geography'POINT(-122 49)')`
- `locations/any(l: not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') gt 10)`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10 and geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') le 10 or not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

<a name="bkmk_comparables"></a>

## <a name="rules-for-filtering-comparable-collections"></a>Правила фильтрации сравниваемых коллекций

Этот раздел относится ко всем следующим типам данных:

- `Collection(Edm.DateTimeOffset)`
- `Collection(Edm.Double)`
- `Collection(Edm.Int32)`
- `Collection(Edm.Int64)`

Типы, такие `Edm.Int32` как `Edm.DateTimeOffset` и, поддерживают все шесть операторов сравнения `le` `lt` `eq` `ne` :,`ge`,, ,и.`gt` Лямбда-выражения над коллекциями этих типов могут содержать простые выражения, использующие любой из этих операторов. Это относится `any` и к, `all`и к. Например, эти фильтры разрешены:

- `ratings/any(r: r ne 5)`
- `dates/any(d: d gt 2017-08-24T00:00:00Z)`
- `not margins/all(m: m eq 3.5)`

Однако существуют ограничения на то, как такие выражения сравнения могут быть объединены в более сложные выражения в лямбда-выражении:

- Правила для `any`:
  - Простые выражения неравенства не могут быть полезны вместе с другими выражениями. Например, это выражение разрешено:
    - `ratings/any(r: r ne 5)`

    но это выражение не так:
    - `ratings/any(r: r ne 5 and r gt 2)`

    и хотя это выражение разрешено, оно не полезно, поскольку условия перекрываются:
    - `ratings/any(r: r ne 5 or r gt 7)`
  - Простые `eq`выражения сравнения `or` `and` /, включающие `lt`, `gt` `ge` ,, или, могут сочетаться с. `le` Пример:
    - `ratings/any(r: r gt 2 and r le 5)`
    - `ratings/any(r: r le 5 or r gt 7)`
  - Выражения сравнения, Объединенные с (объединения), `and` можно объединять с помощью. `or` Эта форма известна в логической логике как "[Дисжунктиве обычная форма](https://en.wikipedia.org/wiki/Disjunctive_normal_form)" (ДНФ). Пример:
    - `ratings/any(r: (r gt 2 and r le 5) or (r gt 7 and r lt 10))`
- Правила для `all`:
  - Простые выражения равенства не могут быть полезны вместе с другими выражениями. Например, это выражение разрешено:
    - `ratings/all(r: r eq 5)`

    но это выражение не так:
    - `ratings/all(r: r eq 5 or r le 2)`

    и хотя это выражение разрешено, оно не полезно, поскольку условия перекрываются:
    - `ratings/all(r: r eq 5 and r le 7)`
  - Простые `ne`выражения сравнения `or` `and` /, включающие `lt`, `gt` `ge` ,, или, могут сочетаться с. `le` Пример:
    - `ratings/all(r: r gt 2 and r le 5)`
    - `ratings/all(r: r le 5 or r gt 7)`
  - Выражения сравнения в сочетании `or` с (дизъюнкции) можно объединять с помощью. `and` Эта форма известна в логической логике как "[был соединительным обычная форма](https://en.wikipedia.org/wiki/Conjunctive_normal_form)" (cnf). Пример:
    - `ratings/all(r: (r le 2 or gt 5) and (r lt 7 or r ge 10))`

<a name="bkmk_complex"></a>

## <a name="rules-for-filtering-complex-collections"></a>Правила фильтрации сложных коллекций

Лямбда-выражения над сложными коллекциями поддерживают гораздо более гибкий синтаксис, чем лямбда-выражения над коллекциями примитивных типов. В таком лямбда-выражении можно использовать любую конструкцию фильтра, которую можно использовать за пределами, за исключением двух исключений.

Сначала функции `search.ismatch` и `search.ismatchscoring` не поддерживаются внутри лямбда-выражений. Дополнительные сведения см. [в разделе Основные сведения о фильтрах коллекции OData в службе поиска Azure](search-query-understand-collection-filters.md).

Во-вторых, не допускаются ссылки на поля, которые не *привязаны* к переменной диапазона (так называемые *свободные переменные*). Например, рассмотрим следующие два эквивалентных выражения фильтра OData:

1. `stores/any(s: s/amenities/any(a: a eq 'parking')) and details/margin gt 0.5`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and details/margin gt 0.5))`

Первое выражение будет разрешено, а вторая форма будет отклонена, так как `details/margin` не привязана к переменной `s`диапазона.

Это правило также распространяется на выражения, которые имеют переменные, привязанные во внешней области. Такие переменные свободны по отношению к области, в которой они отображаются. Например, первое выражение разрешено, а второе эквивалентное выражение не допускается, так как `s/name` является свободным по отношению к области переменной `a`диапазона:

1. `stores/any(s: s/amenities/any(a: a eq 'parking') and s/name ne 'Flagship')`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and s/name ne 'Flagship'))`

Это ограничение не должно быть проблемой на практике, поскольку всегда можно создавать фильтры таким, чтобы лямбда-выражения содержали только привязанные переменные.

## <a name="cheat-sheet-for-collection-filter-rules"></a>Лист Памятка по для правил фильтра коллекции

В следующей таблице перечислены правила построения допустимых фильтров для каждого типа данных коллекции.

[!INCLUDE [Limitations on OData lambda expressions in Azure Search](../../includes/search-query-odata-lambda-limitations.md)]

Примеры создания допустимых фильтров для каждого варианта см. [в разделе как записать допустимые фильтры коллекции](#bkmk_examples).

Если вы часто пишете фильтры и понимаете, что правила из первых принципов могли бы помочь вам больше, чем просто запомнить их, см. раздел [Общие сведения о фильтрах коллекции OData в службе поиска Azure](search-query-understand-collection-filters.md).

## <a name="next-steps"></a>Следующие шаги  

- [Общие сведения о фильтрах коллекции OData в службе поиска Azure](search-query-understand-collection-filters.md)
- [Фильтры в службе "Поиск Azure"](search-filters.md)
- [Общие сведения о языке выражений OData для поиска Azure](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для поиска Azure](search-query-odata-syntax-reference.md)
- [Search Documents (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/Search-Documents) (Поиск по документам (REST API службы "Поиск Azure"))
