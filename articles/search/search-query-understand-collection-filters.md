---
title: Основные сведения о фильтрах коллекции OData
titleSuffix: Azure Cognitive Search
description: Общие сведения о работе фильтров коллекции OData в Когнитивный поиск запросах Azure.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: 9a57e1d16b13d822b6f5b541a7f838b0dd3a69ad
ms.sourcegitcommit: b050c7e5133badd131e46cab144dd5860ae8a98e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/23/2019
ms.locfileid: "72794392"
---
# <a name="understanding-odata-collection-filters-in-azure-cognitive-search"></a>Основные сведения о фильтрах коллекции OData в Azure Когнитивный поиск

Для [фильтрации](query-odata-filter-orderby-syntax.md) по полям коллекции в когнитивный Поиск Azure можно использовать [операторы`any` и `all`](search-query-odata-collection-operators.md) вместе с **лямбда-выражениями**. Лямбда-выражения — это логические выражения, которые ссылаются на **переменную диапазона**. Операторы `any` и `all` аналогичны циклу `for` в большинстве языков программирования, с переменной диапазона, принимающей роль переменной цикла, и лямбда-выражением в качестве тела цикла. Переменная диапазона принимает значение Current в коллекции во время итерации цикла.

По крайней мере, это работает по принципу концептуально. На самом деле, Azure Когнитивный поиск реализует фильтры по-другому, как работает `for` циклы. В идеале это различие будет невидимым для вас, но в некоторых ситуациях это не так. Конечный результат заключается в том, что при написании лямбда-выражений необходимо следовать правилам.

В этой статье объясняется, почему правила для фильтров коллекции существуют, изучив, как Azure Когнитивный поиск выполняет эти фильтры. Если вы пишете расширенные фильтры с помощью сложных лямбда-выражений, эта статья поможет вам получить представление о возможностях фильтров и о том, почему.

Сведения о правилах фильтров коллекции, включая примеры, см. [в разделе Устранение неполадок фильтров коллекции OData в когнитивный Поиск Azure](search-query-troubleshoot-collection-filters.md).

## <a name="why-collection-filters-are-limited"></a>Почему фильтры коллекции ограничены

Существуют три основные причины, по которым не все функции фильтра поддерживаются для всех типов коллекций:

1. Для определенных типов данных поддерживаются только определенные операторы. Например, не имеет смысла сравнивать логические значения `true` и `false` с помощью `lt`, `gt`и т. д.
1. Когнитивный поиск Azure не поддерживает **коррелированный Поиск** по полям типа `Collection(Edm.ComplexType)`.
1. Когнитивный поиск Azure использует Инвертированные индексы для выполнения фильтров по всем типам данных, включая коллекции.

Первая причина — это лишь следствие того, как определяются язык OData и система типов EDM. Последние два более подробно описаны в оставшейся части этой статьи.

## <a name="correlated-versus-uncorrelated-search"></a>Коррелированный и некоррелированный Поиск

При применении нескольких условий фильтра к коллекции сложных объектов эти **критерии сопоставляются, так как** они применяются к *каждому объекту в коллекции*. Например, следующий фильтр возвратит Гостиницы, у которых есть хотя бы одна комната Deluxe с частотой менее 100:

    Rooms/any(room: room/Type eq 'Deluxe Room' and room/BaseRate lt 100)

Если фильтрация была *некоррелированной*, то приведенный выше фильтр может вернуть Гостиницы, где одна комната — Deluxe, а другая комната будет иметь базовый уровень менее 100. Это не имеет смысла, так как оба предложения лямбда-выражения применяются к одной и той же переменной диапазона, а именно `room`. Именно поэтому такие фильтры связаны.

Однако для полнотекстового поиска не существует способа ссылаться на определенную переменную диапазона. Если вы используете поиск с полями для выполнения [полного запроса Lucene](query-lucene-syntax.md) , подобного этому:

    Rooms/Type:deluxe AND Rooms/Description:"city view"

Вы можете получить Гостиницы, где одна комната — Deluxe, а другая комната упоминается в описании. Например, следующий документ с `Id` `1` будет соответствовать запросу:

```json
{
  "value": [
    {
      "Id": "1",
      "Rooms": [
        { "Type": "deluxe", "Description": "Large garden view suite" },
        { "Type": "standard", "Description": "Standard city view room" }
      ]
    },
    {
      "Id": "2",
      "Rooms": [
        { "Type": "deluxe", "Description": "Courtyard motel room" }
      ]
    }
  ]
}
```

Причина в том, что `Rooms/Type` ссылается на все проанализированные условия поля `Rooms/Type` во всем документе, а также на `Rooms/Description`, как показано в таблицах ниже.

Как `Rooms/Type` хранится для полнотекстового поиска:

| Термин в `Rooms/Type` | Идентификаторы документов |
| --- | --- |
| Обучающий | 1, 2 |
| Standard | 1 |

Как `Rooms/Description` хранится для полнотекстового поиска:

| Термин в `Rooms/Description` | Идентификаторы документов |
| --- | --- |
| кауртярд | 2 |
| city | 1 |
| процессор | 1 |
| достаточ | 1 |
| мотель | 2 |
| залах | 1, 2 |
| Standard | 1 |
| Suite | 1 |
| показать | 1 |

Таким образом, в отличие от приведенного выше фильтра, который по сути говорит «сопоставление документов, в которых комната `Type` равна «Deluxe Room» и **что** `BaseRate` менее 100», поисковый запрос говорит «соответствие документов, где `Rooms/Type` имеет термин «Deluxe» и `Rooms/Description` содержит фразу «представление города». Нет концепции отдельных комнат, поля которых можно связать в последнем случае.

> [!NOTE]
> Если вы хотите увидеть поддержку коррелированного поиска, добавленного в Когнитивный поиск Azure, проголосуйте за [этот пользовательский голосовый элемент](https://feedback.azure.com/forums/263029-azure-search/suggestions/37735060-support-correlated-search-on-complex-collections).

## <a name="inverted-indexes-and-collections"></a>Инвертированные индексы и коллекции

Возможно, вы заметили, что существует гораздо меньше ограничений на лямбда-выражения по сравнению со сложными коллекциями, чем для простых коллекций, таких как `Collection(Edm.Int32)`, `Collection(Edm.GeographyPoint)`и т. д. Это связано с тем, что Azure Когнитивный поиск хранит сложные коллекции как реальные коллекции поддокументов, тогда как простые коллекции вообще не хранятся в виде коллекций.

Например, рассмотрим поле коллекции строк, которое можно фильтровать, например `seasons`, в индексе для Интернет-магазина. Некоторые документы, отправленные по этому индексу, могут выглядеть следующим образом:

```json
{
  "value": [
    {
      "id": "1",
      "name": "Hiking boots",
      "seasons": ["spring", "summer", "fall"]
    },
    {
      "id": "2",
      "name": "Rain jacket",
      "seasons": ["spring", "fall", "winter"]
    },
    {
      "id": "3",
      "name": "Parka",
      "seasons": ["winter"]
    }
  ]
}
```

Значения поля `seasons` хранятся в структуре, которая называется **инвертированным индексом**, которая выглядит примерно так:

| Срок действия | Идентификаторы документов |
| --- | --- |
| Весна | 1, 2 |
| Лето | 1 |
| делят | 1, 2 |
| зимне | 2, 3 |

Эта структура данных предназначена для ответа на один вопрос с высокой скоростью: в каком документе отображается указанный термин? Ответ на этот вопрос работает более похоже на проверку обычного равенства, чем на цикл по коллекции. По сути, именно поэтому для коллекций строк Когнитивный поиск Azure допускает только `eq` в качестве оператора сравнения внутри лямбда-выражения для `any`.

Основываясь на равенстве, далее мы рассмотрим, как можно объединить несколько проверок равенства для одной и той же переменной диапазона с `or`. Он работает с благодарностью и [свойством дистрибутиве кванторов](https://en.wikipedia.org/wiki/Existential_quantification#Negation). Следующее выражение:

    seasons/any(s: s eq 'winter' or s eq 'fall')

эквивалентно правилу

    seasons/any(s: s eq 'winter') or seasons/any(s: s eq 'fall')

и каждый из этих двух `any` подвыражений может эффективно выполняться с использованием инвертированного индекса. Кроме того, благодаря [закону отрицания](https://en.wikipedia.org/wiki/Existential_quantification#Negation), приведенному ниже, это выражение:

    seasons/all(s: s ne 'winter' and s ne 'fall')

эквивалентно правилу

    not seasons/any(s: s eq 'winter' or s eq 'fall')

Именно поэтому можно использовать `all` с `ne` и `and`.

> [!NOTE]
> Хотя подробные сведения выходят за рамки этого документа, эти же принципы расширяются на [тесты расстояния и пересечения для коллекций геопространственных точек](search-query-odata-geo-spatial-functions.md) . Именно поэтому в `any`:
>
> - Невозможно инвертировать `geo.intersects`
> - `geo.distance` необходимо сравнивать с помощью `lt` или `le`
> - выражения должны сочетаться с `or`, а не `and`
>
> Правила обратной кинематики применяются к `all`.

При фильтрации по коллекциям типов данных, поддерживающих операторы `lt`, `gt`, `le`и `ge`, например `Collection(Edm.Int32)`, Допускается использование более широкого спектра выражений. В частности, можно использовать `and`, а также `or` в `any`, если базовые выражения сравнения объединяются в **диапазоны сравнения** с помощью `and`, которые затем объединяются с помощью `or`. Эта структура логических выражений называется [Дисжунктиве обычной формой (ДНФ)](https://en.wikipedia.org/wiki/Disjunctive_normal_form), которая в противном случае называется or and. И наоборот, лямбда-выражения для `all` этих типов данных должны быть в [обычной форме был соединительным (cnf)](https://en.wikipedia.org/wiki/Conjunctive_normal_form), в ином случае известной как "and of or". Azure Когнитивный поиск позволяет выполнять такие сравнения диапазонов, так как позволяет эффективно исполнять их с помощью инвертированных индексов, точно так же, как это может сделать быстрый поиск строк.

В сводке ниже приведены правила, которые можно использовать в лямбда-выражении.

- Внутри `any`*положительные проверки* всегда разрешены, например равенство, сравнения диапазонов, `geo.intersects`или `geo.distance` по сравнению с `lt` или `le` (Подумайте о «близкости» как об равенстве, когда дело доходит до проверки расстояния).
- Внутри `any``or` разрешен всегда. `and` можно использовать только для типов данных, которые могут выражать проверку диапазона, и только при использовании or из and (ДНФ).
- В `all`правила являются обратными, то есть разрешены только *отрицательные проверки* , можно использовать `and` всегда, и можно использовать `or` только для проверок диапазона, выраженного как and or (cnf).

На практике это типы фильтров, которые, скорее всего, будут использоваться в любом случае. По-прежнему полезно понимать границы того, что возможно.

Конкретные примеры того, какие виды фильтров разрешены, а какие нет, см. [в разделе как записать допустимые фильтры коллекции](search-query-troubleshoot-collection-filters.md#bkmk_examples).

## <a name="next-steps"></a>Дальнейшие действия  

- [Устранение неполадок фильтров коллекции OData в Azure Когнитивный поиск](search-query-troubleshoot-collection-filters.md)
- [Фильтры в Когнитивный поиск Azure](search-filters.md)
- [Общие сведения о языке выражений OData для Azure Когнитивный поиск](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для Azure Когнитивный поиск](search-query-odata-syntax-reference.md)
- [Поиск документов &#40;Когнитивный поиск Azure REST API&#41;](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
