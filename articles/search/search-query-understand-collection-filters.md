---
title: Основные сведения о фильтрах коллекции OData
titleSuffix: Azure Cognitive Search
description: Узнайте, как работают фильтры коллекции OData в запросах Когнитивный поиск Azure, включая ограничения и поведения, уникальные для коллекций.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: 861e011c4bd368a274998859170e78cf444400a8
ms.sourcegitcommit: 3541c9cae8a12bdf457f1383e3557eb85a9b3187
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2020
ms.locfileid: "86206177"
---
# <a name="understanding-odata-collection-filters-in-azure-cognitive-search"></a>Основные сведения о фильтрах коллекции OData в Azure Когнитивный поиск

Для [фильтрации](query-odata-filter-orderby-syntax.md) по полям коллекции в когнитивный Поиск Azure можно использовать [ `any` `all` операторы и](search-query-odata-collection-operators.md) вместе с **лямбда-выражениями**. Лямбда-выражения — это логические выражения, которые ссылаются на **переменную диапазона**. `any`Операторы и `all` являются аналогом `for` цикла в большинстве языков программирования, с переменной диапазона, принимающей роль переменной цикла, и лямбда-выражением в качестве тела цикла. Переменная диапазона принимает значение Current в коллекции во время итерации цикла.

По крайней мере, это работает по принципу концептуально. В действительности, Azure Когнитивный поиск реализует фильтры по-другому, как `for` работают циклы. В идеале это различие будет невидимым для вас, но в некоторых ситуациях это не так. Конечный результат заключается в том, что при написании лямбда-выражений необходимо следовать правилам.

В этой статье объясняется, почему правила для фильтров коллекции существуют, изучив, как Azure Когнитивный поиск выполняет эти фильтры. Если вы пишете расширенные фильтры с помощью сложных лямбда-выражений, эта статья поможет вам получить представление о возможностях фильтров и о том, почему.

Сведения о правилах фильтров коллекции, включая примеры, см. [в разделе Устранение неполадок фильтров коллекции OData в когнитивный Поиск Azure](search-query-troubleshoot-collection-filters.md).

## <a name="why-collection-filters-are-limited"></a>Почему фильтры коллекции ограничены

Существуют три основные причины, по которым не все функции фильтра поддерживаются для всех типов коллекций:

1. Для определенных типов данных поддерживаются только определенные операторы. Например, не имеет смысла сравнивать логические значения `true` и `false` использовать `lt` , `gt` и т. д.
1. Когнитивный поиск Azure не поддерживает **коррелированный Поиск** по полям типа `Collection(Edm.ComplexType)` .
1. Когнитивный поиск Azure использует Инвертированные индексы для выполнения фильтров по всем типам данных, включая коллекции.

Первая причина — это лишь следствие того, как определяются язык OData и система типов EDM. Последние два более подробно описаны в оставшейся части этой статьи.

## <a name="correlated-versus-uncorrelated-search"></a>Коррелированный и некоррелированный Поиск

При применении нескольких условий фильтра к коллекции сложных объектов эти **критерии сопоставляются, так как** они применяются к *каждому объекту в коллекции*. Например, следующий фильтр возвратит Гостиницы, у которых есть хотя бы одна комната Deluxe с частотой менее 100:

```odata-filter-expr
    Rooms/any(room: room/Type eq 'Deluxe Room' and room/BaseRate lt 100)
```

Если фильтрация была *некоррелированной*, то приведенный выше фильтр может вернуть Гостиницы, где одна комната — Deluxe, а другая комната будет иметь базовый уровень менее 100. Это не имеет смысла, так как оба предложения лямбда-выражения применяются к одной и той же переменной диапазона, а именно `room` . Именно поэтому такие фильтры связаны.

Однако для полнотекстового поиска не существует способа ссылаться на определенную переменную диапазона. Если вы используете поиск с полями для выполнения [полного запроса Lucene](query-lucene-syntax.md) , подобного этому:

```odata-filter-expr
    Rooms/Type:deluxe AND Rooms/Description:"city view"
```

Вы можете получить Гостиницы, где одна комната — Deluxe, а другая комната упоминается в описании. Например, следующий документ `Id` `1` должен соответствовать запросу:

```json
{
  "value": [
    {
      "Id": "1",
      "Rooms": [
        { "Type": "deluxe", "Description": "Large garden view suite" },
        { "Type": "standard", "Description": "Standard city view room" }
      ]
    },
    {
      "Id": "2",
      "Rooms": [
        { "Type": "deluxe", "Description": "Courtyard motel room" }
      ]
    }
  ]
}
```

Причина заключается в том, что `Rooms/Type` относится ко всем проанализированным условиям `Rooms/Type` поля во всем документе, а также к `Rooms/Description` , как показано в таблицах ниже.

Как `Rooms/Type` хранится для полнотекстового поиска:

| Термин в`Rooms/Type` | Идентификаторы документов |
| --- | --- |
| Обучающий | 1, 2 |
| standard | 1 |

Как `Rooms/Description` хранится для полнотекстового поиска:

| Термин в`Rooms/Description` | Идентификаторы документов |
| --- | --- |
| кауртярд | 2 |
| city | 1 |
| процессор | 1 |
| большой. | 1 |
| мотель | 2 |
| комната | 1, 2 |
| standard | 1 |
| Suite | 1 |
| view | 1 |

Таким образом, в отличие от приведенного выше фильтра, в котором по сути говорится о совпадении документов, в которых комната имеет значение `Type` "Deluxe Room", и **что в этой комнате** `BaseRate` меньше 100 ", поисковый запрос говорит «найти документы `Rooms/Type` , где есть термин «Deluxe» и `Rooms/Description` фразу «представление города». Нет концепции отдельных комнат, поля которых можно связать в последнем случае.

> [!NOTE]
> Если вы хотите увидеть поддержку коррелированного поиска, добавленного в Когнитивный поиск Azure, проголосуйте за [этот пользовательский голосовый элемент](https://feedback.azure.com/forums/263029-azure-search/suggestions/37735060-support-correlated-search-on-complex-collections).

## <a name="inverted-indexes-and-collections"></a>Инвертированные индексы и коллекции

Вы могли заметить, что существует гораздо меньше ограничений на лямбда-выражения по сравнению со сложными коллекциями, чем для простых коллекций, таких как `Collection(Edm.Int32)` , `Collection(Edm.GeographyPoint)` и т. д. Это связано с тем, что Azure Когнитивный поиск хранит сложные коллекции как реальные коллекции поддокументов, тогда как простые коллекции вообще не хранятся в виде коллекций.

Например, рассмотрим поле коллекции строк, которое можно фильтровать, например `seasons` в индексе для Интернет-магазина. Некоторые документы, отправленные по этому индексу, могут выглядеть следующим образом:

```json
{
  "value": [
    {
      "id": "1",
      "name": "Hiking boots",
      "seasons": ["spring", "summer", "fall"]
    },
    {
      "id": "2",
      "name": "Rain jacket",
      "seasons": ["spring", "fall", "winter"]
    },
    {
      "id": "3",
      "name": "Parka",
      "seasons": ["winter"]
    }
  ]
}
```

Значения `seasons` поля хранятся в структуре, которая называется **инвертированным индексом**, которая выглядит примерно так:

| Термин | Идентификаторы документов |
| --- | --- |
| spring | 1, 2 |
| Лето | 1 |
| делят | 1, 2 |
| зимне | 2, 3 |

Эта структура данных предназначена для ответа на один вопрос с высокой скоростью: в каком документе отображается указанный термин? Ответ на этот вопрос работает более похоже на проверку обычного равенства, чем на цикл по коллекции. По сути, именно поэтому для коллекций строк Когнитивный поиск Azure допускает только в `eq` качестве оператора сравнения внутри лямбда-выражения для `any` .

Основываясь на равенстве, далее мы рассмотрим, как можно объединить несколько проверок равенства для одной и той же переменной диапазона с `or` . Он работает с благодарностью и [свойством дистрибутиве кванторов](https://en.wikipedia.org/wiki/Existential_quantification#Negation). Следующее выражение:

```odata-filter-expr
    seasons/any(s: s eq 'winter' or s eq 'fall')
```

эквивалентно правилу

```odata-filter-expr
    seasons/any(s: s eq 'winter') or seasons/any(s: s eq 'fall')
```

и каждое из двух `any` подвыражений может эффективно выполняться с использованием инвертированного индекса. Кроме того, благодаря [закону отрицания](https://en.wikipedia.org/wiki/Existential_quantification#Negation), приведенному ниже, это выражение:

```odata-filter-expr
    seasons/all(s: s ne 'winter' and s ne 'fall')
```

эквивалентно правилу

```odata-filter-expr
    not seasons/any(s: s eq 'winter' or s eq 'fall')
```

Именно поэтому можно использовать `all` с `ne` и `and` .

> [!NOTE]
> Хотя подробные сведения выходят за рамки этого документа, эти же принципы расширяются на [тесты расстояния и пересечения для коллекций геопространственных точек](search-query-odata-geo-spatial-functions.md) . Именно поэтому в `any` :
>
> - `geo.intersects`не может быть отрицанием
> - `geo.distance`необходимо сравнить с помощью `lt` или`le`
> - выражения должны быть объединены с `or` , а не`and`
>
> Правила обратной стороны применяются для `all` .

При фильтрации по коллекциям типов данных, которые поддерживают `lt` операторы,, `gt` `le` и `ge` , такие как `Collection(Edm.Int32)` , например, могут использоваться более широкий спектр выражений. В частности, можно использовать `and` и `or` в, пока `any` Базовые выражения сравнения объединяются в **диапазоны сравнения** с помощью `and` , которые затем объединяются с помощью `or` . Эта структура логических выражений называется [Дисжунктиве обычной формой (ДНФ)](https://en.wikipedia.org/wiki/Disjunctive_normal_form), которая в противном случае называется or and. И наоборот, лямбда-выражения для `all` этих типов данных должны быть в [был соединительным обычной форме (cnf)](https://en.wikipedia.org/wiki/Conjunctive_normal_form), в противном случае известной как "and of or". Azure Когнитивный поиск позволяет выполнять такие сравнения диапазонов, так как позволяет эффективно исполнять их с помощью инвертированных индексов, точно так же, как это может сделать быстрый поиск строк.

В сводке ниже приведены правила, которые можно использовать в лямбда-выражении.

- Внутри `any` , *положительные проверки* всегда разрешены, такие как равенство, сравнения диапазонов, `geo.intersects` или `geo.distance` по сравнению с `lt` OR `le` (Представьте «близкость» как равенство, когда дело доходит до проверки расстояния).
- Внутри `any` , `or` всегда разрешено. Можно использовать `and` только для типов данных, которые могут выражать проверки диапазона, и только при использовании or из and (ДНФ).
- Внутри `all` правила являются обратными, то есть разрешены только *отрицательные проверки* , можно использовать `and` Always и можно использовать `or` только для проверок диапазона, выраженного как and or (cnf).

На практике это типы фильтров, которые, скорее всего, будут использоваться в любом случае. По-прежнему полезно понимать границы того, что возможно.

Конкретные примеры того, какие виды фильтров разрешены, а какие нет, см. [в разделе как записать допустимые фильтры коллекции](search-query-troubleshoot-collection-filters.md#bkmk_examples).

## <a name="next-steps"></a>Дальнейшие действия  

- [Устранение неполадок фильтров коллекции OData в Azure Когнитивный поиск](search-query-troubleshoot-collection-filters.md)
- [Фильтры в Когнитивный поиск Azure](search-filters.md)
- [Общие сведения о языке выражений OData для Azure Когнитивный поиск](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для Azure Когнитивный поиск](search-query-odata-syntax-reference.md)
- [Поиск документов &#40;Azure Когнитивный поиск REST API&#41;](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
