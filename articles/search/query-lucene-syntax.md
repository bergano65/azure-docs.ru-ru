---
title: Синтаксис запросов Lucene
titleSuffix: Azure Cognitive Search
description: Справочник по полному синтаксису запросов Lucene, используемому в Azure Когнитивный поиск для подстановочных знаков, нечетких поисков, регулярных выражений и других расширенных конструкций запросов.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 12/14/2020
ms.openlocfilehash: 0dbf418d0a673dd0799f0f638e454c484f837fd7
ms.sourcegitcommit: 66479d7e55449b78ee587df14babb6321f7d1757
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/15/2020
ms.locfileid: "97516595"
---
# <a name="lucene-query-syntax-in-azure-cognitive-search"></a>Синтаксис запроса Lucene в Azure Когнитивный поиск

При создании запросов можно использовать синтаксис [синтаксического анализатора запросов Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) для специализированных форм запросов: шаблон, нечеткий поиск, поиск по сходству, регулярные выражения. Большая часть синтаксиса синтаксического анализатора запросов Lucene [реализована не в Azure когнитивный Поиск](search-lucene-query-architecture.md), за исключением *операций поиска по диапазонам* , созданных с помощью **`$filter`** выражений. 

Полный синтаксис Lucene используется для выражений запроса, передаваемых в **`search`** параметре запроса [поиска документов (REST API)](/rest/api/searchservice/search-documents) , не путать с [синтаксисом OData](query-odata-filter-orderby-syntax.md) , который используется в [**`$filter`**](search-filters.md) [**`$orderby`**](search-query-odata-orderby.md) выражениях и в одном запросе. Параметры OData имеют разный синтаксис и правила для построения запросов, экранирования строк и т. д.

## <a name="example-full-syntax"></a>Пример (полный синтаксис)

Задайте **`queryType`** параметр, чтобы указать полное значение Lucene. В следующем примере вызывается Поиск в поле и повышение термина. Этот запрос ищет Гостиницы, в которых поле "Категория" содержит термин "бюджет". Все документы, содержащие фразу «недавно отремонтированных», имеют более высокий приоритет, чем результат «повышение» (3).  

```http
POST /indexes/hotels-sample-index/docs/search?api-version=2020-06-30
{
  "queryType": "full",
  "search": "category:budget AND \"recently renovated\"^3",
  "searchMode": "all"
}
```

**`searchMode`** Параметр важен в этом примере. Когда операторы находятся в запросе, обычно следует установить параметр `searchMode=all`, чтобы убедиться, что *все* критерии будут удовлетворены.  

Дополнительные примеры см. в разделе [Примеры синтаксиса запросов Lucene](search-query-lucene-examples.md). Дополнительные сведения о запросе и параметрах запроса см. в разделе [Поиск документов (REST API)](/rest/api/searchservice/Search-Documents).

## <a name="syntax-fundamentals"></a><a name="bkmk_syntax"></a> Основные сведения о синтаксисе  

Следующие основные сведения о синтаксисе применяются ко всем запросам, которые используют синтаксис Lucene.  

### <a name="operator-evaluation-in-context"></a>Оценивание операторов в контексте

Размещение определяет, как будет интерпретироваться символ: как оператор или просто как другой знак в строке.

Например, в полном синтаксисе Lucene тильда (~) используется для поиска нечетких соответствий и для поиска с учетом расположения. Если ~ ставится после фразы в кавычках, вызывается поиск с учетом расположения. Если ~ ставится в конце термина, вызывается поиск нечетких соответствий.

Внутри термина, такого как "business~analyst", знак не оценивается как оператор. В этом случае, предположив, что это запрос термина или фразы, [полнотекстовый поиск](search-lucene-query-architecture.md) с [лексическим анализом](search-lucene-query-architecture.md#stage-2-lexical-analysis) удаляет ~ и разбивает термин "business~analyst" на две части: business OR analyst.

В приведенном выше примере используется тильда (~), но тот же принцип применяется к каждому оператору.

### <a name="escaping-special-characters"></a>Экранирование специальных знаков

Чтобы использовать любой оператор поиска как часть искомого текста, необходимо зафиксировать символ, добавив в него одну обратную косую черту ( `\` ). Например, для поиска с подстановочными знаками в `https://` , где `://` является частью строки запроса, необходимо указать `search=https\:\/\/*` . Аналогично, шаблон номер телефона с экранированием может выглядеть следующим образом `\+1 \(800\) 642\-7676` .

Специальные символы, требующие экранирования, включают следующее:  
`+ - & | ! ( ) { } [ ] ^ " ~ * ? : \ /`  

> [!NOTE]  
> Хотя экранирование сохраняет маркеры совместно, [лексический анализ](search-lucene-query-architecture.md#stage-2-lexical-analysis) во время индексирования может привести к их порождению. Например, стандартный анализатор Lucene будет разбивать слова на дефисы, пробелы и другие символы. Если в строке запроса требуются специальные символы, может потребоваться анализатор, сохраняющий их в индексе. К некоторым вариантам относятся [анализаторы](index-add-language-analyzers.md)естественного языка (Майкрософт), которые сохраняют перенос слов или пользовательский анализатор для более сложных шаблонов. Дополнительные сведения см. в разделе [частичные термины, шаблоны и специальные символы](search-query-partial-matching.md).

### <a name="encoding-unsafe-and-reserved-characters-in-urls"></a>Кодирование небезопасных и зарезервированных знаков в URL-адресах

Убедитесь, что в URL-адресе закодированы все небезопасные и зарезервированные знаки. Например, "#" является ненадежным символом, так как он является идентификатором фрагмента или привязки в URL-адресе. Знак должен быть закодирован как `%23`, если он используется в URL-адресе. "&" и "=" являются примерами зарезервированных символов, так как они разделяют параметры и указывают значения в Когнитивный поиск Azure. Дополнительные сведения см. в разделе [RFC1738: универсальные указатели ресурсов (URL-адрес)](https://www.ietf.org/rfc/rfc1738.txt) .

Небезопасными знаками являются: ``" ` < > # % { } | \ ^ ~ [ ]``. Зарезервированными знаками являются: `; / ? : @ = + &`.

## <a name="boolean-operators"></a><a name="bkmk_boolean"></a> Логические операторы

Чтобы повысить точность совпадения, можно внедрить логические операторы в строку запроса. Полный синтаксис поддерживает текстовые операторы в дополнение к символьным операторам. Всегда указывайте текстовые логические операторы (AND, OR, NOT) прописными буквами.

|Оператор для работы с текстом | Символ | Пример | Использование |
|--------------|----------- |--------|-------|
| AND | `&`, `+` | `wifi + luxury` | Указывает термины, которые должны содержаться в совпадении. В этом примере обработчик запросов будет искать документы `wifi` , содержащие и `luxury` . `+`Для обязательных условий используется знак плюс (). Например, `+wifi +luxury` указывает, что оба термина должны появляться где-то в поле одного документа.|
| OR | `|` | `wifi | luxury` | Поиск совпадения при обнаружении одного из терминов. В этом примере обработчик запросов вернет совпадение для документов, содержащих либо или, либо и то, и `wifi` `luxury` другое. Так как OR является оператором соединения по умолчанию, вы также можете его оставить, то есть `wifi luxury` аналогично `wifi | luxury`.|
| NOT | `!`, `-` | `wifi –luxury` | Возвращает совпадения для документов, исключая термин. Например, `wifi –luxury` будет искать документы, которые содержат термин, `wifi` но не `luxury` . <br/><br/>`searchMode`Параметр в запросе запроса определяет, является ли термин с оператором NOT and или ORed с другими условиями в запросе (при условии, что `+` оператор OR отсутствует `|` в других терминах). Допустимые значения: `any` и `all`.  <br/><br/>`searchMode=any` повышает отзыв запросов, включая дополнительные результаты, и по умолчанию `-` интерпретируется как «или not». Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi`, или документам, которые не содержат термин `luxury`.  <br/><br/>`searchMode=all` увеличивает точность запросов, включая меньше результатов, и по умолчанию интерпретируется как «AND NOT». Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi` и не содержат термин "luxury". Вероятно, это более интуитивное поведение оператора `-`. Поэтому рекомендуется использовать `searchMode=all` вместо `searchMode=any` , если требуется оптимизировать поиск точности вместо отзыва, *а* пользователи часто используют `-` оператор в поиске.<br/><br/>При принятии решения о `searchMode` параметре следует учитывать закономерности взаимодействия с пользователем для запросов в различных приложениях. Пользователи, которые ищут информацию, скорее всего, включают оператор в запрос, а не сайты электронной коммерции с более встроенными структурами навигации. |

##  <a name="fielded-search"></a><a name="bkmk_fields"></a> Поиск по полям

Можно определить операцию поиска по полю с `fieldName:searchExpression` синтаксисом, где выражение поиска может представлять собой одно слово или фразу или более сложное выражение в круглых скобках, при необходимости с логическими операторами. Вот несколько примеров.  

- genre:jazz NOT history  

- artists:("Miles Davis" "John Coltrane")

Добавьте несколько строк в кавычках, если необходимо, чтобы обе строки считались одной сущностью, в приведенном случае поиска двух разных исполнителей в поле `artists`.  

Поле, указанное в `fieldName:searchExpression`, должно быть полем `searchable`.  Дополнительные сведения об использовании атрибутов индекса в определениях полей см. в статье [Create Index (Azure Search Service REST API)](/rest/api/searchservice/create-index) (Создание индексов (REST API службы "Поиск Azure")).  

> [!NOTE]
> При использовании выражений с полями для поиска не нужно использовать этот `searchFields` параметр, так как каждое поле поискового выражения имеет явно заданное имя поля. Тем не менее можно по-прежнему использовать `searchFields` параметр, если требуется выполнить запрос, в котором часть частей ограничена определенным полем, а остальное может быть применено к нескольким полям. Например, запрос `search=genre:jazz NOT history&searchFields=description` будет сопоставляться `jazz` только с `genre` полем, тогда как он будет соответствовать `NOT history` `description` полю. Имя поля, указанное в `fieldName:searchExpression` , всегда имеет приоритет над `searchFields` параметром, поэтому в этом примере не нужно включать `genre` в `searchFields` параметр.

##  <a name="fuzzy-search"></a><a name="bkmk_fuzzy"></a> Нечеткий поиск

Нечеткий поиск находит совпадения в терминах, имеющих похожую конструкцию, расширяя термин до максимума 50 терминов, отвечающих критериям расстояния двух или менее. Дополнительные сведения см. в разделе [нечеткий поиск](search-query-fuzzy.md).

Чтобы выполнить поиск нечетких соответствий, необходимо поставить символ тильды "~" в конце слова. Дополнительно можно поставить цифру от 0 до 2 (по умолчанию), указывающую расстояние редактирования. Например, "blue~" или "blue~1" вернет результаты с "blue", "blues" и "glue".

Нечеткий поиск можно применить только к терминам, а не к фразам, но можно добавить символ тильды к каждому термину по отдельности в составе имени или фразы. Например, "Унвиерсти ~ of ~" Вшингтон ~ "соответствует" университету Вашингтон ".
 
##  <a name="proximity-search"></a><a name="bkmk_proximity"></a> Поиск с учетом расположения

Операция поиска с учетом расположения позволяет найти слова, расположенные рядом в документе. Вставьте символ тильды "~" в конце фразы, а затем — цифру, обозначающую количество слов, определяющее границу близости. Например, если ввести `"hotel airport"~5`, будут найдены слова "hotel" и "airport", расположенные в пределах 5 слов друг от друга в документе.  

##  <a name="term-boosting"></a><a name="bkmk_termboost"></a> Повышение термина

При повышении приоритета слов документы сортируются по приоритету, т. е. документы, в которых содержится условие поиска, имеют высший приоритет по отношению к документам, в которых его нет. Этот тип запроса отличается от профилей повышения, так как они повышают приоритет определенных полей, а не определенных слов.  

В следующем примере показаны эти различия. Предположим, что есть профиль повышения, который повышает приоритет совпадений в определенном поле, например, *genre* в [примере musicstoreindex](index-add-scoring-profiles.md#bkmk_ex). Повышение значимости слов может использоваться для дальнейшего повышения приоритета определенных условий поиска относительно других. Например, при вводе запроса `rock^2 electronic` документы, содержащие это условие поиска в поле genre, становятся приоритетнее документов, содержащих это условие поиска в других полях, поддерживающих поиск, в индексе. Кроме того, документы, содержащие слово *rock*, будут иметь более высокий приоритет, чем документы, содержащие слово *electronic*, так как введен коэффициент повышения приоритета (2).  

 Чтобы повысить приоритет условия поиска, используйте символ крышки "^" и коэффициент повышения приоритета (число) в конце этого условия. Вы также можете повысить приоритет фразы. Чем выше коэффициент повышения приоритета, тем приоритетнее условие поиска относительно других. Коэффициент повышения приоритета по умолчанию — 1. Несмотря на то что коэффициент повышения приоритета должен быть положительным числом, он может быть меньше 1 (например, 0,20).  

##  <a name="regular-expression-search"></a><a name="bkmk_regex"></a> Поиск с использованием регулярных выражений  
 Поиск по регулярному выражению находит совпадение на основе шаблонов, допустимых в Apache Lucene, как описано в [классе RegExp](https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/util/automaton/RegExp.html). В Когнитивный поиск Azure регулярное выражение заключено между косыми чертами `/` .

 Например, чтобы найти документы, содержащие "motel" или "hotel", укажите `/[mh]otel/`. Поиск с регулярными выражениями сопоставляется с отдельными словами.

Некоторые средства и языки залагают дополнительные требования к escape-символам. Для JSON строки, включающие косую черту, переводятся обратной косой чертой: "microsoft.com/azure/" становится `search=/.*microsoft.com\/azure\/.*/` местом `search=/.* <string-placeholder>.*/` , где настраивается регулярное выражение, а `microsoft.com\/azure\/` — строка с экранированной косой чертой.

##  <a name="wildcard-search"></a><a name="bkmk_wildcard"></a> Поиск с подстановочными знаками

В целом можно использовать распознаваемый синтаксис для `*` поиска с подстановочными знаками в нескольких () или одиночных ( `?` ) символах. Например, выражение запроса `search=alpha*` возвращает «буквенно-цифровые» или «алфавит». Обратите внимание, что средство синтаксического анализа запросов Lucene поддерживает использование этих символов для поиска одного слова, а не фразы.

Полный синтаксис Lucene поддерживает сопоставление префиксов, инфиксные и суффиксов. Однако если требуется только совпадение префиксов, можно использовать простой синтаксис (сопоставление префиксов поддерживается в обоих случаях).

Для поиска суффикса, где `*` или `?` перед строкой (AS в `search=/.*numeric./` ) или инфиксные Match, требуется полный синтаксис Lucene, а также регулярные символы косой черты в регулярном выражении `/` . Символ "*" или "?" символ в качестве первого символа термина или в термине без `/` . 

> [!NOTE]  
> Как правило, сопоставление шаблонов выполняется очень долго, поэтому может потребоваться изучить альтернативные методы, такие как разметка маркера n-грамм, создающая маркеры для последовательностей символов в термине. Индекс будет больше, но запросы могут выполняться быстрее, в зависимости от конструкции шаблона и длины индексируемых строк.
>

### <a name="impact-of-an-analyzer-on-wildcard-queries"></a>Влияние анализатора на запросы с подстановочными знаками

Во время синтаксического анализа запроса запросы, которые обрабатываются как префикс, суффикс, подстановочный знак или регулярные выражения, передаются как есть в дерево запроса, минуя [лексed Analysis](search-lucene-query-architecture.md#stage-2-lexical-analysis). Совпадения будут найдены, только если индекс содержит строки в формате, указанном в запросе. В большинстве случаев во время индексирования потребуется анализатор, который сохраняет целостность строк, чтобы частичное совпадение Терма и шаблона было продолжено. Дополнительные сведения см. [в статье Поиск неполных терминов в Azure когнитивный Поиск запросы](search-query-partial-matching.md).

Рассмотрим ситуацию, когда в поисковом запросе "Terminate *" должны быть возвращены результаты, содержащие такие термины, как "уволить", "termination" и "Terminate".

Если бы вы использовали анализатор EN. Lucene (Английский Lucene), он применяет агрессивное извлечение из каждого термина. Например, "Terminate", "termination", "Terminate" будут относиться к токену "Терми" в индексе. С другой стороны, термины в запросах с подстановочными знаками или нечеткий поиск не анализируются. Поэтому результаты не будут соответствовать запросу "завершение *".

С другой стороны, анализаторы Microsoft Analyzer (в нашем примере это EN. Microsoft Analyzer) немного более продвинуты и используют лемматизация вместо извлечения корней. Это означает, что все созданные маркеры должны быть действительными словами на английском языке. Например, "Terminate", "Terminate" и "termination" в основном остаются целыми в индексе. это будет предпочтительным вариантом для сценариев, которые зависят от подстановочных знаков и нечетких результатов поиска.

## <a name="scoring-wildcard-and-regex-queries"></a> Оценка запросов с подстановочными знаками и с регулярными выражениями

Azure Когнитивный поиск использует оценку на основе частоты ([TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)) для текстовых запросов. Однако для запросов с подстановочными знаками и регулярными выражениями, где область терминов может быть широкой, фактор частоты игнорируется, чтобы предотвратить смещение ранжирования в сторону совпадений с более редкими терминами. Все совпадения обрабатываются одинаково для поиска с подстановочными знаками и с регулярными выражениями.

## <a name="special-characters"></a>Специальные символы

В некоторых случаях может потребоваться найти специальный символ, например "❤" эмодзи или символ "€". В таких случаях убедитесь, что используемый анализатор не фильтрует эти символы. Стандартный анализатор обходит многие специальные символы, исключая их из индекса.

Анализаторы, которые подделят специальные символы, включают анализатор пробелов, который учитывает все последовательности символов, разделенные пробелами, как токены (поэтому строка "❤" будет считаться маркером). Кроме того, анализатор языка, такой как Microsoft English Analyzer ("en. Microsoft"), принимает строку "€" в качестве маркера. Анализатор можно [проверить](/rest/api/searchservice/test-analyzer) , чтобы узнать, какие маркеры он создает для данного запроса.

При использовании символов Юникода убедитесь, что символы правильно экранированы в URL-адресе запроса (например, для "❤" будет использовать управляющую последовательность `%E2%9D%A4+` ). После этого трансляция выполняется автоматически.  

## <a name="precedence-grouping"></a>Приоритет (группирование)

Вы можете использовать круглые скобки, чтобы создать вложенные запросы, включая операторы в заключенной в скобки инструкции. Например, `motel+(wifi|luxury)` будет выполнять поиск документов, содержащих термин "motel" и "wifi" или "luxury" (или оба).

Группирование полей аналогично, но группирование ограничивается одним полем. Например, `hotelAmenities:(gym+(wifi|pool))` ищет в поле "hotelAmenities" термины "gym" и "wifi" или "gym" и "pool".  

## <a name="query-size-limits"></a>Ограничения размера запроса

Существует ограничение на размер запросов, которые можно отправить в Azure Когнитивный поиск. В частности, вы можете иметь не более 1024 предложений (выражения, разделенные AND, OR и т. д.). Кроме того, размер любого отдельного термина в запросе не может превышать 32 КБ. Если приложение создает поисковые запросы программным способом, рекомендуется разрабатывать его таким образом, чтобы оно не создавало запросы неограниченного размера.  

## <a name="see-also"></a>См. также раздел

+ [Примеры запросов для простого поиска](search-query-simple-examples.md)
+ [Примеры запросов для полного поиска в Lucene](search-query-lucene-examples.md)
+ [Поиск документов](/rest/api/searchservice/Search-Documents)
+ [Синтаксис выражений OData для предложений фильтрации и упорядочивания в службе "Поиск Azure"](query-odata-filter-orderby-syntax.md)   
+ [Простой синтаксис запросов в Azure Когнитивный поиск](query-simple-syntax.md)
