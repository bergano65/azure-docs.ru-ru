---
title: Руководство. Создание пользовательского анализатора
titleSuffix: Azure Cognitive Search
description: Узнайте, как создать пользовательский анализатор для улучшения качества результатов в Когнитивном поиске Azure.
manager: liamca
author: dereklegenzoff
ms.author: delegenz
ms.service: cognitive-search
ms.topic: tutorial
ms.date: 06/22/2020
ms.openlocfilehash: a9c2a5beae8a9206554dd6c432c1d8442b652696
ms.sourcegitcommit: 3d79f737ff34708b48dd2ae45100e2516af9ed78
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2020
ms.locfileid: "87021891"
---
# <a name="tutorial-create-a-custom-analyzer-for-phone-numbers"></a>Руководство по Создание пользовательского анализатора телефонных номеров

[Анализаторы](search-analyzers.md) являются важными компонентами поисковых решений. Чтобы улучшить качество результатов поиска, важно понимать, как анализаторы работают и влияют на результаты.

В некоторых случаях, например при использовании текстового поля для ввода, улучшить результаты поиска можно с помощью правильно подобранного [языкового анализатора](index-add-language-analyzers.md). Но в некоторых сценариях, например при точном поиске телефонных номеров, URL-адресов или сообщений электронной почты, применение пользовательских анализаторов будет более оптимальным.

В этом руководстве используются [REST API](https://docs.microsoft.com/rest/api/searchservice/) Postman и Когнитивного поиска Azure, чтобы вы могли:

> [!div class="checklist"]
> * узнать о принципах работы анализаторов;
> * определить пользовательский анализатор для поиска телефонных номеров;
> * протестировать, как пользовательский анализатор создает маркеры на основе текста;
> * создать отдельные анализаторы для индексации и поиска для дальнейшего улучшения результатов.

## <a name="prerequisites"></a>Предварительные требования

Для выполнения инструкций из этого руководства потребуются перечисленные ниже службы и инструменты.

+ [Классическое приложение Postman](https://www.getpostman.com/)
+ [Создайте службу поиска](search-create-service-portal.md) или [найдите существующую службу](https://ms.portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices)

## <a name="download-files"></a>Загрузка файлов

Исходный код примера для этого руководства расположен в папке [custom-analyzers](https://github.com/Azure-Samples/azure-search-postman-samples/tree/master/custom-analyzers) репозитория [Azure-Samples/azure-search-postman-samples](https://github.com/Azure-Samples/azure-search-postman-samples) на сайте GitHub.

## <a name="1---create-azure-cognitive-search-service"></a>1\. Создание экземпляра службы "Когнитивный поиск Azure"

Чтобы выполнить инструкции из этого руководства, вам потребуется служба "Когнитивный поиск Azure", экземпляр которой вы можете [создать на портале Azure](search-create-service-portal.md). Для выполнения действий в этом пошаговом руководстве можно использовать уровень "Бесплатный".

Для выполнения следующего шага вам потребуется имя службы поиска и ее ключ API. Если вы не знаете, как их найти, см. это [краткое руководство](search-create-service-portal.md#get-a-key-and-url-endpoint).


## <a name="2---set-up-postman"></a>2\. Настройка Postman

Затем запустите Postman и импортируйте коллекцию, скачанную из репозитория [Azure-Samples/azure-search-postman-samples](https://github.com/Azure-Samples/azure-search-postman-samples).

Чтобы импортировать коллекцию, щелкните **Файлы** > **Импорт** и выберите файл коллекции для импорта.

Для каждого запроса выполните следующие действия:

1. Замените `<YOUR-SEARCH-SERVICE>` именем службы поиска.

1. Замените `<YOUR-ADMIN-API-KEY>` первичным или вторичным ключом службы поиска.

  ![URL-адрес и заголовок запроса Postman](media/search-get-started-postman/postman-url.png "URL-адрес и заголовок запроса Postman")

Если вы не работали с Postman, см. статью [Краткое руководство. Создание индекса службы "Когнитивный поиск Azure" в Postman с помощью REST API](search-get-started-postman.md).

## <a name="3---create-an-initial-index"></a>3\. Создание начального индекса

На этом шаге мы создадим начальный индекс, загрузим в него документы, а затем выполним запросы к документам, чтобы оценить результативность начального поиска.

### <a name="create-index"></a>Создание индекса

Начнем с создания простого индекса с именем `tutorial-basic-index` и двумя полями `id` и `phone_number`. Мы еще не определили анализатор, поэтому анализатор `standard.lucene` будет использоваться по умолчанию.

Чтобы создать индекс, мы отправим следующий запрос:

```http
PUT https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-basic-index?api-version=2019-05-06
  Content-Type: application/json
  api-key: <YOUR-ADMIN-API-KEY>

  {
    "fields": [
      {
        "name": "id",
        "type": "Edm.String",
        "key": true,
        "searchable": true,
        "filterable": false,
        "facetable": false,
        "sortable": true
      },
      {
        "name": "phone_number",
        "type": "Edm.String",
        "sortable": false,
        "searchable": true,
        "filterable": false,
        "facetable": false
      }
    ]
  }
```

### <a name="load-data"></a>Загрузка данных

Далее мы загрузим данные в индекс. В некоторых случаях вы не сможете задавать формат принимаемых телефонных номеров, поэтому мы выполним тестирование для разных форматов. В идеале поисковое решение должно возвращать все соответствующие номера телефонов независимо от их формата.

Данные загружаются в индекс с помощью следующего запроса: 

```http
POST https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-basic-index/docs/index?api-version=2019-05-06
  Content-Type: application/json
  api-key: <YOUR-ADMIN-API-KEY>

  {
    "value": [
      {
        "@search.action": "upload",  
        "id": "1",
        "phone_number": "425-555-0100"
      },
      {
        "@search.action": "upload",  
        "id": "2",
        "phone_number": "(321) 555-0199"
      },
      {  
        "@search.action": "upload",  
        "id": "3",
        "phone_number": "+1 425-555-0100"
      },
      {  
        "@search.action": "upload",  
        "id": "4",  
        "phone_number": "+1 (321) 555-0199"
      },
      {
        "@search.action": "upload",  
        "id": "5",
        "phone_number": "4255550100"
      },
      {
        "@search.action": "upload",  
        "id": "6",
        "phone_number": "13215550199"
      },
      {
        "@search.action": "upload",  
        "id": "7",
        "phone_number": "425 555 0100"
      },
      {
        "@search.action": "upload",  
        "id": "8",
        "phone_number": "321.555.0199"
      }
    ]  
  }
```

Теперь, когда данные загружены в индекс, можно запустить поиск.

### <a name="search"></a>Поиск

Чтобы поиск был более интуитивно понятным, не предлагайте пользователям задавать определенный формат запросов. Пользователь может выполнить поиск номера `(425) 555-0100` в любом приведенном выше формате для получения результатов. На этом шаге мы протестируем несколько примеров запросов, чтобы оценить их результативность.

Сначала мы выполним поиск телефонного номера `(425) 555-0100`:

```http
GET https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-basic-index/docs?api-version=2019-05-06&search=(425) 555-0100
  Content-Type: application/json
  api-key: <YOUR-ADMIN-API-KEY>  
```

Этот запрос возвращает **три из четырех ожидаемых результатов**, но также выдает **два неожиданных результата**:

```json
{
    "value": [
        {
            "@search.score": 0.05634898,
            "phone_number": "+1 425-555-0100"
        },
        {
            "@search.score": 0.05634898,
            "phone_number": "425 555 0100"
        },
        {
            "@search.score": 0.05634898,
            "phone_number": "425-555-0100"
        },
        {
            "@search.score": 0.020766128,
            "phone_number": "(321) 555-0199"
        },
        {
            "@search.score": 0.020766128,
            "phone_number": "+1 (321) 555-0199"
        }
    ]
}
```

Затем выполним поиск номера `4255550100` без форматирования:

```http
GET https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-basic-index/docs?api-version=2019-05-06&search=4255550100
  api-key: <YOUR-ADMIN-API-KEY>
```

Результативность этого запроса еще хуже — он возвращает **только одно из четырех правильных совпадений**.

```json
{
    "value": [
        {
            "@search.score": 0.6015292,
            "phone_number": "4255550100"
        }
    ]
}
```

Если это кажется вам нелогичным, вы не одиноки. В следующем разделе мы расскажем, чем обусловлены такие результаты.

## <a name="4---debug-search-results"></a>4\. Отладка результатов поиска

Чтобы понять, чем вызваны такие результаты, важно знать, как работают анализаторы. Мы можем протестировать анализатор по умолчанию с использованием [API анализа текста](https://docs.microsoft.com/rest/api/searchservice/test-analyzer), а затем создать анализатор, соответствующий нашим потребностям.

### <a name="how-analyzers-work"></a>Принципы работы анализаторов

[Анализатор](search-analyzers.md) — это компонент [полнотекстовой поисковой системы](search-lucene-query-architecture.md), отвечающий за обработку текста в строках запросов и индексированных документах. Различные анализаторы по-разному обрабатывают текст в зависимости от сценария. В этом сценарии нам нужно создать анализатор, настроенный для работы с телефонными номерами.

Анализаторы включают три компонента:

+ [**Фильтры символов**](#CharFilters), которые удаляют или замещают отдельные символы во входных текстовых данных.
+ [**Создатель маркеров**](#Tokenizers), который разбивает входной текст на маркеры, используемые в качестве ключей в индексе поиска.
+ [**Фильтры маркеров**](#TokenFilters), которые обрабатывают маркеры, созданные создателем маркеров.

На схеме ниже можно видеть, как эти три компонента создают обрабатывают последовательность:

  ![Схема процесса анализатора](media/tutorial-create-custom-analyzer/analyzers-explained.png)

Затем эти маркеры сохраняются в инвертированном индексе, который позволяет выполнять быстрый полнотекстовый поиск.  Инвертированный индекс обеспечивает поддержку полнотекстового поиска благодаря сопоставлению всех уникальных терминов, извлеченных во время лексического анализа, с документами, в которых они встречаются. Пример можно видеть на схеме ниже:

  ![Пример инвертированного индекса](media/tutorial-create-custom-analyzer/inverted-index-explained.png)

Все операции поиска сводятся к поиску терминов в инвертированном индексе. Когда пользователь отправляет запрос:

1. Запрос обрабатывается с анализом терминов запроса.
1. В инвертированном индексе выполняется поиск документов с совпадающими терминами.
1. Наконец, полученные документы ранжируются с применением [алгоритма сходства](index-ranking-similarity.md).

  ![Схема процесса анализатора](media/tutorial-create-custom-analyzer/query-architecture-explained.png)

Если термины запроса не соответствуют терминам в инвертированном индексе, запрос не возвращает результаты. Чтобы узнать больше о принципах работы запросов, см. статью о [полнотекстовом поиске](search-lucene-query-architecture.md).

> [!Note]
> [Запросы с частичными терминами](search-query-partial-matching.md) являются важным исключением из этого правила. Такие запросы (запрос с префиксом, запрос с подстановочными знаками, запрос с регулярными выражениями) обрабатываются в ходе лексического анализа не так, как обычные запросы терминов. Частичные термины переводятся в нижний регистр только при сопоставлении с терминами в индексе. Если в анализаторе не включена поддержка таких типов запросов, вы будете часто получать непредвиденные результаты, так как совпадений терминов в индексе не будет.

### <a name="test-analyzer-using-the-analyze-text-api"></a>Тестирование анализатора с помощью API анализа текста

Когнитивный поиск Azure включает [API анализа текста](https://docs.microsoft.com/rest/api/searchservice/test-analyzer), который позволяет тестировать анализаторы и изучать то, как они обрабатывают текст.

API анализа текста вызывается с помощью следующего запроса:

```http
POST https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-basic-index/analyze?api-version=2019-05-06
  Content-Type: application/json
  api-key: <YOUR-ADMIN-API-KEY>

  {
      "text": "(425) 555-0100",
      "analyzer": "standard.lucene"
  }
```

API затем возвращает список маркеров, извлеченных из текста. Можно видеть, что стандартный анализатор Lucene разделяет телефонный номер на три отдельных маркера:

```json
{
    "tokens": [
        {
            "token": "425",
            "startOffset": 1,
            "endOffset": 4,
            "position": 0
        },
        {
            "token": "555",
            "startOffset": 6,
            "endOffset": 9,
            "position": 1
        },
        {
            "token": "0100",
            "startOffset": 10,
            "endOffset": 14,
            "position": 2
        }
    ]
}
```

И наоборот, телефонный номер `4255550100` без каких-либо знаков пунктуации обрабатывается как один маркер.

```json
{
  "text": "4255550100",
  "analyzer": "standard.lucene"
}
```

```json
{
    "tokens": [
        {
            "token": "4255550100",
            "startOffset": 0,
            "endOffset": 10,
            "position": 0
        }
    ]
}
```

Помните, что анализируются как термины запроса, так и индексированные документы. Теперь можно понять, почему на предыдущем шаге мы получали именно такие результаты поиска.

По первому запросу мы получили неправильные номера телефонов, так как один из терминов, `555`, был сопоставлен с термином, по которому мы выполнили поиск. При выполнении второго запроса был получен только один номер, так как это была единственная запись, термин в которой совпал с `4255550100`.

## <a name="5---build-a-custom-analyzer"></a>5\. Создание пользовательского анализатора

Теперь, когда нам стало понятно, почему мы получаем такие результаты, мы создадим пользовательский анализатор для улучшения логики разметки.

Его предназначение — сделать поиск телефонных номеров более интуитивно понятным независимо от формата запросов или индексированных строк. Для этого мы зададим [фильтр символов](#CharFilters), [создатель маркеров](#Tokenizers) и [фильтр маркеров](#TokenFilters).

<a name="CharFilters"></a>

### <a name="character-filters"></a>Фильтры символов

Фильтры символов используются для обработки текста перед его отправкой в создатель маркеров. Они часто используются для фильтрации элементов HTML или замены специальных символов.

Для обработки телефонных номеров мы настроим удаление пробелов и специальных символов, так как не все форматы телефонных номеров содержат одинаковые специальные символы и пробелы.

```json
"charFilters": [
    {
      "@odata.type": "#Microsoft.Azure.Search.MappingCharFilter",
      "name": "phone_char_mapping",
      "mappings": [
        "-=>",
        "(=>",
        ")=>",
        "+=>",
        ".=>",
        "\\u0020=>"
      ]
    }
  ]
```

Приведенный выше фильтр удаляет `-` `(` `)` `+` `.` и пробелы из входных данных.

|Входные данные|Выходные данные|  
|-|-|  
|`(321) 555-0199`|`3215550199`|  
|`321.555.0199`|`3215550199`|

<a name="Tokenizers"></a>

### <a name="tokenizers"></a>Токенизаторы

Создатели маркеров разбивают текст на маркеры и удаляют некоторые символы, например знаки пунктуации. Во многих случаях цель разбивки заключается в разделении предложения на отдельные слова.

В таком сценарии мы используем создатель маркеров для получения ключевых слов, `keyword_v2`, так как телефонный номер должен обрабатываться как один термин. Учтите, что это не единственный способ решения такой проблемы. См. раздел [Альтернативные подходы](#Alternate) ниже.

Создатели маркеров для получения ключевых слов всегда выводят вводный текст в виде одного термина.

|Входные данные|Выходные данные|  
|-|-|  
|`The dog swims.`|`[The dog swims.]`|  
|`3215550199`|`[3215550199]`|

<a name="TokenFilters"></a>

### <a name="token-filters"></a>Фильтры токенов

Фильтры маркеров фильтруют или изменяют маркеры, созданные создателем маркеров. Некоторые из распространенных способов использования таких фильтров заключаются в переводе всех символов в нижний регистр с помощью специального фильтра или в фильтрации стоп-слов, например `the`, `and` или `is`.

Хотя в этом сценарии мы не будем использовать такие фильтры, мы применим фильтр маркеров nGram для частичного поиска телефонных номеров.

```json
"tokenFilters": [
  {
    "@odata.type": "#Microsoft.Azure.Search.NGramTokenFilterV2",
    "name": "custom_ngram_filter",
    "minGram": 3,
    "maxGram": 20
  }
]
```

#### <a name="ngramtokenfilterv2"></a>NGramTokenFilterV2

[Фильтр маркеров nGram_v2](https://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html) разделяет маркеры на N-граммы заданного размера с учетом параметров `minGram` и `maxGram`.

При использовании анализатора телефонных номеров мы зададим для параметра `minGram` значение `3`, так как это самая короткая подстрока, которую могут ввести пользователи для поиска. Для параметра `maxGram` задано значение `20`, чтобы любой телефонный номер (даже с расширениями) можно было поместить в одну N-грамму.

 Но побочным эффектом использования таких N-грамм будет получение некоторых ложноположительных результатов. Мы устраним эту проблему на шаге 7, создав отдельный анализатор для запросов поиска без фильтра маркеров с N-граммами.

|Входные данные|Выходные данные|  
|-|-|  
|`[12345]`|`[123, 1234, 12345, 234, 2345, 345]`|  
|`[3215550199]`|`[321, 3215, 32155, 321555, 3215550, 32155501, 321555019, 3215550199, 215, 2155, 21555, 215550, ... ]`|

### <a name="analyzer"></a>Анализатор

При наличии фильтров символов, создателя маркеров и фильтров маркеров мы готовы определить анализатор.

```json
"analyzers": [
  {
    "@odata.type": "#Microsoft.Azure.Search.CustomAnalyzer",
    "name": "phone_analyzer",
    "tokenizer": "custom_tokenizer_phone",
    "tokenFilters": [
      "custom_ngram_filter"
    ],
    "charFilters": [
      "phone_char_mapping"
    ]
  }
]
```

|Входные данные|Выходные данные|  
|-|-|  
|`12345`|`[123, 1234, 12345, 234, 2345, 345]`|  
|`(321) 555-0199`|`[321, 3215, 32155, 321555, 3215550, 32155501, 321555019, 3215550199, 215, 2155, 21555, 215550, ... ]`|

Обратите внимание, что поиск теперь можно выполнить по любым маркерам в выходных данных. Если запрос включает какой-либо из маркеров, при поиске будет получен номер телефона.

Определив пользовательский анализатор, мы повторно создадим индекс, чтобы пользовательский анализатор был доступен для тестирования на следующем шаге. Для простоты коллекция Postman создает новый индекс с именем `tutorial-first-analyzer` с определенным нами анализатором.

## <a name="6---test-the-custom-analyzer"></a>6\. Тестирование пользовательского анализатора

Создав индекс, вы можете протестировать созданный анализатор с помощью следующего запроса:

```http
POST https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-first-analyzer/analyze?api-version=2019-05-06
  Content-Type: application/json
  api-key: <YOUR-ADMIN-API-KEY>  

  {
    "text": "+1 (321) 555-0199",
    "analyzer": "phone_analyzer"
  }
```

Вы сможете увидеть коллекцию маркеров, полученных из телефонного номера:

```json
{
    "tokens": [
        {
            "token": "132",
            "startOffset": 1,
            "endOffset": 17,
            "position": 0
        },
        {
            "token": "1321",
            "startOffset": 1,
            "endOffset": 17,
            "position": 0
        },
        {
            "token": "13215",
            "startOffset": 1,
            "endOffset": 17,
            "position": 0
        },
        ...
        ...
        ...
    ]
}
```

## <a name="7---build-a-custom-analyzer-for-queries"></a>7\. Создание пользовательского анализатора для запросов

После выполнения некоторых примеров запросов для индекса с использованием пользовательского анализатора вы обнаружите, что полнота результатов улучшилась — теперь возвращаются все соответствующие номера телефонов. Но присутствуют и ложноположительные результаты, выдаваемые фильтром маркеров с N-граммами. Это распространенный побочный эффект использования такого фильтра.

Чтобы предотвратить возникновение ложноположительных результатов, мы создадим отдельный анализатор для отправки запросов. Этот анализатор будет аналогичен уже созданному анализатору, но **не будет включать** `custom_ngram_filter`.

```json
    {
      "@odata.type": "#Microsoft.Azure.Search.CustomAnalyzer",
      "name": "phone_analyzer_search",
      "tokenizer": "custom_tokenizer_phone",
      "tokenFilters": [],
      "charFilters": [
        "phone_char_mapping"
      ]
    }
```

В определении индекса мы затем укажем как `indexAnalyzer`, так и `searchAnalyzer`.

```json
    {
      "name": "phone_number",
      "type": "Edm.String",
      "sortable": false,
      "searchable": true,
      "filterable": false,
      "facetable": false,
      "indexAnalyzer": "phone_analyzer",
      "searchAnalyzer": "phone_analyzer_search"
    }
```

Внесите это изменение, и анализатор будет готов к работе. Повторно создайте индекс, проиндексируйте данные и повторно протестируйте запросы, чтобы убедиться в надлежащей работе поиска. Если вы используете коллекцию Postman, она создаст третий индекс с именем `tutorial-second-analyzer`.

<a name="Alternate"></a>

## <a name="alternate-approaches"></a>Альтернативные подходы

Созданный выше анализатор предназначен для обеспечения максимальной гибкости поиска. Но она достигается за счет хранения множества потенциально ненужных терминов в индексе.

В примере ниже показан другой анализатор, который также можно использовать для этой задачи. 

Такой анализатор работает хорошо, но не с входными данными в формате `14255550100`, что усложняет логическое фрагментирование телефонного номера. Например, анализатор не сможет отделить код страны (`1`) от кода зоны (`425`). Такое несоответствие приведет к тому, что указанный выше номер не будет получен при поиске, если пользователь не включил код страны в запрос.

```json
"analyzers": [
  {
    "@odata.type": "#Microsoft.Azure.Search.CustomAnalyzer",
    "name": "phone_analyzer_shingles",
    "tokenizer": "custom_tokenizer_phone",
    "tokenFilters": [
      "custom_shingle_filter"
    ]
  }
],
"tokenizers": [
  {
    "@odata.type": "#Microsoft.Azure.Search.StandardTokenizerV2",
    "name": "custom_tokenizer_phone",
    "maxTokenLength": 4
  }
],
"tokenFilters": [
  {
    "@odata.type": "#Microsoft.Azure.Search.ShingleTokenFilter",
    "name": "custom_shingle_filter",
    "minShingleSize": 2,
    "maxShingleSize": 6,
    "tokenSeparator": ""
  }
]
```

Ниже приведен пример, в котором номер телефона разделен на фрагменты, по которым обычно выполняют поиск пользователи.

|Входные данные|Выходные данные|  
|-|-|  
|`(321) 555-0199`|`[321, 555, 0199, 321555, 5550199, 3215550199]`|

В зависимости от ваших требований этот подход может быть более эффективным.

## <a name="reset-and-rerun"></a>Сброс и повторный запуск

Для простоты в этом руководстве показано, как создать три новых индекса. Но на ранних этапах разработки часто индексы приходится удалять и создавать повторно. Вы можете удалить индекс на портале Azure или с помощью следующего вызова API:

```http
DELETE https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/indexes/tutorial-basic-index?api-version=2019-05-06
  api-key: <YOUR-ADMIN-API-KEY>
```

## <a name="takeaways"></a>Общие выводы

В этом руководстве показано, как создать и протестировать пользовательский анализатор. Вы создали индекс, проиндексировали данные, а затем выполнили запросы к индексу для оценки результатов поиска. После этого вы применили API анализа текста и увидели процесс лексического анализа в действии.

Хотя анализатор, определенный в руководстве, предлагает простое решение для поиска по телефонным номерам, такой же процесс можно использовать для создания пользовательского анализатора телефонных номеров в любом сценарии.

## <a name="clean-up-resources"></a>Очистка ресурсов

Если вы работаете в своей подписке, после завершения проекта целесообразно удалить ресурсы, которые вам больше не нужны. Работающие ресурсы могут означать лишние затраты. Можно удалить отдельные ресурсы или удалить группу ресурсов, что позволит удалить весь набор ресурсов.

Просматривать ресурсы и управлять ими можно на портале с помощью ссылок "Все ресурсы" или "Группы ресурсов" в области навигации слева.

## <a name="next-steps"></a>Дальнейшие действия

Теперь, когда вы узнали, как создать пользовательский анализатор, мы рассмотрим разные фильтры, создатели маркеров и анализаторы, которые вы можете использовать для улучшения поиска.

> [!div class="nextstepaction"]
> [Пользовательские анализаторы в Когнитивном поиске Azure](index-add-custom-analyzers.md)
