---
title: Моделирование данных в Azure Cosmos DB
titleSuffix: Azure Cosmos DB
description: Сведения о моделировании данных в базах данных NoSQL и различиях между моделированием данных в реляционной базе данных и базе данных документов.
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 07/23/2019
ms.openlocfilehash: 523049ea3286445117f41147f3dd12a2c911d1ae
ms.sourcegitcommit: 8074f482fcd1f61442b3b8101f153adb52cf35c9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2019
ms.locfileid: "72755014"
---
# <a name="data-modeling-in-azure-cosmos-db"></a>Моделирование данных в Azure Cosmos DB

Несмотря на то, что базы данных без схемы, такие как Azure Cosmos DB, упрощают хранение и запрос неструктурированных и частичных данных, следует потратить некоторое время на обдумывание модели данных, чтобы получить наибольшую часть службы с точки зрения производительности, масштабируемости и минимальной маршрут.

Как данные будут храниться? Как приложение будет получать данные и выполнять запросы по ним? Приложение слишком интенсивно читается или слишком интенсивно записывается?

После прочтения этой статьи вы сможете ответить на следующие вопросы:

* Что такое моделирование данных и почему оно так важно?
* Как моделирование данных в Azure Cosmos DB отличается от модели реляционной базы данных?
* Как выразить связи данных в нереляционной базе данных?
* Когда следует внедрять данные, а когда — связывать?

## <a name="embedding-data"></a>Внедрение данных

При запуске моделирования данных в Azure Cosmos DB пытаться рассматривать сущности как **автономные элементы** , представленные в виде документов JSON.

Для сравнения, давайте сначала посмотрим, как можно моделировать данные в реляционной базе данных. В следующем примере показано, как можно сохранить в реляционной базе данных человека.

![Модель реляционной базы данных](./media/sql-api-modeling-data/relational-data-model.png)

При работе с реляционными базами данных стратегия заключается в нормализации всех данных. Нормализация данных обычно подразумевает получение сущности, например человека, и разбиение их на отдельные компоненты. В приведенном выше примере у пользователя может быть несколько записей контактных данных, а также несколько записей адресов. Контактные данные можно дополнительно разделить, извлекая общие поля, такие как тип. То же самое касается адреса, каждая запись может иметь тип *Home* или *Business*.

Руководящий принцип при нормализации данных заключается в том, чтобы **избегать хранения избыточных данных** в каждой записи и использовать только ссылки на эти данные. В этом примере для чтения человека со всеми его контактными данными и адресами необходимо использовать объединения для эффективного создания (или денормализации) данных во время выполнения.

    SELECT p.FirstName, p.LastName, a.City, cd.Detail
    FROM Person p
    JOIN ContactDetail cd ON cd.PersonId = p.Id
    JOIN ContactDetailType cdt ON cdt.Id = cd.TypeId
    JOIN Address a ON a.PersonId = p.Id

Чтобы обновить сведения о контактах и адреса для отдельного человека, требуется выполнить операции записи для множества отдельных таблиц.

Теперь давайте посмотрим, как мы будем моделировать те же данные, что и автономная сущность в Azure Cosmos DB.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "addresses": [
            {
                "line1": "100 Some Street",
                "line2": "Unit 1",
                "city": "Seattle",
                "state": "WA",
                "zip": 98012
            }
        ],
        "contactDetails": [
            {"email": "thomas@andersen.com"},
            {"phone": "+1 555 555-5555", "extension": 5555}
        ]
    }

Используя описанный выше подход, мы **денормализовани** запись о лице, **внедрив** всю информацию, относящуюся к этому человеку, например контактные данные и адреса, в *один документ JSON* .
Кроме того, отсутствие привязки к фиксированной схеме повышает гибкость работы, например, мы можем использовать сведения о контактах в самых разных формах.

Получение полной записи о лице из базы данных теперь представляет собой **одну операцию чтения** для одного контейнера и для одного элемента. Обновление записи о лице с контактными данными и адресами также является **одной операцией записи** для одного элемента.

Благодаря денормализации данных ваше приложение может использовать меньше запросов и обновлений для выполнения распространенных операций.

### <a name="when-to-embed"></a>Когда следует использовать внедрение

В общем случае модели внедренных данных следует использовать в следующих ситуациях:

* Между сущностями **существуют связи.**
* между сущностями существуют связи **один к нескольким** ;
* имеются внедренные данные, которые **редко изменяются**;
* Существуют внедренные данные, которые не будут увеличиваться **без привязки**.
* Существуют внедренные данные, которые **часто запрашиваются вместе**.

> [!NOTE]
> Обычно модели денормализованных данных обеспечивают повышенную производительность при **чтении** .

### <a name="when-not-to-embed"></a>Когда внедрение использовать не следует

Хотя правило «Thumb» в Azure Cosmos DBе состоит в денормализации всего содержимого и внедрении всех данных в один элемент, это может привести к возникновению некоторых ситуаций, которые следует избегать.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "comments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            …
            {"id": 100001, "author": "jane", "comment": "and on we go ..."},
            …
            {"id": 1000000001, "author": "angry", "comment": "blah angry blah angry"},
            …
            {"id": ∞ + 1, "author": "bored", "comment": "oh man, will this ever end?"},
        ]
    }

Так могла бы выглядеть сущность публикации с внедренными комментариями, если бы мы моделировали обычный блог или систему CMS. Проблема с данным примером заключается в том, что массив комментариев является **неограниченным**, то есть не существует (фактического) предела для количества комментариев, которое может иметь отдельная публикация. Это может стать проблемой, так как размер элемента может увеличиваться бесконечно большим.

По мере увеличения размера элемента может снизиться возможность передачи данных по сети, а также чтения и обновления элемента в масштабе.

В этом случае лучше рассмотреть следующую модель данных.

    Post item:
    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "recentComments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            {"id": 3, "author": "jane", "comment": "....."}
        ]
    }

    Comment items:
    {
        "postId": "1"
        "comments": [
            {"id": 4, "author": "anon", "comment": "more goodness"},
            {"id": 5, "author": "bob", "comment": "tails from the field"},
            ...
            {"id": 99, "author": "angry", "comment": "blah angry blah angry"}
        ]
    },
    {
        "postId": "1"
        "comments": [
            {"id": 100, "author": "anon", "comment": "yet more"},
            ...
            {"id": 199, "author": "bored", "comment": "will this ever end?"}
        ]
    }

Эта модель содержит три последних комментария, внедренных в контейнер POST, который является массивом с фиксированным набором атрибутов. Другие комментарии группируются в пакетах 100 комментариев и хранятся в виде отдельных элементов. Размер пакета был выбран равным 100, поскольку наше условное приложение позволяет пользователю отправить 100 комментариев за один раз.  

Другой случай, когда внедрение данных не является хорошей идеей, заключается в том, что внедренные данные часто используются в разных элементах и будут часто меняться.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            {
                "numberHeld": 100,
                "stock": { "symbol": "zaza", "open": 1, "high": 2, "low": 0.5 }
            },
            {
                "numberHeld": 50,
                "stock": { "symbol": "xcxc", "open": 89, "high": 93.24, "low": 88.87 }
            }
        ]
    }

Этот код может представлять биржевой портфель человека. Мы решили внедрить информацию об акциях в каждый документ портфеля. В среде, где связанные данные регулярно изменяются, например, в приложении биржевых торгов, внедрение часто изменяемых данных означает, что вы постоянно обновляете каждый документ портфеля при выполнении торговой операции с каждой акцией.

В течение дня акции *zaza* могут покупать и продавать сотни раз, и *zaza* могут входить в портфели тысяч пользователей. В случае использования описанной выше модели данных нам пришлось бы обновлять многие тысячи документов портфелей каждый день, что затруднило бы масштабирование системы.

## <a name="referencing-data"></a>Ссылки на данные

Внедрение данных прекрасно работает во многих случаях, но существуют ситуации, когда денормализация данных приведет к большему числу проблем, чем стоит. Что же нам делать теперь?

Связи между сущностями можно задавать не только в реляционных базах данных. В базе данных документов можно получить сведения в одном документе, относящемся к данным в других документах. Не рекомендуется создавать системы, которые лучше подходят для реляционной базы данных в Azure Cosmos DB или в любой другой базе данных документов, но простые связи прекрасно подходят и могут быть полезными.

В приведенном ниже коде JSON мы решили использовать использованный ранее пример биржевого портфеля, однако здесь мы не внедряем элемент акции в портфеле, а ссылаемся на него. Если элемент акции часто изменяется в течение дня, то обновлять требуется единственный документ акции.

    Person document:
    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            { "numberHeld":  100, "stockId": 1},
            { "numberHeld":  50, "stockId": 2}
        ]
    }

    Stock documents:
    {
        "id": "1",
        "symbol": "zaza",
        "open": 1,
        "high": 2,
        "low": 0.5,
        "vol": 11970000,
        "mkt-cap": 42000000,
        "pe": 5.89
    },
    {
        "id": "2",
        "symbol": "xcxc",
        "open": 89,
        "high": 93.24,
        "low": 88.87,
        "vol": 2970200,
        "mkt-cap": 1005000,
        "pe": 75.82
    }

Недостаток такого подхода проявляется, когда приложению нужно отобразить информацию о каждой имеющейся акции в портфеле человека; в этом случае потребуется выполнить множество обращений к базе данных, чтобы загрузить информацию для каждого документа акции. Здесь мы приняли решение повысить эффективность операций записи, которые часто выполняются в течение дня, однако это затруднило выполнение операций чтения, которые оказывают меньшее влияние на производительность всей данной системы.

> [!NOTE]
> Модели нормализованных данных **могут потребовать больше круговых путей** к серверу.

### <a name="what-about-foreign-keys"></a>Сведения о внешнем ключе

Поскольку в настоящий момент концепция ограничения, основанная на внешнем ключе или чем-либо другом, отсутствует, все связи между документами представляют собой "слабые звенья" и не проверяются базой данных. Если вы хотите убедиться, что данные, на которые ссылается документ, действительно существуют, это нужно сделать в приложении либо с помощью триггеров на стороне сервера или хранимых процедур в Azure Cosmos DB.

### <a name="when-to-reference"></a>Когда следует использовать ссылки

В общем случае модели нормализованных данных следует использовать в следующих ситуациях:

* Осуществляется представление связей **один ко многим** .
* Осуществляется представление связей **многие ко многим** .
* Связанные данные **часто изменяются**.
* Данные, на которые указывает ссылка, могут быть **неограниченными**.

> [!NOTE]
> Обычно нормализация обеспечивает повышенную производительность при **записи** .

### <a name="where-do-i-put-the-relationship"></a>Куда следует поместить связь

Рост связи поможет определить, в каком документе следует сохранить ссылку.

Давайте рассмотрим следующий код JSON, моделирующий издателей и книги.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press",
        "books": [ 1, 2, 3, ..., 100, ..., 1000]
    }

    Book documents:
    {"id": "1", "name": "Azure Cosmos DB 101" }
    {"id": "2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "3", "name": "Taking over the world one JSON doc at a time" }
    ...
    {"id": "100", "name": "Learn about Azure Cosmos DB" }
    ...
    {"id": "1000", "name": "Deep Dive into Azure Cosmos DB" }

Если на издателя приходится небольшое число книг, а рост ограничен, то может оказаться удобным хранить ссылку на книгу в документе издателя. Однако если число книг на издателя не имеет ограничений, эта модель данных приведет к изменяемым и разрастающимся массивам, как в приведенном выше примере с документом издателя.

Небольшая доработка помогает получить модель, которая все еще представляет те же данные, однако избавляется от крупных изменяемых коллекций.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press"
    }

    Book documents:
    {"id": "1","name": "Azure Cosmos DB 101", "pub-id": "mspress"}
    {"id": "2","name": "Azure Cosmos DB for RDBMS Users", "pub-id": "mspress"}
    {"id": "3","name": "Taking over the world one JSON doc at a time"}
    ...
    {"id": "100","name": "Learn about Azure Cosmos DB", "pub-id": "mspress"}
    ...
    {"id": "1000","name": "Deep Dive into Azure Cosmos DB", "pub-id": "mspress"}

В приведенном выше примере мы помещали неограниченную коллекцию в документ издателя. Вместо этого мы просто воспользуемся ссылкой на издателя в каждом документе книги.

### <a name="how-do-i-model-manymany-relationships"></a>Как моделировать связи "многие ко многим"

В реляционной базе данных связи *многие ко многим* часто моделируются с помощью таблиц JOIN, которые просто соединяют вместе записи из других таблиц.

![Объединенные таблицы](./media/sql-api-modeling-data/join-table.png)

У вас может возникнуть желание реплицировать это с помощью документов и создать модель данных, аналогичную приведенной ниже.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen" }
    {"id": "a2", "name": "William Wakefield" }

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101" }
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "b3", "name": "Taking over the world one JSON doc at a time" }
    {"id": "b4", "name": "Learn about Azure Cosmos DB" }
    {"id": "b5", "name": "Deep Dive into Azure Cosmos DB" }

    Joining documents:
    {"authorId": "a1", "bookId": "b1" }
    {"authorId": "a2", "bookId": "b1" }
    {"authorId": "a1", "bookId": "b2" }
    {"authorId": "a1", "bookId": "b3" }

Такой подход будет работать. Однако при загрузке автора вместе с его книгами или книги вместе с ее автором всегда потребуется отправлять два дополнительных запроса в базу данных. Один запрос отправляется в документ присоединения, а другой — для получения самого присоединяемого документа.

Если эта таблица JOIN всего лишь соединяет два элемента данных, почему бы просто не отказаться от нее?
Давайте рассмотрим следующее.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen", "books": ["b1, "b2", "b3"]}
    {"id": "a2", "name": "William Wakefield", "books": ["b1", "b4"]}

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101", "authors": ["a1", "a2"]}
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users", "authors": ["a1"]}
    {"id": "b3", "name": "Learn about Azure Cosmos DB", "authors": ["a1"]}
    {"id": "b4", "name": "Deep Dive into Azure Cosmos DB", "authors": ["a2"]}

Теперь, если у меня есть автор, я сразу же знал, какие книги были написаны, и наоборот, если у меня был загружен документ книги, я бы знал идентификаторы авторов. Это позволяет отказаться от промежуточного запроса к таблице JOIN и сократить количество круговых путей для вашего приложения.

## <a name="hybrid-data-models"></a>Гибридные модели данных

Мы рассмотрели внедрение данных (или денормализацию) и использование ссылок на данные (или нормализацию), а также преимущества и недостатки этих подходов.

Однако далеко не всегда следует придерживаться лишь одного из подходов, можно попробовать совместить их.

Учитывая применяемые в приложении схемы использования и рабочие нагрузки, в некоторых случаях совмещение внедрения и ссылок может иметь смысл и позволяет упростить логическую схему приложения, сократить число круговых путей к серверу и при этом сохранить высокий уровень производительности.

Давайте рассмотрим следующий код JSON.

    Author documents:
    {
        "id": "a1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "countOfBooks": 3,
        "books": ["b1", "b2", "b3"],
        "images": [
            {"thumbnail": "https://....png"}
            {"profile": "https://....png"}
            {"large": "https://....png"}
        ]
    },
    {
        "id": "a2",
        "firstName": "William",
        "lastName": "Wakefield",
        "countOfBooks": 1,
        "books": ["b1"],
        "images": [
            {"thumbnail": "https://....png"}
        ]
    }

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
            {"id": "a2", "name": "William Wakefield", "thumbnailUrl": "https://....png"}
        ]
    },
    {
        "id": "b2",
        "name": "Azure Cosmos DB for RDBMS Users",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
        ]
    }

Здесь мы в большей степени придерживались модели внедрения, где данные из других сущностей внедряются в документ верхнего уровня, однако для остальных данных используются ссылки.

Если взглянуть на документ книги, можно заметить несколько интересных полей в массиве авторов. Поле `id`, которое используется для ссылки на авторский документ, является стандартным методом в нормализованной модели, но у нас также есть `name` и `thumbnailUrl`. Мы могли бы задержаться в `id` и оставить приложение, чтобы получить дополнительную информацию из соответствующего документа автора, используя "Link", но так как наше приложение отображает имя автора и эскиз с каждой книгой, которую вы выводите может сэкономить круговой путь к серверу на каждую книгу в списке, выполняя нормализацию **данных от** автора.

Конечно, если имя автора изменилось или хотели бы обновить свою фотографию, нам пришлось бы перейти и обновить каждую книгу, опубликованную ранее, но для нашего приложения, исходя из предположения, что авторы не меняют имена часто, это приемлемое решение проекта.  

В примере используются значения **предварительно вычисленных статистических выражений**, чтобы сэкономить вычислительные ресурсы на операции чтения. В данном примере некоторые данные, внедренные в документ автора, вычисляются во время выполнения. Каждый раз при публикации новой книги создается документ книги, **и** для поля countOfBooks задается вычисленное значение, зависящее от числа существующих для данного автора документов книги. Такая оптимизация хорошо подходит для систем с большим количеством операций чтения, где можно выполнять вычисления в операциях записи для повышения производительности операций чтения.

Использование модели с предварительно вычисленными значениями в полях стало возможным благодаря тому, что Azure Cosmos DB поддерживает **транзакции с несколькими документами**. Многие хранилища NoSQL не позволяют выполнять транзакции между документами, что вынуждает слепо следовать правилу "всегда внедряйте все, что можно". В Azure Cosmos DB вы можете использовать триггеры на стороне сервера или хранимые процедуры, которые вставляют книги и обновляют авторов в рамках транзакции ACID. Теперь вам не **обязательно** внедрять все в один документ просто для того, чтобы обеспечить согласованность данных.

## <a name="distinguishing-between-different-document-types"></a>Различия между различными типами документов

В некоторых случаях может потребоваться смешивать различные типы документов в одной коллекции. Обычно это происходит, когда требуется, чтобы несколько связанных документов находились в одном [разделе](partitioning-overview.md). Например, можно разместить книги и обзоры книг в одной и той же коллекции и секционировать их с помощью `bookId`. В такой ситуации обычно требуется добавить в документы поле, определяющее их тип, чтобы отличать их.

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "bookId": "b1",
        "type": "book"
    }

    Review documents:
    {
        "id": "r1",
        "content": "This book is awesome",
        "bookId": "b1",
        "type": "review"
    },
    {
        "id": "r2",
        "content": "Best book ever!",
        "bookId": "b1",
        "type": "review"
    }

## <a name="next-steps"></a>Дальнейшие действия

Основная идея этой статьи заключается в том, что моделирование данных без фиксированных схем не теряет своей актуальности.

Как не существует единственного способа представить элемент данных на экране, нет такого способа и для моделирования данных. Необходимо разобраться в принципах работы приложения, его механизмах формирования, использования и обработки данных. После этого с помощью представленных здесь рекомендаций вы можете приступить к созданию модели, которая оптимально соответствует основным потребностям вашего приложения. Благодаря отсутствию схемы в базе данных вы можете оперативно вносить изменения в приложения и легко корректировать модель данных соответствующим образом.

Дополнительные сведения об Azure Cosmos DB см. на странице [документации](https://azure.microsoft.com/documentation/services/cosmos-db/) по этой службе.

Чтобы понять, как сегментировать данные по нескольким разделам, ознакомьтесь со статьей [Секционирование, ключи секции и масштабирование в DocumentDB](sql-api-partition-data.md).

Чтобы узнать, как моделировать и секционировать данные на Azure Cosmos DB с помощью практического примера, см. [Пример моделирования данных и секционирования — реальные примеры](how-to-model-partition-example.md).
