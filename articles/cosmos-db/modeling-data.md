---
title: Моделирование данных в Azure Cosmos DB
titleSuffix: Azure Cosmos DB
description: Сведения о моделировании данных в базах данных NoSQL и различиях между моделированием данных в реляционной базе данных и базе данных документов.
author: rimman
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 04/08/2019
ms.author: rimman
ms.custom: rimman
ms.openlocfilehash: e8581cb130c8b2d7ac044838f0ae922b9b5e86cd
ms.sourcegitcommit: c174d408a5522b58160e17a87d2b6ef4482a6694
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59792121"
---
# <a name="data-modeling-in-azure-cosmos-db"></a>Моделирование данных в Azure Cosmos DB

Хотя схемы базы данных, как Azure Cosmos DB, существенно упрощают для хранения и запроса неструктурированных и частично структурированных данных, вам следует уделить время вашей модели данных, чтобы получить все преимущества с точки зрения производительности и масштабируемости службы и минимальной стоимость.

Как данные будут храниться? Как приложение будет получать данные и выполнять запросы по ним? Такое приложение интенсивными операциями чтения или интенсивными операциями записи

После прочтения этой статьи вы сможете ответить на следующие вопросы:

* Что такое моделирование данных и почему оно так важно?
* Чем отличается моделирование данных в Azure Cosmos DB в реляционной базе данных?
* Как выразить связи данных в нереляционной базе данных?
* Когда следует внедрять данные, а когда — связывать?

## <a name="embedding-data"></a>Внедрение данных

Когда вы начинаете моделировать данные в Azure Cosmos DB, попробуйте обрабатывать свои сущности как **автономное элементы** представлены в виде документов JSON.

Для сравнения давайте сначала посмотрим, как можно смоделировать в реляционной базе данных. В следующем примере показано, как можно сохранить в реляционной базе данных человека.

![Модель реляционной базы данных](./media/sql-api-modeling-data/relational-data-model.png)

При работе с реляционными базами данных, стратегия — нормализовать все ваши данные. Нормализация данных обычно включает в себя взять сущность, например человека и разбить ее на дискретные компоненты. В приведенном выше примере специалист службы может иметь несколько записей сведениями о контактах, а также несколько записей с адресом. Сведения о контактах можно разделить, извлекая Общие поля, такие как тип. То же применимо к адресу, каждая запись может иметь тип *Главная* или *бизнеса*.

Руководящий принцип при нормализации данных заключается в том, чтобы **избегать хранения избыточных данных** в каждой записи и использовать только ссылки на эти данные. В этом примере, чтобы считать данные о человеке со всеми сведения о контактах и адреса необходимо использовать СОЕДИНЕНИЯ эффективно compose обратно (или выполнить денормализацию) данных во время выполнения.

    SELECT p.FirstName, p.LastName, a.City, cd.Detail
    FROM Person p
    JOIN ContactDetail cd ON cd.PersonId = p.Id
    JOIN ContactDetailType on cdt ON cdt.Id = cd.TypeId
    JOIN Address a ON a.PersonId = p.Id

Чтобы обновить сведения о контактах и адреса для отдельного человека, требуется выполнить операции записи для множества отдельных таблиц.

Теперь давайте рассмотрим как смоделировать же данные в виде самодостаточной сущности в Azure Cosmos DB.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "addresses": [
            {
                "line1": "100 Some Street",
                "line2": "Unit 1",
                "city": "Seattle",
                "state": "WA",
                "zip": 98012
            }
        ],
        "contactDetails": [
            {"email": "thomas@andersen.com"},
            {"phone": "+1 555 555-5555", "extension": 5555}
        ]
    }

Используя подход выше мы имеют **денормализованные** записи человека, с **внедрение** все сведения, относящиеся к этого человека, такие как свои сведения о контактах и адреса, в *единый JSON* документа.
Кроме того, отсутствие привязки к фиксированной схеме повышает гибкость работы, например, мы можем использовать сведения о контактах в самых разных формах.

Получение всей записи человека из базы данных является теперь **операция чтения одной** от одного контейнера, а также для одного элемента. Обновление записи человека, с помощью свои сведения о контактах и адреса, также является **единый операции записи** от одного элемента.

Благодаря денормализации данных ваше приложение может использовать меньше запросов и обновлений для выполнения распространенных операций.

### <a name="when-to-embed"></a>Когда следует использовать внедрение

В общем случае модели внедренных данных следует использовать в следующих ситуациях:

* Существуют **содержится** связи между сущностями.
* между сущностями существуют связи **один к нескольким** ;
* имеются внедренные данные, которые **редко изменяются**;
* Внедренные данные, не будет увеличиваться **без границы**.
* Внедренные данные, **отправляется запрос на получение часто**.

> [!NOTE]
> Обычно модели денормализованных данных обеспечивают повышенную производительность при **чтении** .

### <a name="when-not-to-embed"></a>Когда внедрение использовать не следует

Несмотря на то опыт в Azure Cosmos DB, чтобы выполнить денормализацию всех элементов и внедрить все данные в один элемент, это может привести к некоторым нежелательным ситуациям.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "comments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            …
            {"id": 100001, "author": "jane", "comment": "and on we go ..."},
            …
            {"id": 1000000001, "author": "angry", "comment": "blah angry blah angry"},
            …
            {"id": ∞ + 1, "author": "bored", "comment": "oh man, will this ever end?"},
        ]
    }

Так могла бы выглядеть сущность публикации с внедренными комментариями, если бы мы моделировали обычный блог или систему CMS. Проблема с данным примером заключается в том, что массив комментариев является **неограниченным**, то есть не существует (фактического) предела для количества комментариев, которое может иметь отдельная публикация. Это может стать проблемой, так как размер элемента может увеличиваться бесконечно большой.

При этом снижается возможность передачи данных по сети, а также чтения и обновления элемента, в масштабе, при увеличении размера элемента.

В этом случае лучше рассмотреть следующую модель данных.

    Post item:
    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "recentComments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            {"id": 3, "author": "jane", "comment": "....."}
        ]
    }

    Comment items:
    {
        "postId": "1"
        "comments": [
            {"id": 4, "author": "anon", "comment": "more goodness"},
            {"id": 5, "author": "bob", "comment": "tails from the field"},
            ...
            {"id": 99, "author": "angry", "comment": "blah angry blah angry"}
        ]
    },
    {
        "postId": "1"
        "comments": [
            {"id": 100, "author": "anon", "comment": "yet more"},
            ...
            {"id": 199, "author": "bored", "comment": "will this ever end?"}
        ]
    }

Эта модель имеет три последние комментарии в контейнере post, который является массивом с фиксированный набор атрибутов. Другие комментарии сгруппированы в пакеты 100 комментариев и хранятся в виде отдельных элементов. Размер пакета был выбран равным 100, поскольку наше условное приложение позволяет пользователю отправить 100 комментариев за один раз.  

Еще один случай, где внедрение данных не имеет смысл при внедренные данные часто используются в разных элементов и постоянно изменяются.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            {
                "numberHeld": 100,
                "stock": { "symbol": "zaza", "open": 1, "high": 2, "low": 0.5 }
            },
            {
                "numberHeld": 50,
                "stock": { "symbol": "xcxc", "open": 89, "high": 93.24, "low": 88.87 }
            }
        ]
    }

Этот код может представлять биржевой портфель человека. Мы решили внедрить информацию об акциях в каждый документ портфеля. В среде, где связанные данные регулярно изменяются, например, в приложении биржевых торгов, внедрение часто изменяемых данных означает, что вы постоянно обновляете каждый документ портфеля при выполнении торговой операции с каждой акцией.

В течение дня акции *zaza* могут покупать и продавать сотни раз, и *zaza* могут входить в портфели тысяч пользователей. В случае использования описанной выше модели данных нам пришлось бы обновлять многие тысячи документов портфелей каждый день, что затруднило бы масштабирование системы.

## <a name="referencing-data"></a>Ссылки на данные

Таким образом, внедрение данных отлично подходит для многих ситуаций, однако совершенно ясно, что существуют сценарии, в которых денормализация данных вызовет больше проблем, чем поможет решить. Что же нам делать теперь?

Связи между сущностями можно задавать не только в реляционных базах данных. В базе данных документов можно поместить в один документ сведения, которые ссылаются на данные в других документах. Я не спорю, что мы создаем системы, которые лучше подходят для реляционной базы данных в Azure Cosmos DB или любой другой базы данных документов, однако простые связи легко реализуются и могут быть полезны.

В приведенном ниже коде JSON мы решили использовать использованный ранее пример биржевого портфеля, однако здесь мы не внедряем элемент акции в портфеле, а ссылаемся на него. Если элемент акции часто изменяется в течение дня, то обновлять требуется единственный документ акции.

    Person document:
    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            { "numberHeld":  100, "stockId": 1},
            { "numberHeld":  50, "stockId": 2}
        ]
    }

    Stock documents:
    {
        "id": "1",
        "symbol": "zaza",
        "open": 1,
        "high": 2,
        "low": 0.5,
        "vol": 11970000,
        "mkt-cap": 42000000,
        "pe": 5.89
    },
    {
        "id": "2",
        "symbol": "xcxc",
        "open": 89,
        "high": 93.24,
        "low": 88.87,
        "vol": 2970200,
        "mkt-cap": 1005000,
        "pe": 75.82
    }

Недостаток такого подхода проявляется, когда приложению нужно отобразить информацию о каждой имеющейся акции в портфеле человека; в этом случае потребуется выполнить множество обращений к базе данных, чтобы загрузить информацию для каждого документа акции. Здесь мы приняли решение повысить эффективность операций записи, которые часто выполняются в течение дня, однако это затруднило выполнение операций чтения, которые оказывают меньшее влияние на производительность всей данной системы.

> [!NOTE]
> Модели нормализованных данных **могут потребовать больше круговых путей** к серверу.

### <a name="what-about-foreign-keys"></a>Сведения о внешнем ключе

Поскольку в настоящий момент концепция ограничения, основанная на внешнем ключе или чем-либо другом, отсутствует, все связи между документами представляют собой "слабые звенья" и не проверяются базой данных. Если вы хотите убедиться, что данные, на которые ссылается документ, действительно существуют, это нужно сделать в приложении либо с помощью триггеров на стороне сервера или хранимых процедур в Azure Cosmos DB.

### <a name="when-to-reference"></a>Когда следует использовать ссылки

В общем случае модели нормализованных данных следует использовать в следующих ситуациях:

* Осуществляется представление связей **один ко многим** .
* Осуществляется представление связей **многие ко многим** .
* Связанные данные **часто изменяются**.
* Данные, на которые указывает ссылка, могут быть **неограниченными**.

> [!NOTE]
> Обычно нормализация обеспечивает повышенную производительность при **записи** .

### <a name="where-do-i-put-the-relationship"></a>Куда следует поместить связь

Рост связи поможет определить, в каком документе следует сохранить ссылку.

Давайте рассмотрим следующий код JSON, моделирующий издателей и книги.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press",
        "books": [ 1, 2, 3, ..., 100, ..., 1000]
    }

    Book documents:
    {"id": "1", "name": "Azure Cosmos DB 101" }
    {"id": "2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "3", "name": "Taking over the world one JSON doc at a time" }
    ...
    {"id": "100", "name": "Learn about Azure Cosmos DB" }
    ...
    {"id": "1000", "name": "Deep Dive into Azure Cosmos DB" }

Если на издателя приходится небольшое число книг, а рост ограничен, то может оказаться удобным хранить ссылку на книгу в документе издателя. Однако если число книг на издателя не имеет ограничений, эта модель данных приведет к изменяемым и разрастающимся массивам, как в приведенном выше примере с документом издателя.

Небольшая доработка помогает получить модель, которая все еще представляет те же данные, однако избавляется от крупных изменяемых коллекций.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press"
    }

    Book documents:
    {"id": "1","name": "Azure Cosmos DB 101", "pub-id": "mspress"}
    {"id": "2","name": "Azure Cosmos DB for RDBMS Users", "pub-id": "mspress"}
    {"id": "3","name": "Taking over the world one JSON doc at a time"}
    ...
    {"id": "100","name": "Learn about Azure Cosmos DB", "pub-id": "mspress"}
    ...
    {"id": "1000","name": "Deep Dive into Azure Cosmos DB", "pub-id": "mspress"}

В приведенном выше примере мы помещали неограниченную коллекцию в документ издателя. Вместо этого мы просто воспользуемся ссылкой на издателя в каждом документе книги.

### <a name="how-do-i-model-manymany-relationships"></a>Как моделировать связи "многие ко многим"

В реляционной базе данных связи *многие ко многим* часто моделируются с помощью таблиц JOIN, которые просто соединяют вместе записи из других таблиц.

![Объединенные таблицы](./media/sql-api-modeling-data/join-table.png)

У вас может возникнуть желание реплицировать это с помощью документов и создать модель данных, аналогичную приведенной ниже.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen" }
    {"id": "a2", "name": "William Wakefield" }

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101" }
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "b3", "name": "Taking over the world one JSON doc at a time" }
    {"id": "b4", "name": "Learn about Azure Cosmos DB" }
    {"id": "b5", "name": "Deep Dive into Azure Cosmos DB" }

    Joining documents:
    {"authorId": "a1", "bookId": "b1" }
    {"authorId": "a2", "bookId": "b1" }
    {"authorId": "a1", "bookId": "b2" }
    {"authorId": "a1", "bookId": "b3" }

Такой подход будет работать. Однако при загрузке автора вместе с его книгами или книги вместе с ее автором всегда потребуется отправлять два дополнительных запроса в базу данных. Один запрос отправляется в документ присоединения, а другой — для получения самого присоединяемого документа.

Если эта таблица JOIN всего лишь соединяет два элемента данных, почему бы просто не отказаться от нее?
Давайте рассмотрим следующее.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen", "books": ["b1, "b2", "b3"]}
    {"id": "a2", "name": "William Wakefield", "books": ["b1", "b4"]}

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101", "authors": ["a1", "a2"]}
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users", "authors": ["a1"]}
    {"id": "b3", "name": "Learn about Azure Cosmos DB", "authors": ["a1"]}
    {"id": "b4", "name": "Deep Dive into Azure Cosmos DB", "authors": ["a2"]}

Теперь если у меня есть автор, я сразу знать, какие книги он написал, и и наоборот, если у меня загружен документ книги я знаю идентификаторы авторов. Это позволяет отказаться от промежуточного запроса к таблице JOIN и сократить количество круговых путей для вашего приложения.

## <a name="hybrid-data-models"></a>Гибридные модели данных

Мы рассмотрели внедрение данных (или денормализацию) и использование ссылок на данные (или нормализацию), а также преимущества и недостатки этих подходов.

Однако далеко не всегда следует придерживаться лишь одного из подходов, можно попробовать совместить их.

Учитывая применяемые в приложении схемы использования и рабочие нагрузки, в некоторых случаях совмещение внедрения и ссылок может иметь смысл и позволяет упростить логическую схему приложения, сократить число круговых путей к серверу и при этом сохранить высокий уровень производительности.

Давайте рассмотрим следующий код JSON.

    Author documents:
    {
        "id": "a1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "countOfBooks": 3,
        "books": ["b1", "b2", "b3"],
        "images": [
            {"thumbnail": "https://....png"}
            {"profile": "https://....png"}
            {"large": "https://....png"}
        ]
    },
    {
        "id": "a2",
        "firstName": "William",
        "lastName": "Wakefield",
        "countOfBooks": 1,
        "books": ["b1"],
        "images": [
            {"thumbnail": "https://....png"}
        ]
    }

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
            {"id": "a2", "name": "William Wakefield", "thumbnailUrl": "https://....png"}
        ]
    },
    {
        "id": "b2",
        "name": "Azure Cosmos DB for RDBMS Users",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
        ]
    }

Здесь мы в большей степени придерживались модели внедрения, где данные из других сущностей внедряются в документ верхнего уровня, однако для остальных данных используются ссылки.

Если взглянуть на документ книги, можно заметить несколько интересных полей в массиве авторов. Существует `id` это поле используется для обратной ссылки на документ автора, стандартным решением в модели нормализации, но у нас также есть `name` и `thumbnailUrl`. Мы может работать с `id` и заставить приложение для получения соответствующего документа автора с использованием «ссылки», никаких дополнительных сведений, она нужна, но поскольку наше приложение выводит имя автора и эскиз с каждую книгу отображается, мы сохраняем круговом пути к серверу на каждую книгу в список путем денормализации **некоторые** данных об авторе.

Конечно Если изменить имя автора или обновления его фотографии нам пришлось бы перейти и обновить каждую книгу, они никогда не опубликована, но для нашего приложения, основываясь на предположении, что авторы часто меняют свои имена, это решение вполне.  

В примере используются значения **предварительно вычисленных статистических выражений**, чтобы сэкономить вычислительные ресурсы на операции чтения. В данном примере некоторые данные, внедренные в документ автора, вычисляются во время выполнения. Каждый раз при публикации новой книги создается документ книги, **и** для поля countOfBooks задается вычисленное значение, зависящее от числа существующих для данного автора документов книги. Такая оптимизация хорошо подходит для систем с большим количеством операций чтения, где можно выполнять вычисления в операциях записи для повышения производительности операций чтения.

Использование модели с предварительно вычисленными значениями в полях стало возможным благодаря тому, что Azure Cosmos DB поддерживает **транзакции с несколькими документами**. Многие хранилища NoSQL не позволяют выполнять транзакции между документами, что вынуждает слепо следовать правилу "всегда внедряйте все, что можно". В Azure Cosmos DB вы можете использовать триггеры на стороне сервера или хранимые процедуры, которые вставляют книги и обновляют авторов в рамках транзакции ACID. Теперь вам не **обязательно** внедрять все в один документ просто для того, чтобы обеспечить согласованность данных.

## <a name="distinguishing-between-different-document-types"></a>Различить разные типы документов

В некоторых сценариях может потребоваться смешивать разные типы документов в одной и той же коллекции; Это обычно происходит, когда требуется несколько связанных документов, находиться в том же [секции](partitioning-overview.md). Например, можно поместить обе книги и обзоры в одной коллекции книг и секционирование по `bookId`. В такой ситуации обычно требуется добавить в документы с полем, которое определяет их тип, чтобы различать их.

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "bookId": "b1",
        "type": "book"
    }

    Review documents:
    {
        "id": "r1",
        "content": "This book is awesome",
        "bookId": "b1",
        "type": "review"
    },
    {
        "id": "r2",
        "content": "Best book ever!",
        "bookId": "b1",
        "type": "review"
    }

## <a name="next-steps"></a>Дальнейшие действия

Основная идея этой статьи заключается в том, что моделирование данных без фиксированных схем не теряет своей актуальности.

Как не существует единственного способа представить элемент данных на экране, нет такого способа и для моделирования данных. Необходимо разобраться в принципах работы приложения, его механизмах формирования, использования и обработки данных. После этого с помощью представленных здесь рекомендаций вы можете приступить к созданию модели, которая оптимально соответствует основным потребностям вашего приложения. Благодаря отсутствию схемы в базе данных вы можете оперативно вносить изменения в приложения и легко корректировать модель данных соответствующим образом.

Дополнительные сведения об Azure Cosmos DB см. на странице [документации](https://azure.microsoft.com/documentation/services/cosmos-db/) по этой службе.

Чтобы понять, как сегментировать данные по нескольким разделам, ознакомьтесь со статьей [Секционирование, ключи секции и масштабирование в DocumentDB](sql-api-partition-data.md).
