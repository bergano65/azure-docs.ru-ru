---
title: Диагностика и устранение проблем с запросами при использовании Azure Cosmos DB
description: Узнайте, как определять, диагностировать и устранять неполадки Azure Cosmos DB запросов SQL.
author: ginamr
ms.service: cosmos-db
ms.topic: troubleshooting
ms.date: 07/10/2019
ms.author: girobins
ms.subservice: cosmosdb-sql
ms.reviewer: sngun
ms.openlocfilehash: fd8e80c7cd7cb71e4e0418d970cf2f328f1a3d79
ms.sourcegitcommit: dbde4aed5a3188d6b4244ff7220f2f75fce65ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/19/2019
ms.locfileid: "74184714"
---
# <a name="troubleshoot-query-performance-for-azure-cosmos-db"></a>Устранение неполадок с производительностью запросов для Azure Cosmos DB
В этой статье описывается, как определять, диагностировать и устранять неполадки Azure Cosmos DB запросов SQL. Чтобы добиться оптимальной производительности для Azure Cosmos DBных запросов, выполните описанные ниже действия по устранению неполадок. 

## <a name="collocate-clients-in-same-azure-region"></a>Совместное размещение клиентов в одном регионе Azure 
Минимальная возможная задержка достигается при размещении клиентского приложения в том же регионе Azure, в котором предоставляется конечная точка Azure Cosmos DB. Список доступных регионов см. в статье о [регионах Azure](https://azure.microsoft.com/global-infrastructure/regions/#services) .

## <a name="check-consistency-level"></a>Проверить уровень согласованности
[Уровень согласованности](consistency-levels.md) может повлиять на производительность и плату. Убедитесь, что уровень согласованности подходит для данного сценария. Дополнительные сведения см. в разделе [Выбор уровня согласованности](consistency-levels-choosing.md).

## <a name="log-the-executed-sql-query"></a>Запись в журнал выполненного запроса SQL 

Вы можете зарегистрировать выполненный SQL-запрос в учетной записи хранения или в таблице журнала диагностики. [Журналы запросов SQL с помощью журналов диагностики](monitor-cosmos-db.md#diagnostic-settings) позволяют регистрировать немаскированные запросы в учетной записи хранения по своему усмотрению. Это позволяет просмотреть журналы и найти запрос, который использует более высокий уровень RUs. Позже можно будет использовать идентификатор действия для сопоставления с фактическим запросом в Куерирунтиместатистикс. Запрос скрывается для целей безопасности и имен параметров запроса, а их значения в предложениях WHERE отличаются от фактических имен и значений. Вы можете использовать ведение журнала в учетной записи хранения для долгосрочного хранения выполненных запросов.  

## <a name="log-query-metrics"></a>Метрики запросов к журналу

Используйте `QueryMetrics` для устранения проблем с ресурсоемкими или дорогостоящими запросами. 

  * Задайте для `FeedOptions.PopulateQueryMetrics = true` `QueryMetrics` в ответе.
  * `QueryMetrics` класс имеет перегруженную функцию `.ToString()`, которую можно вызвать для получения строкового представления `QueryMetrics`. 
  * Метрики можно использовать для получения следующих аналитических сведений. 
  
      * Выполнялось ли ненормальное выполнение какого-либо конкретного компонента конвейера запросов (в порядке сотен или более миллисекунд). 

          * Взгляните на `TotalExecutionTime`.
          * Если `TotalExecutionTime` запроса меньше времени выполнения до конца, то время будет затрачено на стороне клиента или сети. Проверьте, что клиент и регион Azure выровнены по подразделу.
      
      * Было ли количество ложных срабатываний в проанализированных документах (если число выходных документов гораздо меньше, чем число извлеченных документов).  

          * Взгляните на `Index Utilization`.
          * `Index Utilization` = (число возвращенных документов/число загруженных документов)
          * Если число возвращаемых документов значительно меньше числа загруженных, то выполняется анализ ложных срабатываний.
          * Ограничьте число извлекаемых документов с помощью более узких фильтров.  

      * Как отдельные фаред циклов приема-передачи (см. `Partition Execution Timeline` из строкового представления `QueryMetrics`). 
      * Используется ли для запроса высокая стоимость запросов. 

Дополнительные сведения см. [в статье Получение метрик выполнения запросов SQL](profile-sql-api-query.md) .
      
## <a name="tune-query-feed-options-parameters"></a>Настройка параметров канала запроса 
Производительность запросов можно настроить с помощью [параметров канала](https://docs.microsoft.com/dotnet/api/microsoft.azure.documents.client.feedoptions?view=azure-dotnet). Попробуйте задать следующие параметры:

  * Сначала установите `MaxDegreeOfParallelism` в значение-1, а затем сравните производительность в разных значениях. 
  * Сначала установите `MaxBufferedItemCount` в значение-1, а затем сравните производительность в разных значениях. 
  * Установите `MaxItemCount` в значение-1.

При сравнении производительности при различных значениях используйте такие значения, как 2, 4, 8, 16 и т. д.
 
## <a name="read-all-results-from-continuations"></a>Считывание всех результатов из продолжений
Если вы считаете, что не получаете все результаты, полностью очистите маркер продолжения. Иными словами, продолжайте считывать результаты, пока в маркере продолжения остаются документы.

Полную очистку можно выполнить одним из следующих способов:

  * Продолжить обработку результатов, пока продолжение не пусто.
  * Продолжить обработку, пока запрос содержит больше результатов. 

    ```csharp
    // using AsDocumentQuery you get access to whether or not the query HasMoreResults
    // If it does, just call ExecuteNextAsync until there are no more results
    // No need to supply a continuation token here as the server keeps track of progress
    var query = client.CreateDocumentQuery<Family>(collectionLink, options).AsDocumentQuery();
    while (query.HasMoreResults)
    {
        foreach (Family family in await query.ExecuteNextAsync())
        {
            families.Add(family);
        }
    }
    ```

## <a name="choose-system-functions-that-utilize-index"></a>Выбор системных функций, использующих индекс
Если выражение может быть преобразовано в диапазон строковых значений, значит оно может использовать индекс. В противном случае у него нет такой возможности. 

Вот список строковых функций, которые могут использовать индекс: 
    
  * STARTSWITH(str_expr, str_expr); 
  * LEFT(str_expr, num_expr) = str_expr; 
  * SUBSTRING(str_expr, num_expr, num_expr) = str_expr, но только если значение first num_expr равно 0. 
    
    Ниже приведены примеры запросов. 
    
    ```sql

    -- If there is a range index on r.name, STARTSWITH will utilize the index while ENDSWITH won't 
    SELECT * 
    FROM c 
    WHERE STARTSWITH(c.name, 'J') AND ENDSWITH(c.name, 'n')

    ```
    
    ```sql

    -- LEFT will utilize the index while RIGHT won't 
    SELECT * 
    FROM c 
    WHERE LEFT(c.name, 2) = 'Jo' AND RIGHT(c.name, 2) = 'hn'

    ```

  * Избегайте системных функций в фильтре (или в предложении WHERE), которые не обрабатываются индексом. Некоторые примеры таких системных функций включают в себя, верхний и нижний.
  * По возможности запросы следует писать так, чтобы в них использовались фильтры для ключей секции.
  * Чтобы обеспечить выполнение запросов, избегайте вызова верхнего или нижнего уровня в фильтре. Вместо этого следует нормализовать регистр значений при вставке. Для каждого значения вставьте значение с требуемым Регистром или вставьте исходное значение и значение с нужным регистром. 

    Например,
    
    ```sql

    SELECT * FROM c WHERE UPPER(c.name) = "JOE"

    ```
    
    В этом случае сохраните "Джо" с прописными буквами или сохраните как "Joe" исходное значение и "Джо". 
    
    Если регистр данных JSON нормализован, запрос становится следующим:
    
    ```sql

    SELECT * FROM c WHERE c.name = "JOE"

    ```

    Второй запрос будет более производительным, так как он не требует выполнения преобразований для каждого из значений, чтобы сравнить значения с "Джо".

Дополнительные сведения о системных функциях см. в статье [системные функции](sql-query-system-functions.md) .

## <a name="check-indexing-policy"></a>Проверка политики индексации
Чтобы проверить, является ли текущая [политика индексирования](index-policy.md) оптимальной, сделайте следующее.

  * Убедитесь, что все пути JSON, используемые в запросах, включены в политику индексирования для ускорения операций чтения.
  * Пути исключения не используются в запросах для более производительных операций записи.

Дополнительные сведения см. [в статье Управление политикой индексирования](how-to-manage-indexing-policy.md) .

## <a name="spatial-data-check-ordering-of-points"></a>Пространственные данные: Проверка порядка точек
Точки внутри многоугольника должны указываться в порядке против часовой стрелки. Если точки указаны в порядке по часовой стрелке, то многоугольник представляет регион, расположенный снаружи от него.

## <a name="optimize-join-expressions"></a>Выражения оптимизации соединений
`JOIN` выражения могут расширяться в крупные перекрестные продукты. По возможности выполняйте запрос к меньшему области поиска с помощью более узких фильтров.

Вложенные запросы с несколькими значениями могут оптимизировать `JOIN` выражения путем принудительной отправки предикатов после каждого выражения SELECT-many, а не после всех перекрестных соединений в предложении `WHERE`. Подробный пример см. в статье [Оптимизация выражений соединений](https://docs.microsoft.com/azure/cosmos-db/sql-query-subquery#optimize-join-expressions) .

## <a name="optimize-order-by-expressions"></a>Оптимизировать выражения УПОРЯДОЧЕНия 
`ORDER BY` производительность запросов может снизиться, если поля являются разреженными или не включены в политику индексов.

  * Для разреженных полей, таких как время, сократите область поиска, насколько это возможно с помощью фильтров. 
  * Для `ORDER BY`одного свойства Включите свойство в политику индексов. 
  * Для нескольких выражений `ORDER BY` свойств Определите [составной индекс](https://docs.microsoft.com/azure/cosmos-db/index-policy#composite-indexes) для полей, которые сортируются.  

## <a name="many-large-documents-being-loaded-and-processed"></a>Много загружаемых и обрабатываемых больших документов
Время и ответы, необходимые для запроса, не только зависят от размера ответа, они также зависят от работы, выполненной конвейером обработки запросов. Время и RUs увеличиваются пропорционально объему работы, выполненной всем конвейером обработки запросов. Большая работа выполняется для больших документов, поэтому для загрузки и обработки больших документов требуется больше времени и RUs.

## <a name="low-provisioned-throughput"></a>Низкая пропускная способность
Убедитесь, что подготовленная пропускная способность может работать с рабочей нагрузкой. Увеличьте бюджет на ЕДИНИЦу в затронутых коллекциях.

## <a name="try-upgrading-to-the-latest-sdk-version"></a>Попробуйте выполнить обновление до последней версии пакета SDK
Чтобы определить последнюю версию пакета SDK, см. статью [Загрузка пакета SDK и заметки о выпуске](sql-api-sdk-dotnet.md) .

## <a name="next-steps"></a>Дополнительная информация
Дополнительные сведения см. в документах, посвященных измерениям для каждого запроса, получению статистики выполнения для настройки запросов и т. д.

* [Получение метрик выполнения SQL-запросов с помощью пакета SDK для .NET](profile-sql-api-query.md)
* [Настройка производительности запросов в Azure Cosmos DB](sql-api-sql-query-metrics.md)
* [Советы по повышению производительности при использовании пакета SDK для .NET](performance-tips.md)
