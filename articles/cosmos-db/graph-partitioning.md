---
title: Секционирование данных в API Gremlin для Azure Cosmos DB | Документация Майкрософт
description: Узнайте, как в Azure Cosmos DB можно использовать секционированный граф. В этой статье также описываются требования и рекомендации для секционированного графа.
author: luisbosquez
ms.author: lbosq
ms.service: cosmos-db
ms.subservice: cosmosdb-graph
ms.topic: conceptual
ms.date: 12/06/2018
ms.custom: seodec18
ms.openlocfilehash: f1e486a302b440d819e15ef86f8d76ea5e50d201
ms.sourcegitcommit: 8330a262abaddaafd4acb04016b68486fba5835b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2019
ms.locfileid: "54036330"
---
# <a name="using-a-partitioned-graph-in-azure-cosmos-db"></a>Использование секционированного графа в Azure Cosmos DB

Одной из ключевых функций API Gremlin в Azure Cosmos DB является способность обрабатывать крупномасштабные графы с помощью горизонтального масштабирования. Горизонтального масштабирования можно достичь с помощью [возможностей секционирования в Azure Cosmos DB](partition-data.md). С точки зрения хранилища и пропускной способности контейнеры можно масштабировать независимо друг от друга. В Azure Cosmos DB можно создавать контейнеры, которые можно автоматически масштабировать, чтобы хранить данные графа. Данные автоматически балансируются на основе указанного **ключа секции**.

В этом документе описаны особенности секционирования базы данных графов, а также его влияние на вершины (или узлы) и ребра.

## <a name="requirements-for-partitioned-graph"></a>Требования к секционированному графу

Ниже приведены сведения, которые нужно учитывать при создании контейнера секционированного графа.

- **Секционирование необходимо**, если контейнер будет хранить больше чем 10 ГБ или если необходимо выделить более чем 10 000 единиц запросов в секунду (ЕЗ).

- **Вершины и ребра хранятся в виде документов JSON**.

- **Для вершин требуется ключ секции**. Этот ключ определяет, в какой секции будет храниться вершина, с использованием алгоритма хэширования. Имя этого ключа секции будет строкой из одного слова без пробелов и специальных символов. При создании нового контейнера определяется ключ секции и его формат будет: `/partitioning-key-name`.

- **Ребра будут храниться вместе с их исходной вершиной**. Другими словами, для каждой вершины ключ секции определяет их место хранения вместе с ее исходящими ребрами. Это делается во избежание межсекционных запросов при использовании кратности `out()` в запросах графа.

- **В запросах графа необходимо задавать ключ секции**. Чтобы воспользоваться всеми преимуществами горизонтального секционирования в Azure Cosmos DB, ключ секции необходимо по возможности указывать всякий раз, когда выбирается одна вершина. Ниже приведены запросы для выбора одной или нескольких вершин в секционированном графе:

    - `/id` и `/label` не поддерживаются в качестве ключей секции для контейнера в API Gremlin.


    - Выбор вершины по идентификатору, затем **использование шага `.has()` для указания свойства ключа секции**: 
    
        ```
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - Выбор вершины путем **указания кортежа, включая значение ключа секции и идентификатор**: 
    
        ```
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - Указание **массива кортежей значений ключей секций и идентификаторов**:
    
        ```
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - Выбор набора вершин и **определение списка значений ключей секций**: 
    
        ```
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

## <a name="best-practices-when-using-a-partitioned-graph"></a>Рекомендации при использовании секционированного графа

Следуйте приведенным ниже рекомендациям, чтобы обеспечить производительность и масштабируемость при использовании секционированных графов с контейнерами с неограниченным хранилищем.

- **Всегда указывайте значение ключа секции при запросе вершины**. Чтобы получить возможность повысить производительность, получите вершины из известной секции.

- **По возможности используйте исходящее направление при запросе ребер**. Как упоминалось выше, ребра хранятся с их исходными вершинами в исходящем направлении. Поэтому, вероятность повторной сортировки межсекционных запросов сведена к минимуму, когда данные и запросы разработаны с ориентацией на этот шаблон.

- **Выберите ключ секции, который равномерно распределяет данные по секциям**. Это решение сильно зависит от модели данных решения. Дополнительные сведения о создании соответствующего ключа секции см. в статье [Секционирование и масштабирование в Azure Cosmos DB](partition-data.md).

- **Оптимизируйте запросы для получения данных в пределах секции**. Оптимальной стратегией секционирования является согласование с шаблонами запросов. Запросы для получения данных из одной секции обеспечивают наилучшую производительность.

## <a name="next-steps"></a>Дополнительная информация

Затем можно ознакомиться со следующими статьями:

* Дополнительные сведения о [секционировании и масштабировании в Azure Cosmos DB](partition-data.md).
* Дополнительные сведения о [поддержке Gremlin в API Gremlin](gremlin-support.md).
* [Общие сведения об API Gremlin](graph-introduction.md).
