---
title: Секционирование в Azure Cosmos DB API Cassandra
description: Дополнительные сведения о секционировании в Azure Cosmos DB API Cassandra
author: TheovanKraay
ms.author: thvankra
ms.service: cosmos-db
ms.subservice: cosmosdb-cassandra
ms.topic: conceptual
ms.date: 05/20/2020
ms.openlocfilehash: 5f159ffcea0aa88f354ae503be96a5c571c10adb
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2020
ms.locfileid: "85806838"
---
# <a name="partitioning-in-azure-cosmos-db-cassandra-api"></a>Секционирование в Azure Cosmos DB API Cassandra

В этой статье описано, как работает секционирование в Azure Cosmos DB API Cassandra. 

API Cassandra использует секционирование для масштабирования отдельных таблиц в пространства ключей в соответствии с потребностями производительности приложения. Секции формируются на основе значения ключа секции, связанного с каждой записью в таблице. Все записи в секции имеют одинаковое значение ключа секции. Azure Cosmos DB прозрачно и автоматически управляет размещением секций по физическим ресурсам для эффективного удовлетворения требований к масштабируемости и производительности таблицы. По мере увеличения требований к пропускной способности и хранению приложения Azure Cosmos DB перемещает и распределяет данные между большим числом физических компьютеров.

С точки зрения разработчика секционирование ведет себя так же, как Azure Cosmos DB API Cassandra, как это делается в машинном [Cassandraе Apache](https://cassandra.apache.org/). Однако в этом случае существуют некоторые различия. 


## <a name="differences-between-apache-cassandra-and-azure-cosmos-db"></a>Различия между Apache Cassandra и Azure Cosmos DB

В Azure Cosmos DB каждая машина, на которой хранятся разделы, сама по себе называется [физической секцией](partition-data.md#physical-partitions). Физическая Секция — это аналог виртуальной машины; Выделенная единица вычислений или набор физических ресурсов. Каждая секция, хранящаяся в этой единице вычислений, называется [логической секцией](partition-data.md#logical-partitions) в Azure Cosmos DB. Если вы уже знакомы с Apache Cassandra, логические секции можно рассматривать так же, как и обычные секции в Cassandra. 

Apache Cassandra рекомендует ограничение в 100 МБ на размер данных, которые могут храниться в секции. API Cassandra для Azure Cosmos DB допускает до 20 ГБ на логический раздел и до 30 ГБ данных на физическую секцию. В Azure Cosmos DB, в отличие от Apache Cassandra, объем вычислений, доступный в физической секции, выражается с помощью одной метрики [единиц запросов](request-units.md), которая позволяет представить рабочую нагрузку в виде запросов (операций чтения или записи) в секунду, а не ядер, памяти или операций ввода-вывода. Это может привести к более прямолинейному планированию ресурсов, если вы понимаете стоимость каждого запроса. Каждый физический раздел может иметь до 10000. Дополнительные сведения о параметрах масштабируемости см. в статье о [гибком масштабировании](manage-scale-cassandra.md) в API Cassandra. 

В Azure Cosmos DB каждая физическая Секция состоит из набора реплик, также известных как наборы реплик, по крайней мере 4 реплики на секцию. Это отличается от Apache Cassandra, где возможна настройка коэффициента репликации, равная 1. Однако это приводит к низкому доступу, если единственный узел с данными выходит из строя. В API Cassandra всегда существует коэффициент репликации 4 (кворум из 3). Azure Cosmos DB автоматически управляет наборами реплик, хотя эти наборы необходимо поддерживать с помощью различных средств в Apache Cassandra. 

Apache Cassandra имеет концепцию токенов, которые являются хэшированными ключами секций. Токены основываются на murmur3 байте 64 со значениями от-2 ^ 63 до-2 ^ 63-1. Этот диапазон обычно называется "Token Ring" в Apache Cassandra. Token Ring распространяется на диапазоны маркеров, и эти диапазоны делятся между узлами, присутствующими в собственном кластере Apache Cassandra. Секционирование для Azure Cosmos DB реализуется аналогичным образом, за исключением того, что использует другой хэш-алгоритм и имеет больший круг. 


## <a name="primary-key"></a>Первичный ключ

Все таблицы в API Cassandra должны иметь `primary key` определенные. Ниже приведен синтаксис для первичного ключа.

```shell
column_name cql_type_definition PRIMARY KEY
```

Предположим, мы хотим создать пользовательскую таблицу, в которой хранятся сообщения для разных пользователей:

```shell
CREATE TABLE uprofile.user ( 
   id UUID PRIMARY KEY, 
   user text,  
   message text);
```

В этом проекте мы определили `id` поле как первичный ключ. Первичный ключ функционирует как идентификатор для записи в таблице, а также используется в качестве ключа секции в Azure Cosmos DB. Если первичный ключ определен ранее описанным способом, в каждой секции будет только одна запись. Это приведет к идеальному горизонтальному и масштабируемому распределению при записи данных в базу данных и идеально подходит для вариантов использования при поиске по значению ключа. Приложение должно предоставлять первичный ключ при считывании данных из таблицы для повышения производительности чтения. 

:::image type="content" source="./media/cassandra-partitioning/cassandra-partitioning.png" alt-text="Partition" border="false":::


## <a name="compound-primary-key"></a>Составной первичный ключ

Apache Cassandra также имеет концепцию `compound keys` . Составная `primary key` часть состоит из более чем одного столбца; первый столбец — `partition key` , а все дополнительные столбцы — `clustering keys` . Синтаксис для `compound primary key` показан ниже.

```shell
PRIMARY KEY (partition_key_column_name, clustering_column_name [, ...])
```

Предположим, мы хотим изменить приведенную выше структуру и обеспечить возможность эффективного извлечения сообщений для определенного пользователя:

```shell
CREATE TABLE uprofile.user (
   user text,  
   id int, 
   message text, 
   PRIMARY KEY (user, id));
```

В этом проекте теперь мы определяем в `user` качестве ключа секции, а в `id` качестве ключа кластеризации. Можно определить столько ключей кластеризации, сколько нужно, но каждое значение (или сочетание значений) для ключа кластеризации должно быть уникальным, чтобы в результате добавить несколько записей в одну секцию, например:

```shell
insert into uprofile.user (user, id, message) values ('theo', 1, 'hello');
insert into uprofile.user (user, id, message) values ('theo', 2, 'hello again');
```

При возвращении данных они сортируются по ключу кластеризации, как ожидалось в Apache Cassandra:

:::image type="content" source="./media/cassandra-partitioning/select-from-pk.png" alt-text="Partition":::

При использовании данных, смоделированных таким образом, каждой секции можно назначить несколько записей, сгруппированных по пользователям. Таким способом можно выдать запрос, который эффективно направляется `partition key` (в данном случае), `user` чтобы получить все сообщения для данного пользователя. 

:::image type="content" source="./media/cassandra-partitioning/cassandra-partitioning2.png" alt-text="Partition" border="false":::


## <a name="composite-partition-key"></a>Составной ключ секции

Составные ключи секции работают по сути так же, как и составные ключи, за исключением того, что можно указать несколько столбцов в качестве составного ключа секции. Синтаксис составных ключей секционирования показан ниже:

```shell
PRIMARY KEY (
   (partition_key_column_name[, ...]), 
    clustering_column_name [, ...]);
```
Например, можно использовать следующий код, где уникальное сочетание `firstname` и `lastname` будет формировать ключ секции, а `id` — ключ кластеризации:

```shell
CREATE TABLE uprofile.user ( 
   firstname text, 
   lastname text,
   id int,  
   message text, 
   PRIMARY KEY ((firstname, lastname), id) );
```

## <a name="next-steps"></a>Дальнейшие шаги

* Дополнительные сведения о [секционировании и горизонтальном масштабировании в Azure Cosmos DB](partition-data.md).
* Дополнительные сведения о [подготовленной пропускной способности в Azure Cosmos DB](request-units.md).
* Сведения о [глобальном распределении в Azure Cosmos DB](distribute-data-globally.md).
