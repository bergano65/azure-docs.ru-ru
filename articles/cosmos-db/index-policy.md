---
title: Политики индексирования в Azure Cosmos DB
description: Узнайте, как настроить и изменить политику индексирования по умолчанию для автоматического индексирования и повышения производительности в Azure Cosmos DB.
author: ThomasWeiss
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 09/10/2019
ms.author: thweiss
ms.openlocfilehash: 886d17098259ddbb78698a3c1280f797e370c714
ms.sourcegitcommit: b4f201a633775fee96c7e13e176946f6e0e5dd85
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2019
ms.locfileid: "72597159"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Политики индексирования в Azure Cosmos DB

В Azure Cosmos DB каждый контейнер имеет политику индексирования, определяющую, как должны индексироваться элементы контейнера. Политика индексирования по умолчанию для вновь создаваемых контейнеров индексирует все свойства каждого элемента, принудительно заменяя индексы диапазона для любой строки или числа, а также пространственные индексы для любого объекта геообъектного формата JSON типа Point. Это позволяет получить высокую производительность запросов без необходимости думать об индексировании и управлении индексами.

В некоторых ситуациях может потребоваться переопределить это автоматическое поведение, чтобы лучше соответствовать вашим требованиям. Политику индексирования контейнера можно настроить, задав ее *режим индексирования*, а также включить или исключить *пути к свойствам*.

> [!NOTE]
> Метод обновления политик индексации, описанный в этой статье, применим только к API-интерфейсу SQL (Core) Azure Cosmos DB.

## <a name="indexing-mode"></a>Режим индексирования

Azure Cosmos DB поддерживает два режима индексирования:

- **Целостность**. индекс обновляется синхронно по мере создания, обновления или удаления элементов. Это означает, что согласованность запросов чтения будет согласована, [настроенной для учетной записи](consistency-levels.md).
- **Нет**: индексирование в контейнере отключено. Это часто используется, когда контейнер используется в качестве чистого хранилища значений ключа без необходимости в вторичных индексах. Его также можно использовать для повышения производительности операций с массовыми операциями. После выполнения операций с массовыми операциями в режиме индексирования можно задать значение consistent, а затем отслеживать его с помощью [IndexTransformationProgress](how-to-manage-indexing-policy.md#use-the-net-sdk-v2) до завершения.

> [!NOTE]
> Cosmos DB также поддерживает режим отложенной индексации. Отложенное индексирование выполняет обновления индекса с более низким уровнем приоритета, когда обработчик не выполняет никаких других действий. Это может привести к **несоответствиям или неполным** результатам запроса. Кроме того, использование отложенного индексирования вместо "None" для выполнения операций с массовыми операциями не дает никаких преимуществ, так как любое изменение в режиме индекса приведет к удалению и повторному созданию индекса. По этим причинам мы советуем использовать их для клиентов. Чтобы повысить производительность для выполнения операций с массовыми операциями, установите для режима индекса значение None, а затем вернитесь в режим consistent и отслеживайте свойство `IndexTransformationProgress` контейнера до завершения.

По умолчанию для политики индексирования задано значение `automatic`. Это достигается путем задания для свойства `automatic` в политике индексирования значения `true`. Присвоение этому свойству значения `true` позволяет Azure CosmosDB автоматически индексировать документы по мере их написания.

## <a name="including-and-excluding-property-paths"></a>Включение и исключение путей к свойствам

Пользовательская политика индексации может указывать пути к свойствам, которые явно включены или исключены из индексирования. Оптимизируя Количество индексируемых путей, можно уменьшить объем хранилища, используемого контейнером, и увеличить задержку операций записи. Эти пути определяются [методом, описанным в разделе Обзор индексирования](index-overview.md#from-trees-to-property-paths) со следующими дополнениями.

- путь, ведущий к скалярному значению (строке или номеру), заканчивается на `/?`
- элементы из массива обрабатываются совместно с помощью `/[]` нотации (а не `/0` `/1` и т. д.).
- подстановочный знак `/*` можно использовать для сопоставления с любыми элементами, расположенными под узлом

Снова выполнив тот же пример:

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- путь к `employees`у `headquarters` `/headquarters/employees/?`

- путь `locations` "`country` `/locations/[]/country/?`

- путь к любому элементу в разделе `headquarters` `/headquarters/*`

Например, можно включить путь `/headquarters/employees/?`. Этот путь обеспечит индексирование свойства Employees, но не будет индексировать дополнительный вложенный код JSON в этом свойстве.

## <a name="includeexclude-strategy"></a>Стратегия включения и исключения

Любая политика индексации должна включать корневой путь `/*` как либо включенный, либо Исключенный путь.

- Включите корневой путь для выборочного исключения путей, которые не нужно индексировать. Это рекомендуемый подход, так как он позволяет Azure Cosmos DB заранее индексировать любое новое свойство, которое может быть добавлено в модель.
- Исключите корневой путь для выборочного включения путей, которые необходимо проиндексировать.

- Для путей с обычными символами, включающими буквенно-цифровые символы и символ _ (подчеркивание), не нужно заключать строку пути вокруг двойных кавычек (например, "/Пас/?"). Для путей с другими специальными символами необходимо экранировать строку пути, заключенную в двойные кавычки (например, "/\"path-ABC \"/?"). Если в пути предполагается наличие специальных символов, можно избежать последовательного переключения всех путей в целях безопасности. Функционально, это не имеет никакой разницы при экранировании всех путей и только тех, которые имеют специальные символы.

- Системное свойство "ETag" исключается из индексирования по умолчанию, если только ETag не добавлен в включаемый путь для индексирования.

При включении и исключении путей можно столкнуться со следующими атрибутами:

- `kind` может иметь значение `range` или `hash`. Функция индекса диапазона предоставляет все функции хэш-индекса, поэтому мы рекомендуем использовать индекс диапазона.

- `precision` — это число, определенное на уровне индекса для включенных путей. Значение `-1` указывает на максимальную точность. Рекомендуется всегда устанавливать это значение в `-1`.

- `dataType` может иметь значение `String` или `Number`. Указывает типы свойств JSON, которые будут индексироваться.

Если этот параметр не указан, эти свойства будут иметь следующие значения по умолчанию:

| **Имя свойства**     | **Значение по умолчанию** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` и `Number` |

В [этом разделе](how-to-manage-indexing-policy.md#indexing-policy-examples) приведены примеры политик индексации для включения и исключения путей.

## <a name="spatial-indexes"></a>Пространственные индексы

При определении пространственного пути в политике индексирования необходимо определить, какой индекс ```type``` должен применяться к этому пути. К пространственным индексам могут относиться следующие типы:

* Точка

* Polygon.

* MultiPolygon;

* LineString;

По умолчанию Azure Cosmos DB не создает пространственные индексы. Если вы хотите использовать встроенные функции пространственного SQL, необходимо создать пространственный индекс для обязательных свойств. В [этом разделе](geospatial.md) приведены примеры политик индексации для добавления пространственных индексов.

## <a name="composite-indexes"></a>Составные индексы

Для запросов с предложением `ORDER BY` с двумя или более свойствами требуется составной индекс. Кроме того, можно определить составной индекс, чтобы повысить производительность многих запросов на равенство и диапазонов. По умолчанию составные индексы не определяются, поэтому при необходимости следует [добавлять составные индексы](how-to-manage-indexing-policy.md#composite-indexing-policy-examples) .

При определении составного индекса необходимо указать:

- Два или более пути свойств. Последовательность, в которой определяются пути к свойствам, имеет значение.

- Порядок (по возрастанию или по убыванию).

> [!NOTE]
> При добавлении составного индекса запрос будет использовать существующие индексы диапазона до завершения добавления нового составного индекса. Таким образом, при добавлении составного индекса вы можете не сразу приступить к улучшению производительности. Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

### <a name="order-by-queries-on-multiple-properties"></a>УПОРЯДОЧИТЬ по запросам для нескольких свойств:

Следующие рекомендации используются при использовании составных индексов для запросов с предложением `ORDER BY` с двумя или более свойствами:

- Если пути составного индекса не соответствуют последовательности свойств в предложении `ORDER BY`, составной индекс не поддерживает этот запрос.

- Порядок составных путей индекса (по возрастанию или по убыванию) должен также соответствовать `order` в предложении `ORDER BY`.

- Составной индекс также поддерживает предложение `ORDER BY` с противоположным порядком по всем путям.

Рассмотрим следующий пример, где составной индекс определяется для свойств Name, Age и _TS:

| **Составной индекс**     | **Пример запроса `ORDER BY`**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

Необходимо настроить политику индексирования, чтобы можно было обслуживать все необходимые `ORDER BY` запросы.

### <a name="queries-with-filters-on-multiple-properties"></a>запросы с фильтрами по нескольким свойствам.

Если запрос имеет фильтры по двум или более свойствам, может оказаться полезным создать составной индекс для этих свойств.

Например, рассмотрим следующий запрос, имеющий фильтр проверки на равенство двух свойств:

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age = 18
```

Этот запрос будет более эффективным, что займет меньше времени и потребляет меньше единиц запросов, если он способен использовать составной индекс в (Name ASC, Age ASC).

Запросы с фильтрами диапазонов также можно оптимизировать с помощью составного индекса. Однако запрос может иметь только один фильтр диапазона. Фильтры диапазонов включают `>`, `<`, `<=`, `>=` и `!=`. Фильтр диапазона должен быть определен последним в составном индексе.

Рассмотрим следующий запрос с фильтрами равенства и диапазона.

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age > 18
```

Этот запрос будет более эффективным с составным индексом в (Name ASC, Age ASC). Однако запрос не будет использовать составной индекс в (Age ASC, Name ASC), так как фильтры равенства должны быть определены первыми в составном индексе.

При создании составных индексов для запросов с фильтрами для нескольких свойств используются следующие рекомендации.

- Свойства в фильтре запроса должны соответствовать значениям в составном индексе. Если свойство находится в составном индексе, но не включено в запрос в качестве фильтра, то запрос не будет использовать составной индекс.
- Если запрос содержит дополнительные свойства в фильтре, которые не были определены в составном индексе, то для оценки запроса будет использоваться сочетание составного индекса и индекса диапазона. Для этого потребуется меньше единиц запросов, чем при использовании индексов диапазона.
- Если свойство имеет фильтр диапазона (`>`, `<`, `<=`, `>=` или `!=`), то это свойство должно быть определено последним в составном индексе. Если запрос содержит более одного фильтра диапазона, он не будет использовать составной индекс.
- При создании составного индекса для оптимизации запросов с несколькими фильтрами `ORDER` составного индекса не будет влиять на результаты. Это необязательное свойство.
- Если не определить составной индекс для запроса с фильтрами по нескольким свойствам, запрос будет выполняться с ошибкой. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса.

Рассмотрим следующие примеры, где составной индекс определяется по имени, возрасту и метке свойства.

| **Составной индекс**     | **Образец запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |

### <a name="queries-with-a-filter-as-well-as-an-order-by-clause"></a>запросы с фильтром, а также с предложением ORDER BY;

Если запрос фильтрует одно или несколько свойств и имеет различные свойства в предложении ORDER BY, может быть полезно добавить свойства в фильтре в предложение `ORDER BY`.

Например, добавив свойства в фильтре в предложение ORDER BY, можно переписывать следующий запрос, чтобы использовать составной индекс:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.name, c.timestamp
```

Те же оптимизации шаблонов и запросов можно обобщить для запросов с несколькими фильтрами равенства:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.name, c.age, c.timestamp
```

Следующие рекомендации используются при создании составных индексов для оптимизации запроса с помощью предложения Filter и `ORDER BY`.

* Если запрос фильтрует свойства, они должны быть включены первыми в предложение `ORDER BY`.
* Если не определить составной индекс для запроса с фильтром для одного свойства и отдельным предложением `ORDER BY` с другим свойством, запрос будет выполняться. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса, особенно если свойство в предложении `ORDER BY` имеет большую кратность.
* Все рекомендации по созданию составных индексов для запросов `ORDER BY` с несколькими свойствами, а также с запросами с фильтрами по нескольким свойствам по-прежнему применяются.


| **Составной индекс**                      | **Пример запроса `ORDER BY`**                                  | **Поддерживается составным индексом?** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="modifying-the-indexing-policy"></a>Изменение политики индексирования

Политику индексирования контейнера можно обновить в любое время с [помощью портал Azure или одного из поддерживаемых пакетов SDK](how-to-manage-indexing-policy.md). Обновление политики индексирования активирует преобразование старого индекса в новый, который выполняется в сети и на месте (поэтому дополнительное пространство для хранения данных во время операции не потребляется). Индекс старой политики эффективно преобразуется в новую политику, не влияя на доступность записи или пропускную способность, подготовленную в контейнере. Преобразование индекса — это асинхронная операция, а время, необходимое для выполнения, зависит от подготовленной пропускной способности, количества элементов и их размера.

> [!NOTE]
> При добавлении диапазона или пространственного индекса запросы могут не возвращать все совпадающие результаты и выполнять это действие без возврата ошибок. Это означает, что результаты запроса могут быть непостоянными до завершения преобразования индекса. Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

Если для новой политики индексирования задан режим "целостный", другие изменения политики индексирования не могут быть применены во время преобразования индекса. Чтобы отменить выполнение преобразования индекса, можно задать для параметра режим политики индексирования значение нет (что приведет к немедленному удалению индекса).

## <a name="indexing-policies-and-ttl"></a>Политики индексирования и TTL

Для [функции срока жизни (TTL)](time-to-live.md) необходимо, чтобы индексация была активной в контейнере, в котором он включен. Это означает следующее:

- невозможно активировать TTL для контейнера, в котором для режима индексирования задано значение None,
- невозможно задать для режима индексирования значение None в контейнере, где активирован TTL.

В сценариях, где не требуется индексировать свойство, но требуется TTL, можно использовать политику индексации с:

- режим индексирования установлен в значение consistent, а
- Нет добавленных путей и
- `/*` только как исключаемый путь.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании см. по следующим ссылкам:

- [Общие сведения об индексировании](index-overview.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
