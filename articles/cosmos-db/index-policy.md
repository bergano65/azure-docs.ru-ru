---
title: Политики индексирования в Azure Cosmos DB
description: Узнайте, как настроить и изменить политику индексирования по умолчанию для автоматического индексирования и повышения производительности в Azure Cosmos DB.
author: timsander1
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 08/11/2020
ms.author: tisande
ms.openlocfilehash: e1254b31bffa72918b46c550e8354bd1c2195dfb
ms.sourcegitcommit: 2ffa5bae1545c660d6f3b62f31c4efa69c1e957f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2020
ms.locfileid: "88077600"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Indexing policy in Azure Cosmos DB (Политики индексации в Azure Cosmos DB)

В Azure Cosmos DB каждый контейнер имеет политику индексирования, определяющую, как должны индексироваться элементы контейнера. Политика индексирования по умолчанию для вновь создаваемых контейнеров индексирует все свойства каждого элемента и применяет индексы диапазона для любой строки или числа. Это позволяет получить высокую производительность запросов без необходимости думать об индексировании и управлении индексами.

В некоторых ситуациях полезно переопределить автоматическое поведение в соответствии с конкретными требованиями. Политику индексирования контейнера можно настроить, задав ее *режим индексирования*, а также включить или исключить *пути к свойствам*.

> [!NOTE]
> Метод обновления политик индексации, описанный в этой статье, применим только к API-интерфейсу SQL (Core) Azure Cosmos DB. Дополнительные сведения об индексировании в [API Azure Cosmos DB для MongoDB](mongodb-indexing.md)

## <a name="indexing-mode"></a>Режим индексирования

Azure Cosmos DB поддерживает два режима индексирования:

- **Целостность**. индекс обновляется синхронно по мере создания, обновления или удаления элементов. Это означает, что согласованность запросов чтения будет согласована, [настроенной для учетной записи](consistency-levels.md).
- **Нет**: индексирование в контейнере отключено. Это часто используется, когда контейнер используется в качестве чистого хранилища значений ключа без необходимости в вторичных индексах. Его также можно использовать для повышения производительности операций с массовыми операциями. После выполнения операций с массовыми операциями в режиме индексирования можно задать значение consistent, а затем отслеживать его с помощью [IndexTransformationProgress](how-to-manage-indexing-policy.md#dotnet-sdk) до завершения.

> [!NOTE]
> Azure Cosmos DB также поддерживает режим отложенной индексации. Отложенное индексирование выполняет обновления индекса с более низким уровнем приоритета, когда обработчик не выполняет никаких других действий. Это может привести к **несоответствиям или неполным** результатам запроса. Если вы планируете запрашивать Cosmos-контейнер, не выбирайте Отложенное индексирование. В июне 2020 мы предоставили изменение, которое больше не позволяет установить для новых контейнеров режим отложенной индексации. Если учетная запись Azure Cosmos DB уже содержит хотя бы один контейнер с отложенным индексированием, эта учетная запись автоматически исключается из изменений. Вы также можете запросить исключение, обратившись в [службу поддержки Azure](https://portal.azure.com/?#blade/Microsoft_Azure_Support/HelpAndSupportBlade).

По умолчанию для политики индексирования задано значение `automatic` . Это достигается путем задания `automatic` свойству в политике индексирования значения `true` . Задание этого свойства `true` позволяет Azure CosmosDB автоматически индексировать документы по мере их написания.

## <a name="including-and-excluding-property-paths"></a><a id="include-exclude-paths"></a>Включение и исключение путей к свойствам

Пользовательская политика индексации может указывать пути к свойствам, которые явно включены или исключены из индексирования. Оптимизируя Количество индексируемых путей, можно значительно сократить задержку и ЕДИНИЦу оплаты операций записи. Эти пути определяются [методом, описанным в разделе Обзор индексирования](index-overview.md#from-trees-to-property-paths) со следующими дополнениями.

- путь, ведущий к скалярному значению (строке или номеру), заканчивается на`/?`
- элементы из массива обрабатываются вместе с помощью `/[]` нотации (а не и `/0` `/1` т. д.).
- `/*`подстановочный знак можно использовать для сопоставления с любыми элементами, расположенными под узлом

Снова выполнив тот же пример:

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- `headquarters` `employees` путь:`/headquarters/employees/?`

- `locations` `country` путь`/locations/[]/country/?`

- путь к любому элементу `headquarters` в разделе`/headquarters/*`

Например, можно включить `/headquarters/employees/?` путь. Этот путь обеспечит индексирование свойства Employees, но не будет индексировать дополнительный вложенный код JSON в этом свойстве.

## <a name="includeexclude-strategy"></a>Стратегия включения и исключения

Любая политика индексации должна включать корневой путь `/*` как либо включенный, либо Исключенный путь.

- Включите корневой путь для выборочного исключения путей, которые не нужно индексировать. Это рекомендуемый подход, так как он позволяет Azure Cosmos DB заранее индексировать любое новое свойство, которое может быть добавлено в модель.
- Исключите корневой путь для выборочного включения путей, которые необходимо проиндексировать.

- Для путей с обычными символами, включающими буквенно-цифровые символы и символ _ (подчеркивание), не нужно заключать строку пути вокруг двойных кавычек (например, "/Пас/?"). Для путей с другими специальными символами необходимо экранировать строку пути, заключенную в двойные кавычки (например, "/ \" path-ABC \" /?"). Если в пути предполагается наличие специальных символов, можно избежать последовательного переключения всех путей в целях безопасности. Функционально, это не имеет никакой разницы при экранировании всех путей и только тех, которые имеют специальные символы.

- По `_etag` умолчанию свойство System исключено из индексирования, если только ETag не добавлен в включаемый путь для индексирования.

- Если режим индексирования установлен в значение **consistent**, системные свойства `id` и `_ts` будут автоматически индексироваться.

При включении и исключении путей можно столкнуться со следующими атрибутами:

- `kind`может иметь значение `range` или `hash` . Функция индекса диапазона предоставляет все функции хэш-индекса, поэтому мы рекомендуем использовать индекс диапазона.

- `precision`число, определенное на уровне индекса для включенных путей. Значение указывает на `-1` максимальную точность. Рекомендуется всегда задавать для этого параметра значение `-1` .

- `dataType`может иметь значение `String` или `Number` . Указывает типы свойств JSON, которые будут индексироваться.

Если этот параметр не указан, эти свойства будут иметь следующие значения по умолчанию:

| **Имя свойства**     | **Значение по умолчанию** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` и `Number` |

В [этом разделе](how-to-manage-indexing-policy.md#indexing-policy-examples) приведены примеры политик индексации для включения и исключения путей.

## <a name="includeexclude-precedence"></a>Приоритет включения или исключения

Если включенные пути и исключенные пути конфликтуют, приоритет имеет более точный путь.

Ниже приведен пример:

**Включаемый путь**:`/food/ingredients/nutrition/*`

**Исключенный путь**:`/food/ingredients/*`

В этом случае включенный путь имеет приоритет над исключенным путем, так как он более точен. На основе этих путей все данные в `food/ingredients` пути или вложенные в них будут исключены из индекса. Исключением могут быть данные внутри включаемого пути: `/food/ingredients/nutrition/*` , который будет индексироваться.

Ниже приведены некоторые правила для приоритета включенных и исключаемых путей в Azure Cosmos DB.

- Более глубокие пути более точны, чем более узкие пути. Например: `/a/b/?` более точно, чем `/a/?` .

- `/?`Более точнее, чем `/*` . Например `/a/?` , более точнее `/a/*` , чем так, `/a/?` имеет приоритет.

- Путь `/*` должен содержать либо включенный путь, либо Исключенный путь.

## <a name="spatial-indexes"></a>Пространственные индексы

При определении пространственного пути в политике индексации необходимо определить, какой индекс ```type``` следует применить к этому пути. К пространственным индексам могут относиться следующие типы:

* Точка

* Polygon

* MultiPolygon

* LineString

По умолчанию Azure Cosmos DB не создает пространственные индексы. Если вы хотите использовать встроенные функции пространственного SQL, необходимо создать пространственный индекс для обязательных свойств. В [этом разделе](sql-query-geospatial-index.md) приведены примеры политик индексации для добавления пространственных индексов.

## <a name="composite-indexes"></a>Составные индексы

Для запросов, имеющих `ORDER BY` предложение с двумя или более свойствами, требуется составной индекс. Кроме того, можно определить составной индекс, чтобы повысить производительность многих запросов на равенство и диапазонов. По умолчанию составные индексы не определяются, поэтому при необходимости следует [добавлять составные индексы](how-to-manage-indexing-policy.md#composite-indexing-policy-examples) .

В отличие от включенных или исключенных путей, нельзя создать путь с `/*` подстановочным знаком. Каждый составной путь имеет неявную `/?` в конце пути, который не нужно указывать. Составные пути ведут к скалярному значению, и это единственное значение, включенное в составной индекс.

При определении составного индекса необходимо указать:

- Два или более пути свойств. Последовательность, в которой определяются пути к свойствам, имеет значение.

- Порядок (по возрастанию или по убыванию).

> [!NOTE]
> При добавлении составного индекса запрос будет использовать существующие индексы диапазона до завершения добавления нового составного индекса. Таким образом, при добавлении составного индекса вы можете не сразу приступить к улучшению производительности. Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

### <a name="order-by-queries-on-multiple-properties"></a>УПОРЯДОЧИТЬ по запросам для нескольких свойств:

Следующие рекомендации используются при использовании составных индексов для запросов с `ORDER BY` предложением с двумя или более свойствами:

- Если пути составного индекса не соответствуют последовательности свойств в `ORDER BY` предложении, составной индекс не поддерживает запрос.

- Порядок составных путей индексов (по возрастанию или по убыванию) должен также совпадать с параметром `order` в `ORDER BY` предложении.

- Составной индекс также поддерживает `ORDER BY` предложение с противоположным порядком для всех путей.

Рассмотрим следующий пример, где составной индекс определяется для свойств Name, Age и _ts.

| **Составной индекс**     | **Образец `ORDER BY` запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

Необходимо настроить политику индексирования, чтобы можно было обслуживать все необходимые `ORDER BY` запросы.

### <a name="queries-with-filters-on-multiple-properties"></a>запросы с фильтрами по нескольким свойствам.

Если запрос имеет фильтры по двум или более свойствам, может оказаться полезным создать составной индекс для этих свойств.

Например, рассмотрим следующий запрос, имеющий фильтр проверки на равенство двух свойств:

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age = 18
```

Этот запрос будет более эффективным, что займет меньше времени и потребляет меньше единиц запросов, если он способен использовать составной индекс в (Name ASC, Age ASC).

Запросы с фильтрами диапазонов также можно оптимизировать с помощью составного индекса. Однако запрос может иметь только один фильтр диапазона. Фильтры диапазонов включают `>` , `<` ,, `<=` `>=` и `!=` . Фильтр диапазона должен быть определен последним в составном индексе.

Рассмотрим следующий запрос с фильтрами равенства и диапазона.

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age > 18
```

Этот запрос будет более эффективным с составным индексом в (Name ASC, Age ASC). Однако запрос не будет использовать составной индекс в (Age ASC, Name ASC), так как фильтры равенства должны быть определены первыми в составном индексе.

При создании составных индексов для запросов с фильтрами для нескольких свойств используются следующие рекомендации.

- Свойства в фильтре запроса должны соответствовать значениям в составном индексе. Если свойство находится в составном индексе, но не включено в запрос в качестве фильтра, то запрос не будет использовать составной индекс.
- Если запрос содержит дополнительные свойства в фильтре, которые не были определены в составном индексе, то для оценки запроса будет использоваться сочетание составного индекса и индекса диапазона. Для этого потребуется меньше единиц запросов, чем при использовании индексов диапазона.
- Если свойство имеет фильтр диапазона (,, `>` `<` `<=` , `>=` или `!=` ), то это свойство должно быть определено последним в составном индексе. Если запрос содержит более одного фильтра диапазона, он не будет использовать составной индекс.
- При создании составного индекса для оптимизации запросов с несколькими фильтрами `ORDER` составной индекс не будет оказывать влияния на результаты. Это необязательное свойство.
- Если не определить составной индекс для запроса с фильтрами по нескольким свойствам, запрос будет выполняться с ошибкой. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса.

Рассмотрим следующие примеры, где составной индекс определяется по имени, возрасту и метке свойства.

| **Составной индекс**     | **Образец запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |

### <a name="queries-with-a-filter-as-well-as-an-order-by-clause"></a>запросы с фильтром, а также с предложением ORDER BY;

Если запрос фильтрует одно или несколько свойств и имеет различные свойства в предложении ORDER BY, может быть полезно добавить свойства в фильтр в `ORDER BY` предложение.

Например, добавив свойства в фильтре в предложение ORDER BY, можно переписывать следующий запрос, чтобы использовать составной индекс:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.name, c.timestamp
```

Те же оптимизации шаблонов и запросов можно обобщить для запросов с несколькими фильтрами равенства:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.name, c.age, c.timestamp
```

Следующие рекомендации используются при создании составных индексов для оптимизации запроса с помощью фильтра и `ORDER BY` предложения.

* Если запрос фильтрует свойства, они должны быть включены в `ORDER BY` предложение первыми.
* Если не определить составной индекс для запроса с фильтром по одному свойству и отдельным `ORDER BY` предложением с другим свойством, запрос будет выполняться. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса, особенно если свойство в `ORDER BY` предложении имеет большую кратность.
* Все вопросы, касающиеся создания составных индексов для `ORDER BY` запросов с несколькими свойствами, а также запросы с фильтрами по нескольким свойствам, по-прежнему применяются.


| **Составной индекс**                      | **Образец `ORDER BY` запроса**                                  | **Поддерживается составным индексом?** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="modifying-the-indexing-policy"></a>Изменение политики индексирования

Политику индексирования контейнера можно обновить в любое время с [помощью портал Azure или одного из поддерживаемых пакетов SDK](how-to-manage-indexing-policy.md). Обновление политики индексирования активирует преобразование старого индекса в новый, который выполняется в сети и на месте (поэтому дополнительное пространство для хранения данных во время операции не потребляется). Индекс старой политики эффективно преобразуется в новую политику, не влияя на доступность записи, доступность чтения или пропускную способность, подготовленную в контейнере. Преобразование индекса — это асинхронная операция, а время, необходимое для выполнения, зависит от подготовленной пропускной способности, количества элементов и их размера.

> [!NOTE]
> Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

На запись доступности во время любых преобразований индекса не влияет. Преобразование «индекс» использует подготовленный метод отправки, но с более низким приоритетом, чем операции CRUD или запросы.

При добавлении нового индекса влияния на чтение доступности не возникает. Запросы будут использовать новые индексы только после завершения преобразования индекса. Во время преобразования индекса обработчик запросов будет продолжать использовать существующие индексы, поэтому во время преобразования индексирования вы научитесь выполнять аналогичные операции чтения до начала изменения индексирования. При добавлении новых индексов также возникает риск неполного или несоответствия результатов запроса.

При удалении индексов и немедленном выполнении запросов, использующих фильтрацию по удаленным индексам, не гарантируется согласованность или полнота результатов запроса. Если удалить несколько индексов и сделать это в одном изменении одной политики индексирования, обработчик запросов гарантирует согласованность и полноту результатов в рамках преобразования «индекс». Однако при удалении индексов с помощью нескольких изменений политики индексирования обработчик запросов не гарантирует согласованности или полноты результатов до завершения всех преобразований индекса. Большинство разработчиков не удаляют индексы, а затем сразу же пытаются выполнить запросы, использующие эти индексы, так что на практике такая ситуация маловероятно.

> [!NOTE]
> Там, где это возможно, всегда следует попытаться сгруппировать несколько изменений индексирования в одно изменение одной политики индексирования.

## <a name="indexing-policies-and-ttl"></a>Политики индексирования и TTL

Для использования [функции срока жизни (TTL)](time-to-live.md) требуется индексирование. Это означает следующее.

- невозможно активировать TTL для контейнера, в котором для режима индексирования задано значение None,
- невозможно задать для режима индексирования значение None в контейнере, где активирован TTL.

В сценариях, где не требуется индексировать свойство, но требуется TTL, можно использовать политику индексации с:

- режим индексирования установлен в значение consistent, а
- Нет добавленных путей и
- `/*`только как исключающий путь.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании см. по следующим ссылкам:

- [Общие сведения об индексировании](index-overview.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
