---
title: Советы по повышению производительности для пакета SDK для Java версии 4 в Azure Cosmos DB
description: Сведения о том, как повысить производительность базы данных Azure Cosmos DB с пакетом SDK для Java версии 4
author: anfeldma-ms
ms.service: cosmos-db
ms.devlang: java
ms.topic: how-to
ms.date: 07/08/2020
ms.author: anfeldma
ms.openlocfilehash: 30573eb3b35152ab5769c1aab9c4af052cb454a6
ms.sourcegitcommit: 1e6c13dc1917f85983772812a3c62c265150d1e7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2020
ms.locfileid: "86171029"
---
# <a name="performance-tips-for-azure-cosmos-db-java-sdk-v4"></a>Советы по повышению производительности для пакета SDK для Java версии 4 в Azure Cosmos DB

> [!div class="op_single_selector"]
> * [Пакет SDK для Java версии 4](performance-tips-java-sdk-v4-sql.md)
> * [Пакет SDK для Async Java версии 2](performance-tips-async-java.md)
> * [Пакет SDK для Sync Java версии 2](performance-tips-java.md)
> * [Пакет SDK версии 3 для .NET](performance-tips-dotnet-sdk-v3-sql.md)
> * [Пакет SDK для .NET версии 2](performance-tips.md)
> 

> [!IMPORTANT]  
> Советы по повышению производительности в этой статье предназначены исключительно для пакета SDK для Java версии 4 в Azure Cosmos DB. Дополнительные сведения см. в [заметках о выпуске](sql-api-sdk-java-v4.md) для пакета SDK для Java версии 4 в Azure Cosmos DB, в [репозитории Maven](https://mvnrepository.com/artifact/com.azure/azure-cosmos), а также в [руководстве по устранению неполадок](troubleshoot-java-sdk-v4-sql.md) для пакета SDK для Java версии 4 в Azure Cosmos DB. Если сейчас вы используете более раннюю версию, чем версия 4, руководство [Перевод приложения на использование пакета средств разработки Java для Azure Cosmos DB версии 4](migrate-java-v4-sdk.md) поможет вам обновить его до версии 4.
>

Azure Cosmos DB — быстрая и гибкая распределенная база данных, которая легко масштабируется с гарантированной задержкой и пропускной способностью. Для масштабирования базы данных с помощью Azure Cosmos DB не нужно вносить в архитектуру существенные изменения или писать сложный код. Для увеличения или уменьшения масштаба достаточно вызвать один метод интерфейса API или пакета SDK. Но так как для доступа к Azure Cosmos DB выполняются сетевые вызовы, некоторая оптимизация на стороне клиента поможет повысить производительность при работе с пакета SDK для Java версии 4 в Azure Cosmos DB.

Чтобы повысить производительность базы данных, рассмотрите следующие варианты.

## <a name="networking"></a>Сеть

* **Режим подключения: использование прямого подключения**
<a id="direct-connection"></a>
    
    Режим подключения к Azure Cosmos DB серьезно влияет на производительность, в частности на задержку на стороне клиента. Режим подключения — это ключевой параметр конфигурации, доступный для настройки клиента. Для Azure Cosmos DB пакета SDK для Java версии 4 доступны два режима подключения:  

    * Режим Direct (по умолчанию)      
    * Режим шлюза

    Эти режимы подключения, по сути, являются условием маршрутизации запросов плоскости данных — чтения и записи документа. передавайте их с клиентского компьютера в секции в серверной части Azure Cosmos DB. Обычно режим Direct является предпочтительным вариантом для лучшей производительности. он позволяет клиенту открывать подключения TCP непосредственно к секциям в Azure Cosmos DB серверных *запросов и передавать запросы напрямую ly*без посредников. И наоборот, в режиме шлюза выполняемые клиентом запросы направляются на так называемый сервер шлюза в интерфейсной части Azure Cosmos DB, который в свою очередь направляет запросы соответствующим секциям в серверной части Azure Cosmos DB. Так как в режиме шлюза используется стандартный порт HTTPS и одна конечная точка, его рекомендуется использовать для приложений, запущенных в корпоративных сетях со строгими ограничениями брандмауэра. Но режим шлюза не обеспечивает максимальную производительность, поскольку задействует дополнительный сетевой прыжок (от клиента к шлюзу и от шлюза к секции) при каждой операции чтения или записи данных в Azure Cosmos DB. Поэтому для обеспечения более высокой производительности рекомендуется использовать режим прямого подключения.

    Режим подключения для запросов плоскости данных настраивается в построителе Azure Cosmos DB клиента с помощью методов *директмоде ()* или *гатеваймоде ()* , как показано ниже. Чтобы настроить в любом из режимов параметры по умолчанию, вызовите любой метод без аргументов. В противном случае Передайте экземпляр класса параметров конфигурации в качестве аргумента (*директконнектионконфиг* для *директмоде ()*, *гатевайконнектионконфиг* для *гатеваймоде ()*.)
    
    ### <a name="java-v4-sdk"></a><a id="override-default-consistency-javav4"></a> Пакет SDK для Java версии 4

    # <a name="async"></a>[Асинхронный режим](#tab/api-async)

    Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceClientConnectionModeAsync)]

    # <a name="sync"></a>[Синхронизация](#tab/api-sync)

    Синхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=PerformanceClientConnectionModeSync)]

    --- 

    Метод *директмоде ()* имеет дополнительное переопределение по следующей причине. Операции плоскости управления, такие как база данных и CRUD в контейнере, *всегда* используют режим шлюза. Когда пользователь настроил режим Direct для операций с плоскостью данных, операции плоскости управления используют параметры режима шлюза по умолчанию. Это подходит большинству пользователей. Тем не менее пользователи, которым нужен прямой режим для операций с плоскостью данных, а также тунабилити параметров режима шлюза плоскости управления, могут использовать следующее переопределение *директмоде ()* :

    ### <a name="java-v4-sdk"></a><a id="override-default-consistency-javav4"></a> Пакет SDK для Java версии 4

    # <a name="async"></a>[Асинхронный режим](#tab/api-async)

    Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceClientDirectOverrideAsync)]

    # <a name="sync"></a>[Синхронизация](#tab/api-sync)

    Синхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=PerformanceClientDirectOverrideSync)]

    --- 

<a name="collocate-clients"></a>
* **Повышение производительности за счет размещения клиентов в одном регионе Azure** <a id="same-region"></a>

    Если это возможно, размещайте приложения, выполняющие вызовы к Azure Cosmos DB, в том же регионе, в котором находится база данных Azure Cosmos. Для приблизительного сравнения: вызовы к Azure Cosmos DB в пределах региона выполняются в течение 1–2 мс, но задержка между восточным и западным побережьем США превышает 50 мс. Значение задержки может отличаться в зависимости от выбранного маршрута при передаче запроса от клиента к границе центра обработки данных Azure. Минимальная возможная задержка достигается при размещении клиентского приложения в том же регионе Azure, в котором предоставляется конечная точка Azure Cosmos DB. Список доступных регионов см. на странице [Регионы Azure](https://azure.microsoft.com/regions/#services).

    :::image type="content" source="./media/performance-tips/same-region.png" alt-text="Пример политики подключения Azure Cosmos DB" border="false":::

    Приложение, взаимодействующее с учетной записью Azure Cosmos DB в нескольких регионах, должно настроить [предпочтительные расположения](tutorial-global-distribution-sql-api.md#preferred-locations), чтобы запросы направлялись в совмещенный регион.

* **Включите ускоренную сеть на виртуальной машине Azure для снижения задержки.**

Рекомендуется следовать инструкциям по включению ускоренной сети в виртуальной машине Azure для [Windows (щелкните здесь, чтобы получить инструкции)](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-powershell) или [Linux (щелкните здесь, чтобы получить инструкции)](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-cli), чтобы обеспечить максимальную производительность.

Без ускоренной сети операции ввода-вывода, выполняемые между виртуальной машиной Azure и другими ресурсами Azure, могут без необходимости маршрутизироваться через узел и виртуальный коммутатор, расположенный между виртуальной машиной и ее сетевой картой. Наличие узла и виртуального коммутатора внутри пути данных не только увеличивает задержку и дрожание в коммуникационном канале, но также приводит к краже циклов ЦП у виртуальной машины. Благодаря ускоренной сети виртуальная машина взаимодействует напрямую с сетевой картой, без посредников; все сведения о политике сети, которые ранее обрабатывались узлом и виртуальным коммутатором, теперь обрабатываются оборудованием на сетевой карте, а узел и виртуальный коммутатор обходятся. При включении ускоренной сети, как правило, можно ожидать снижение задержки и увеличение пропускной способности, а также улучшение *согласованности* задержки и снижение загрузки ЦП.

Ограничения: ускоренная сеть должна поддерживаться в ОС виртуальной машины и может быть включена только при остановке и освобождении виртуальной машины. Виртуальную машину невозможно развернуть с помощью Azure Resource Manager.

Дополнительные сведения см. в инструкциях для [Windows](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-powershell) и [Linux](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-cli).

## <a name="sdk-usage"></a>Использование пакета SDK
* **Установка последней версии пакета SDK**

    Пакеты SDK для Azure Cosmos DB постоянно улучшаются, чтобы обеспечивать самую высокую производительность. Сведения об улучшениях в последней версии пакета SDK см. в статье о [пакете SDK для Azure Cosmos DB](sql-api-sdk-async-java.md).

* **Используйте один и тот же клиент Azure Cosmos DB в течение всего жизненного цикла приложения.**

    Каждый экземпляр клиента Azure Cosmos DB является потокобезопасным, а также эффективно управляет подключениями и кэширует адреса. Чтобы реализовать возможность управления подключениями и оптимизировать производительность, рекомендуется использовать один экземпляр клиента Azure Cosmos DB для каждого домена приложения в течение жизненного цикла приложения.

   <a id="max-connection"></a>

* **Использование минимально необходимого уровня согласованности для приложения**

    При создании *CosmosClient* используется согласованность по умолчанию, если явно не задано значение *Сеанс*. Если в логике приложения не требуется согласованность типа *Сеанс*, задайте для параметра *Согласованность* значение *Случайная*. Примечание. Рекомендуется использовать согласованность по меньшей мере уровня *Сеанс* в приложениях, использующих обработчик канала изменений Azure Cosmos DB.

* **Использование асинхронного API для обеспечения максимальной подготовленной пропускной способности**

    Пакет SDK для Java версии 4 в Azure Cosmos DB содержит два API — синхронный и асинхронный. Не вдаваясь в подробности, асинхронный API реализует функциональность пакета SDK, тогда как синхронный API представляет собой тонкую оболочку, осуществляющую блокирование вызовов к асинхронному API. Это отличается от более старого пакета SDK для Async Java версии 2 в Azure Cosmos DB, который был исключительно асинхронным, а также более старого пакета SDK для Sync Java версии 2 в Azure Cosmos DB, который был исключительно синхронным и имел полностью отдельную реализацию. 
    
    Выбор API определяется во время инициализации клиента: *CosmosAsyncClient* поддерживает асинхронный API, а *CosmosClient* — синхронный. 
    
    Асинхронный API реализует неблокирующие операции ввода-вывода и является оптимальным выбором, если ваша цель — максимально высокая пропускная способность при отправке запросов для Azure Cosmos DB. 
    
    Использование синхронного API может быть оправдано, если вам нужен API, блокирующий ответ на каждый запрос или если синхронная операция является доминирующей парадигмой в приложении. Например, синхронный API может потребоваться при сохранении данных в Azure Cosmos DB в приложении микрослужб при условии, что пропускная способность не является критически важной.  
    
    Просто имейте в виду, что пропускная способность синхронного API снижается с увеличением времени ответа на запрос, а асинхронный API может использовать все пропускную способность вашего оборудования. 
    
    Совместное размещение по географическому признаку может обеспечить более высокую и согласованную пропускную способность при использовании синхронного API (см. раздел [Повышение производительности за счет размещения клиентов в одном регионе Azure](#collocate-clients)), однако это по-прежнему не позволит превзойти пропускную способность для асинхронного API.

    Некоторые пользователи могут быть незнакомы с [Project Reactor](https://projectreactor.io/) — платформой Reactive Streams, используемой для реализации асинхронного API пакета SDK для Java версии 4 в Azure Cosmos DB. Если это так, мы рекомендуем вам ознакомиться с нашим вводным руководством по [шаблонам Reactor](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples/blob/master/reactor-pattern-guide.md), а затем ознакомиться с этим [введением в реактивное программирование](https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/Intro). Если вы уже использовали Azure Cosmos DB с асинхронным интерфейсом, применяя при этом пакет SDK для Async Java версии 2 в Azure Cosmos DB, возможно, вы знакомы с [ReactiveX](http://reactivex.io/)/[RxJava](https://github.com/ReactiveX/RxJava), но не знаете точно, что именно изменилось в Project Reactor. В этом случае ознакомьтесь с нашим [сравнением Reactor и RxJava](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples/blob/master/reactor-rxjava-guide.md).

    В следующих фрагментах кода показано, как инициализировать клиент Azure Cosmos DB для операции с асинхронным API или синхронным API соответственно.

    ### <a name="java-v4-sdk"></a><a id="override-default-consistency-javav4"></a> Пакет SDK для Java версии 4

    # <a name="async"></a>[Асинхронный режим](#tab/api-async)

    Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceClientAsync)]

    # <a name="sync"></a>[Синхронизация](#tab/api-sync)

    Синхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=PerformanceClientSync)]

    --- 

* **Настройка ConnectionPolicy**

    По умолчанию при использовании пакета SDK для Java версии 4 в Azure Cosmos DB запросы на прямое подключение к Cosmos DB выполняются по протоколу TCP. В режиме внутреннего прямого подключения используется специальная архитектура для динамического управления сетевыми ресурсами и обеспечения лучшей производительности.

    В пакета SDK для Java версии 4 в Azure Cosmos DB для повышения производительности базы данных у большинства рабочих нагрузок лучше всего подходит режим прямого подключения. 

    * ***Общие сведения о режиме прямого подключения***

        :::image type="content" source="./media/performance-tips-async-java/rntbdtransportclient.png" alt-text="Иллюстрация архитектуры режима прямого подключения" border="false":::

        Клиентская архитектура, применяемая в режиме прямого подключения, обеспечивает предсказуемое использование сети и мультиплексированный доступ к репликам Azure Cosmos DB. На схеме выше показано, как в режиме прямого подключения запросы клиентов направляются к репликам в серверной части Cosmos DB. Архитектура режима прямого подключения выделяет до 10 **каналов** на стороне клиента на каждую реплику базы данных. Канал представляет собой TCP-соединение, которому предшествует буфер запросов глубиной 30 запросов. Каналы, принадлежащие реплике, динамически распределяются по мере необходимости **конечной точкой службы** реплики. Когда пользователь отправляет запрос в режиме прямого подключения, **TransportClient** направляет запрос на соответствующую конечную точку службы на основе ключа раздела. **Очередь запросов** помещает запросы в буфер перед конечной точкой службы.

    * ***Параметры конфигурации для прямого режима***

        Если требуется не по умолчанию режим прямого режима, создайте экземпляр *директконнектионконфиг* и настройте его свойства, а затем передайте экземпляр настраиваемого свойства в метод *директмоде ()* в построителе Azure Cosmos DB клиента.

        Эти параметры конфигурации управляют поведением базовой архитектуры прямого режима, о которой говорилось выше.

        Для начала воспользуйтесь рекомендуемыми параметрами конфигурации, приведенными ниже. Эти параметры *директконнектионконфиг* являются дополнительными параметрами конфигурации, которые могут повлиять на производительность пакета SDK непредвиденным образом. рекомендуется избегать изменения этих пользователей, если только они не кажутся очень удобными для понимания компромиссов и абсолютно необходимы. При возникновении проблем обращайтесь к [специалистам команды Azure Cosmos DB](mailto:CosmosDBPerformanceSupport@service.microsoft.com).

        | Параметр конфигурации       | По умолчанию    |
        | :------------------:       | :-----:    |
        | idleConnectionTimeout      | "PT1M"     |
        | максконнектионсперендпоинт  | "PT0S"     |
        | connectTimeout             | "PT1M10S"  |
        | idleEndpointTimeout        | 8388608    |
        | максрекуестсперконнектион   | 10         |

* **Настройка параллельных запросов для секционированных коллекций**

    Пакет SDK для Java версии 4 в Azure Cosmos DB поддерживает параллельные запросы, позволяющие обращаться к секционированным коллекциям в параллельном режиме. Дополнительные сведения см. в [примерах кода](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples), касающихся работы с пакетом SDK для Java версии 4 в Azure Cosmos DB. Параллельные запросы предназначены для сокращения задержки при обработке запросов и улучшения пропускной способности посредством их последовательных аналогов.

    * ***Настройка setMaxDegreeOfParallelism\:***
    
        Параллельный режим запросов позволяет одновременно обращаться к нескольким секциям. Однако данные из каждой секционированной коллекции извлекаются в рамках запроса последовательно. С помощью параметра setMaxDegreeOfParallelism установите значение, соответствующее числу секций, что обеспечит максимальную вероятность высокой производительности запроса при сохранении всех остальных параметров системы. Если вы не знаете количество секций, просто используйте высокое значение для setMaxDegreeOfParallelism. Система автоматически выберет минимальное из двух значений: количество секций или число, указанное пользователем.

        Следует отметить, что параллельные запросы обеспечивают больше преимуществ, если данные равномерно распределены во всех секциях по отношению к запросу. Если коллекция секционируется таким образом, что все или большинство данных, возвращаемых запросом, содержатся в нескольких секциях (в худшем случае в одной), это негативно скажется на производительности запроса.

    * ***Настройка setMaxBufferedItemCount\:***
    
        Параллельный запрос предназначен для предварительного получения результатов, пока текущий пакет результатов обрабатывается клиентом. Предварительная выборка способствует общему уменьшению задержки при обработке запроса. Значение setMaxBufferedItemCount ограничивает количество предварительно выбираемых результатов. Указав для параметра setMaxBufferedItemCount ожидаемое число возвращаемых результатов (или еще более высокое значение), вы обеспечите максимальное влияние предварительной выборки на производительность запросов.

        Предварительная выборка работает одинаково при любом значении параметра MaxDegreeOfParallelism. Для данных из всех секций применяется один буфер.

* **Горизонтальное увеличение масштаба рабочей нагрузки клиента**

    При проверке с высокой пропускной способностью клиентское приложение может стать узким местом из-за того, что на компьютере будут достигнуты максимальные уровни использования ЦП и сети. Если вы достигли этой точки, то можете повысить производительность Azure Cosmos DB, развернув клиентские приложения на нескольких серверах.

    Общее правило заключается в том, чтобы не превышать загрузку ЦП > 50 % на любом конкретном сервере для снижения задержки.

   <a id="tune-page-size"></a>

* **Оптимизация производительности посредством настройки размера страницы для запросов и каналов чтения**

    Если при массовом чтении документов с помощью функции чтения канала (например, *readItems*) или обработке запроса SQL (*queryItems*) будет получен слишком большой набор результатов, такие результаты возвращаются частями. По умолчанию результаты возвращаются в пакетах (не более 100 элементов и не более 1 МБ в каждом пакете).

    Предположим, что приложение отправляет запрос к Azure Cosmos DB, а вашему приложению для выполнения задачи требуется полный набор результатов запроса. Чтобы снизить количество сетевых взаимодействий, необходимых для получения всех нужных результатов, попробуйте увеличить размер страницы с помощью поля заголовка запроса [x-ms-max-item-count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers). 

    * В односекционных запросах установка для поля [x-ms-max-item-count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) значения -1 (без ограничений по размеру страницы) увеличивает задержку, минимизируя количество страниц ответов на запрос: полный результирующий набор будет возвращен на одной странице (либо, если запрос занимает больше времени, чем интервал времени ожидания, полный результирующий набор будет возвращен на минимально возможном числе страниц). Это экономит время на нескольких круговых путях запроса.
    
    * В запросах между секциями при установке для поля [x-ms-max-item-count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) значения -1 и снятии ограничения на размер страницы появляется риск перегрузки пакета SDK из-за неуправляемых размеров страниц. В случае запросов между секциями мы рекомендуем увеличить предельный размер страницы до большого, но конечного значения (например, 1000), чтобы сократить задержку. 
    
    В некоторых приложениях полный набор результатов запроса может не требоваться. Чтобы отобразить лишь некоторые результаты, например когда пользовательский интерфейс или приложение API возвращает только 10 результатов за раз, размер страницы можно уменьшить до 10. Это позволит снизить пропускную способность, используемую на операции чтения и на выполнение запросов.

    Можно также задать предпочтительный аргумент размера страницы для метода *byPage* вместо того, чтобы напрямую изменять поле заголовка REST. Помните, что поле [x-ms-max-item-count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) или аргумент предпочтительного размера страницы для *byPage* задают только верхний предел размера страницы, а не абсолютное требование. Поэтому по ряду причин Azure Cosmos DB может возвращать страницы, размер которых меньше предпочтительного. 

* **Использование надлежащего планировщика (избегайте перехвата потоков цикла обработки событий ввода-вывода netty)**

    Асинхронные функции пакета SDK для Java в Azure Cosmos DB основаны на неблокирующих операциях ввода-вывода [netty](https://netty.io/). В пакете SDK используется фиксированное число потоков цикла обработки событий ввода-вывода netty (это число соответствует числу ядер ЦП на компьютере) для выполнения операций ввода-вывода. Объект Flux, возвращаемый API, выводит результат в один из общих потоков цикла обработки событий ввода-вывода netty. Поэтому важно не блокировать общие потоки цикла обработки событий ввода-вывода netty. Интенсивное использование ЦП или блокировка операции в потоке цикла обработки событий ввода-вывода netty может вызвать взаимоблокировку или значительно уменьшить пропускную способность пакета SDK.

    Например, следующий код выполняет рабочую нагрузку с интенсивной нагрузкой на ЦП в потоке цикла обработки событий ввода-вывода netty.
    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-noscheduler"></a>Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceNeedsSchedulerAsync)]

    Если необходимо выполнить обработку полученного результата с интенсивной нагрузкой на ЦП, этого нежелательно делать в потоке цикла обработки событий ввода-вывода netty. Вместо этого можно предоставить собственный планировщик, чтобы предоставить собственный поток для выполнения работы, как показано ниже (требуется `import reactor.core.scheduler.Schedulers` ).

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-scheduler"></a>Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceAddSchedulerAsync)]

    Следует использовать подходящий планировщик Reactor в зависимости от типа рабочей нагрузки. Дополнительные сведения см. здесь: [``Schedulers``](https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html).

    Дополнительные сведения о пакете SDK для Java версии 4 в Azure Cosmos DB см. в [каталоге Cosmos DB единого репозитория Azure SDK для Java на сайте GitHub](https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/cosmos/azure-cosmos).

* **Оптимизация параметров ведения журнала в приложении**

    По различным причинам вам может потребоваться добавить функции ведения журнала в поток, который создает высокую пропускную способность запросов. Если ваша цель в полном насыщении подготовленной пропускной способности контейнера запросами, создаваемыми этим потоком, оптимизация ведения журнала может значительно повысить производительность.

    * ***Настройка асинхронного средства ведения журнала***

        Задержка синхронного средства ведения журнала обязательно учитывается в общем значении задержки для потока, создающего запросы. Асинхронное средство ведения журнала, такое как [log4j2](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Flogging.apache.org%2Flog4j%2Flog4j-2.3%2Fmanual%2Fasync.html&data=02%7C01%7CCosmosDBPerformanceInternal%40service.microsoft.com%7C36fd15dea8384bfe9b6b08d7c0cf2113%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637189868158267433&sdata=%2B9xfJ%2BWE%2F0CyKRPu9AmXkUrT3d3uNA9GdmwvalV3EOg%3D&reserved=0), рекомендуется использовать, чтобы отделить служебные данные ведения журнала от потоков приложений с высокой производительностью.

    * ***Отключение ведения журнала netty***

        Журналы библиотеки netty загружают ЦП, и их необходимо отключить (отключения журнала в конфигурации может быть недостаточно). Если вы не используете режим отладки, полностью отключите ведение журналов netty. Поэтому, если вы используете log4j для сокращения дополнительных затрат на ЦП в связи с ``org.apache.log4j.Category.callAppenders()`` из netty, добавьте следующую строку в базу кода:

        ```java
        org.apache.log4j.Logger.getLogger("io.netty").setLevel(org.apache.log4j.Level.OFF);
        ```

 * **Лимит на ресурсы открытых файлов ОС**
 
    Некоторые дистрибутивы Linux (например, RedHat) ограничивают максимальное число открытых файлов и общее число подключений. Чтобы узнать текущие ограничения, выполните следующую команду:

    ```bash
    ulimit -a
    ```

    Число открытых файлов (nofile) должно быть достаточно большим, чтобы было достаточно места для настроенного размера пула подключений и других открытых файлов в ОС. Это число можно изменить для включения поддержки пула подключений большего размера.

    Откройте файл limits.conf:

    ```bash
    vim /etc/security/limits.conf
    ```
    
    Добавьте или измените следующие строки:

    ```
    * - nofile 100000
    ```

* **Указание ключа секции в операциях точечной записи**

    Чтобы повысить производительность операций точечной записи, укажите ключ секции элемента в вызове API точечной записи, как показано ниже:

    # <a name="async"></a>[Асинхронный режим](#tab/api-async)

    Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceNoPKAsync)]

    # <a name="sync"></a>[Синхронизация](#tab/api-sync)

    Синхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=PerformanceNoPKSync)]

    --- 

    вместо того, чтобы предоставлять только экземпляр элемента, как показано ниже:

    # <a name="async"></a>[Асинхронный режим](#tab/api-async)

    Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceAddPKAsync)]

    # <a name="sync"></a>[Синхронизация](#tab/api-sync)

    Синхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=PerformanceAddPKSync)]

    --- 

    Последний вариант поддерживается, но добавляет задержку в приложение; пакет SDK должен проанализировать элемент и извлечь ключ секции.

## <a name="indexing-policy"></a>Политика индексации
 
* **Увеличение скорости выполнения операций записи посредством исключения неиспользуемых путей из индексирования**

    Политика индексирования Azure Cosmos DB позволяет добавлять к индексированию или исключать из индексирования определенные пути к документам, используя механизм Indexing Paths (setIncludedPaths и setExcludedPaths). Возможность управления путями индексирования позволяет оптимизировать производительность записи и снизить затраты на хранение индекса для сценариев с заранее определенными шаблонами запросов. Это связано с тем, что затраты на индексирование непосредственно зависят от количества уникальных путей индексирования. Например, в следующем коде показано, как включить и исключить все разделы документов (также называемые поддеревом) из индексирования с помощью подстановочного знака "*".

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos"></a><a id="java4-indexing"></a>Пакет SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=MigrateIndexingAsync)]

    Дополнительные сведения см. в статье [Политики индексации Azure Cosmos DB](indexing-policies.md).

## <a name="throughput"></a>Пропускная способность
<a id="measure-rus"></a>

* **Измерение и настройка расхода единиц запроса/повторного использования**

    Azure Cosmos DB предоставляет обширный набор операций с документами в коллекции базы данных, в том числе реляционные и иерархические запросы с использованием UDF, хранимых процедур и триггеров. Затраты, связанные с каждой из этих операций, зависят от типа процессора, операций ввода-вывода и памяти, необходимой для завершения операции. Вместо того чтобы думать о закупке и управлении аппаратными ресурсами, вы можете думать о единице запроса (RU) как единой меры для ресурсов, необходимых для выполнения различных операций с базами данных и обслуживания запросов приложений.

    Пропускная способность выделяется на основе количества [единиц запроса](request-units.md), заданного для каждого контейнера. Удельный расход единиц запросов оценивается в расчете на одну секунду. Частота запросов для приложений, у которых она превышает подготовленные единицы запросов для контейнера, будет ограничена, пока она не упадет ниже зарезервированного для контейнера уровня. Если приложению требуется более высокий уровень пропускной способности, можно увеличить ее путем выделения дополнительных единиц запросов.

    Сложность запроса влияет на количество единиц запроса, потребляемых операцией. Количество предикатов и их характер, количество определяемых пользователем функций и размер набора исходных данных — все это влияет на плату за операции запроса.

    Чтобы оценить расходы на любую операцию (создание, обновление или удаление), проверьте значение заголовка [x-ms-request-charge](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers). Это значение содержит число единиц запроса, потребляемых соответствующей операцией. Также можно проверить аналогичное свойство RequestCharge в ResourceResponse\<T> или FeedResponse\<T>.

    # <a name="async"></a>[Асинхронный режим](#tab/api-async)

    Асинхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/async/SampleDocumentationSnippetsAsync.java?name=PerformanceRequestChargeAsync)]

    # <a name="sync"></a>[Синхронизация](#tab/api-sync)

    Синхронный API пакета SDK для Java версии 4 (Maven com.azure::azure-cosmos)

    [!code-java[](~/azure-cosmos-java-sql-api-samples/src/main/java/com/azure/cosmos/examples/documentationsnippets/sync/SampleDocumentationSnippets.java?name=PerformanceRequestChargeSync)]

    --- 

    Стоимость запроса, указанная в этом заголовке, учитывается как часть подготовленной пропускной способности. Например, если вы предоставили 2000 единиц запроса в секунду, а приведенный выше запрос возвращает 1000 документов размером по 1 КБ каждый, затраты на операцию составят 1000 единиц. Таким образом, перед ограничением частоты выполнения последующих запросов сервер за одну секунду выполняет только два таких запроса. Чтобы узнать больше, ознакомьтесь с [единицами запроса](request-units.md) и [калькулятором единиц запроса](https://www.documentdb.com/capacityplanner).

<a id="429"></a>
* **Обработка ограничения скорости / слишком высокая частота запросов**

    Выполнение запроса, который превышает лимит зарезервированной пропускной способности для учетной записи, не приводит к снижению производительности сервера, так как пользователь не сможет превысить это зарезервированное значение. Сервер заранее завершит запрос с ошибкой RequestRateTooLarge (код состояния HTTP: 429) и вернет в заголовке [x-x-ms-retry-after-ms](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) время (в миллисекундах), спустя которое можно повторно выполнить этот запрос.

    ```xml
        HTTP Status 429,
        Status Line: RequestRateTooLarge
        x-ms-retry-after-ms :100
    ```

    Пакеты SDK перехватят этот ответ, обработают заголовок retry-after, указанный сервером, и отправят запрос повторно. Если к вашей учетной записи параллельно имеет доступ только один клиент, следующая попытка будет успешной.

    По умолчанию количество повторных попыток отправки запроса составляет 9 (это значение задается клиентом). Если к вашей учетной записи имеют доступ несколько клиентов и они выполняют запросы одновременно, этого значения может быть недостаточно. В этом случае клиент выдаст для приложения исключение *CosmosClientException* с кодом состояния 429. Число повторных попыток по умолчанию можно переопределить в свойстве setRetryOptions экземпляра ConnectionPolicy. По умолчанию в случае превышения заданного счетчика повторов исключение *CosmosClientException* с кодом состояния 429 возвращается через 30 секунд (совокупное время ожидания). Это происходит, даже если текущее значение количества повторных попыток (по умолчанию (9) или определенное пользователем) меньше максимального значения.

    Хотя автоматическая процедура отправки повторного запроса позволяет улучшить устойчивость приложений и повысить удобство работы с ними, она может снизить производительность, что, в свою очередь, станет причиной появления более длительных задержек. Если настройка производительности повлияла на регулирование сервера и стала причиной автоматической отправки запросов пакетом SDK, это может стать причиной появления пиков задержек на стороне клиента. Чтобы избежать пиков задержек во время настройки производительности, проверьте расход ресурсов на каждую операцию и убедитесь, что значение частоты запросов не превышено. Дополнительные сведения см. в статье [Единицы запросов в DocumentDB](request-units.md).

* **Использование меньших документов для более высокой пропускной способности**

    Стоимость запроса (плата за обработку запроса) для каждой операции напрямую зависит от размера документа. За операции с большими документами взимается больше единиц запроса, чем за операции с мелкими документами. Оптимальнее всего проектировать приложение и рабочие процессы с размером элемента около 1 КБ либо с размером схожего порядка или величины. Для приложений, чувствительных к задержке, следует избегать крупных элементов — документы размером в несколько мегабайт замедлят работу приложения.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о создании приложения с высокой масштабируемостью и производительностью см. в статье [Partitioning and scaling in Azure Cosmos DB](partition-data.md) (Секционирование и масштабирование в Azure Cosmos DB).
