---
title: Устранение неполадок с временем ожидания кэша Azure для Redis
description: Узнайте, как устранить распространенные проблемы времени ожидания с кэшем Azure для Redis
author: yegu-ms
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: yegu
ms.openlocfilehash: e58b305a43cc5ad339fb87b9b8a09af04c410839
ms.sourcegitcommit: 5a8c65d7420daee9667660d560be9d77fa93e9c9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2019
ms.locfileid: "74121384"
---
# <a name="troubleshoot-azure-cache-for-redis-timeouts"></a>Устранение неполадок с временем ожидания кэша Azure для Redis

В этом разделе обсуждаются проблемы времени ожидания, возникающие при подключении к кэшу Azure для Redis.

- [Исправление сервера Redis](#redis-server-patching)
- [Исключения времени ожидания StackExchange. Redis](#stackexchangeredis-timeout-exceptions)

> [!NOTE]
> Шаги по устранению проблем в этой статье также включают в себя указания по выполнению команд Redis и мониторингу различных метрик производительности. Дополнительные сведения и указания см. в разделе [Дополнительные сведения](#additional-information).
>

## <a name="redis-server-patching"></a>Исправление сервера Redis

Кэш Azure для Redis регулярно обновляет программное обеспечение сервера в рамках предоставляемых им функций управляемой службы. Это действие [установки исправлений](cache-failover.md) выполняется практически за сценой. Во время отработки отказа при исправлении узлов сервера Redis клиенты, подключенные к этим узлам, могут столкнуться с временным временем ожидания, так как подключения переключаются между этими узлами. Узнайте, [как отработка отказа влияет на мое клиентское приложение](cache-failover.md#how-does-a-failover-affect-my-client-application) , чтобы получить дополнительные сведения о том, какие побочные эффекты могут быть установлены в приложении и как можно улучшить обработку событий исправления.

## <a name="stackexchangeredis-timeout-exceptions"></a>Исключения времени ожидания StackExchange.Redis

StackExchange. Redis использует параметр конфигурации с именем `synctimeout` для синхронных операций со значением по умолчанию 1000 мс. Если синхронный вызов не завершается в течение этого времени, клиент StackExchange. Redis выдает ошибку времени ожидания, как показано в следующем примере:

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)

В этом сообщении об ошибке содержатся метрики, которые помогут вам определить причину и возможное решение проблемы. В следующей таблице содержатся сведения о метриках сообщения об ошибке.

| Метрики сообщения об ошибке | Подробная информация |
| --- | --- |
| inst |Указывает, что за последний интервал времени инициировано 0 команд. |
| mgr |Диспетчер сокетов выполняет `socket.select`, что означает, что в ОС запрашивается указание сокета, который должен быть выполнен. Читатель не может активно читать данные из сети, так как не считает, что ничего делать. |
| очередь |Указывает, что выполняется 73 операции. |
| qu |6 выполняемых операций находятся в очереди неотправленных данных и еще не записаны в исходящую сеть. |
| qs |67 выполняющихся операций отправлены на сервер, но ответ еще недоступен. Ответ может быть таким: `Not yet sent by the server` или `sent by the server but not yet processed by the client.` |
| qc |0 выполняемых операций имеет ответы, но еще не помечены как завершенные, так как они ожидают завершения цикла |
| wr |Существует активный модуль записи (то есть 6 неотправленных запросов не пропускаются) байт/активевритерс |
| больше |Указывает, что отсутствуют активные модули чтения и нет байтов для чтения для bytes/activereaders сетевой карты. |

Для изучения возможных основных причин можно использовать следующие шаги.

1. Рекомендуется использовать следующий шаблон для подключения при использовании клиента StackExchange. Redis.

    ```csharp
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");

    });

    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ```

    Дополнительные сведения см. в разделе о [подключении к кэшу с использованием StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

1. Убедитесь, что сервер и клиентское приложение находятся в одном регионе в Azure. Например, вы можете получить время ожидания, если кэш находится в восточной части США, но клиент находится в западной части США, а запрос не завершится в течение `synctimeout` интервала, или вы можете получить время ожидания при отладке с локального компьютера разработки. 

    Кэш и клиент настоятельно рекомендуется размещать в одном и том же регионе Azure. Если используются межрегиональные вызовы, необходимо увеличить значение интервала `synctimeout` по умолчанию (1000 мс), добавив в строку подключения свойство `synctimeout`. В следующем примере показан фрагмент строки подключения для StackExchange. Redis, предоставляемый кэшем Azure для Redis с `synctimeout` 2000 мс.

        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
1. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
1. Если запросы привязаны к ограничениям пропускной способности на сервере или клиенте, они занимают больше времени и могут вызвать время ожидания. Сведения о превышении времени ожидания в связи с пропускной способностью сети на сервере см. в разделе [ограничение пропускной способности на стороне сервера](cache-troubleshoot-server.md#server-side-bandwidth-limitation). Сведения о превышении времени ожидания в связи с пропускной способностью сети клиента см. в разделе [ограничение пропускной способности на стороне клиента](cache-troubleshoot-client.md#client-side-bandwidth-limitation).
1. Используются ли ресурсы ЦП на сервере или клиенте?

   - Убедитесь, что вы получаете ограничение по ЦП на клиенте. Высокая загрузка ЦП может привести к тому, что запрос не будет обрабатываться в течение `synctimeout` интервала времени и вызвать тайм-аут запроса. Переход на больший размер клиента или распределение нагрузки может помочь в управлении этой проблемой.
   - Проверьте, выполняется ли привязка ЦП к серверу, отслеживая [метрику производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)ЦП. Запросы, поступающие в период с Redis ЦП, могут привести к истечению времени ожидания этих запросов. Чтобы устранить эту проблему, можно распределить нагрузку между несколькими сегментами в кэше уровня "Премиум" или обновить до более крупной или ценовой категории. Дополнительные сведения см. в разделе [ограничение пропускной способности на стороне сервера](cache-troubleshoot-server.md#server-side-bandwidth-limitation).
1. Занимает ли выполнение команд на сервере слишком много времени? Длительные команды, выполняющие длительное время для обработки на Redis-сервере, могут привести к истечению времени ожидания. Дополнительные сведения о долго выполняющихся командах см. в разделе [длительные команды](cache-troubleshoot-server.md#long-running-commands). Вы можете подключиться к кэшу Azure для экземпляра Redis с помощью клиента Redis-CLI или [консоли Redis](cache-configure.md#redis-console). Затем выполните команду [SLOWLOG](https://redis.io/commands/slowlog) , чтобы проверить, выполняются ли запросы медленнее, чем ожидалось. Сервер Redis и StackExchange.Redis оптимизированы для обработки большого количества небольших запросов, а не нескольких больших запросов. Чтобы повысить их производительность, рекомендуется разбить данные на небольшие фрагменты.

    Сведения о подключении к конечной точке SSL кэша с помощью Redis-CLI и stunnel см. в записи блога с [объявлением о поставщике состояния сеанса ASP.NET для предварительной версии Redis](https://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx).
1. Высокая загрузка сервера Redis может влечь истечение времени ожидания. Вы можете выполнить мониторинг значения загрузки сервера, измеряя `Redis Server Load`метрику производительности кэша[ ](cache-how-to-monitor.md#available-metrics-and-reporting-intervals). Максимальное значение загрузки (100) указывает на то, что сервер слишком загружен обработкой запросов и не простаивает. Чтобы узнать, не использует ли сервер все свои ресурсы на определенные запросы, выполните команду SlowLog, как описано в предыдущем абзаце. Дополнительные сведения см. в разделе "Высокий коэффициент загрузки ЦП и сервера".
1. Происходили ли на клиенте другие события, для которых требовалось сетевое кэширование? К общим событиям относятся: масштабирование количества экземпляров клиента, развертывание новой версии клиента или включение автомасштабирования. В нашем тестировании мы обнаружили, что автоматическое масштабирование или масштабирование может привести к потере исходящего сетевого подключения в течение нескольких секунд. Код StackExchange.Redis устойчив к таким событиям и подключается повторно. При повторном подключении все запросы в очереди могут исключаться из истечения времени ожидания.
1. Существовал ли в кэше большой запрос, предшествующий нескольким небольшим запросам, для которых истекло время ожидания? Параметр, `qs` в сообщении об ошибке, сообщает, сколько запросов отправлено с клиента на сервер, но не обрабатывали ответ. Это количество может увеличиваться, так как StackExchange.Redis использует одно подключение TCP, которое позволяет обрабатывать только один ответ за раз. Хотя время ожидания первой операции истекло, она не останавливает отправку данных на сервер или с сервера. Другие запросы будут заблокированы до тех пор, пока не завершится большой запрос, и это может привести к истечению времени ожидания. Чтобы решить эту проблему, рекомендуется снизить вероятность возникновения времени ожидания, увеличив размер кэша для рабочей нагрузки и разбив данные большого объема на небольшие фрагменты. Другое решение — использовать в клиенте пул объектов `ConnectionMultiplexer` и для отправки новых запросов применять наименее загруженный объект `ConnectionMultiplexer`. Загрузка нескольких объектов соединения должна препятствовать истечению времени ожидания других запросов.
1. Если вы используете `RedisSessionStateProvider`, убедитесь, что время ожидания повторных попыток задано правильно. Значение `retryTimeoutInMilliseconds` должно быть выше, чем `operationTimeoutInMilliseconds`, иначе попытки не повторяются. В следующем примере для `retryTimeoutInMilliseconds` задано значение 3000. Дополнительные сведения см. в статьях [Поставщик состояния сеанса ASP.NET для Redis](cache-aspnet-session-state-provider.md) и [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration) (Использование параметров конфигурации поставщика состояния сеанса и поставщика кэша вывода).

    ```xml
    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />
    ```

1. Проверяйте использование памяти на сервере кэша Redis для Azure, [отслеживая](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` и `Used Memory`. Если используется политика вытеснения, Redis начнет вытеснять ключи, когда значение `Used_Memory` достигнет размера кэша. В идеале значение `Used Memory RSS` должно быть немного больше, чем значение `Used memory`. Большое различие означает фрагментацию памяти (внутреннюю или внешнюю). Если значение `Used Memory RSS` меньше значения `Used Memory`, это значит, что часть кэш-памяти используется операционной системой для подкачки. При этом могут возникать значительные задержки. Поскольку Redis не имеет возможности контролировать сопоставление выделенных страниц со страницами памяти, высокая `Used Memory RSS` часто является результатом пикового использования памяти. Когда Redis Server освобождает память, распределитель получает память, но она может не вернуть память в систему. При этом операционная система может сообщать о расхождении между `Used Memory` и использованием памяти. Возможно, память была использована и освобождена Redis, но не была передана в систему. Чтобы устранить проблемы с памятью, выполните следующие действия.

   - Обновите кэш до большего размера, чтобы не выполнять никаких ограничений памяти в системе.
   - Задайте время истечения срока действия ключей, чтобы они вытеснялись заранее.
   - Отслеживайте метрику кэша `used_memory_rss`. Если это значение приближается к размеру кэша, скорее всего, вы начнете просматривать проблемы с производительностью. Распределите данные по нескольким сегментам, если вы используете кэш уровня "Премиум", или обновите до большего размера кэша.

   Дополнительные сведения см. [в разделе нехватка памяти на сервере Redis](cache-troubleshoot-server.md#memory-pressure-on-redis-server).

## <a name="additional-information"></a>Дополнительная информация

- [Устранение неполадок, связанных с кэшем Azure для Redis на стороне клиента](cache-troubleshoot-client.md)
- [Устранение неполадок в кэше Azure для Redis неполадок на стороне сервера](cache-troubleshoot-server.md)
- [Как измерить и протестировать производительность моего кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
- [Как отслеживать кэш Redis для Azure?](cache-how-to-monitor.md)
