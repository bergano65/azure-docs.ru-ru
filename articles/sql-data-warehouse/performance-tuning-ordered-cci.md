---
title: Настройка производительности с упорядоченным кластеризованным индексом columnstore хранилища данных SQL Azure | Документация Майкрософт
description: Рекомендации и соображения, которые следует знать при использовании упорядоченного кластеризованного индекса columnstore для повышения производительности запросов.
services: sql-data-warehouse
author: XiaoyuMSFT
manager: craigg
ms.service: sql-data-warehouse
ms.topic: conceptual
ms.subservice: development
ms.date: 09/05/2019
ms.author: xiaoyul
ms.reviewer: nibruno; jrasnick
ms.openlocfilehash: 37d8f17e825daa3a1c160509b1a38f8c70256d1c
ms.sourcegitcommit: b4f201a633775fee96c7e13e176946f6e0e5dd85
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2019
ms.locfileid: "72595369"
---
# <a name="performance-tuning-with-ordered-clustered-columnstore-index"></a>Настройка производительности с упорядоченным кластеризованным индексом columnstore  

Когда пользователи запрашивают таблицу columnstore в хранилище данных SQL Azure, оптимизатор проверяет минимальное и максимальное значения, хранящиеся в каждом сегменте.  Сегменты, находящиеся вне границ предиката запроса, не считываются с диска в память.  Запрос может повысить производительность, если количество сегментов для чтения и их общий размер невелики.   

## <a name="ordered-vs-non-ordered-clustered-columnstore-index"></a>Упорядоченный и неупорядоченный кластеризованный индекс columnstore 
По умолчанию для каждой таблицы хранилища данных Azure, созданной без параметра индекса, внутренний компонент (построитель индексов) создает на нем неупорядоченный кластеризованный индекс columnstore (CCI).  Данные в каждом столбце сжимаются в отдельный сегмент группы строк CCI.  Существуют метаданные для диапазона значений каждого сегмента, поэтому сегменты, находящиеся вне границ предиката запроса, не считываются с диска во время выполнения запроса.  CCI обеспечивает наивысший уровень сжатия данных и уменьшает размер сегментов для чтения, чтобы запросы могли выполняться быстрее. Однако поскольку построитель индексов не сортирует данные перед их сжатием в сегменты, могут возникать сегменты с перекрывающимися диапазонами значений, что приводит к тому, что запросы считывают больше сегментов с диска и занимают больше времени для завершения.  

При создании упорядоченного объекта CCI подсистема хранилища данных SQL Azure сортирует существующие данные в памяти по ключам порядка, прежде чем построитель индексов сжимает их в сегменты индекса.  При использовании отсортированных данных перекрытие сегментов сокращается, позволяя запросам использовать более эффективное исключение сегментов и, таким образом, более высокую производительность, поскольку количество сегментов для чтения с диска меньше.  Если все данные могут быть отсортированы в памяти одновременно, перекрытие сегментов можно избежать.  Учитывая большой размер данных в таблицах хранилища данных, этот сценарий не происходит часто.  

Чтобы проверить диапазоны сегментов для столбца, выполните следующую команду с именем таблицы и именем столбца:

```sql
SELECT o.name, pnp.index_id, cls.row_count, pnp.data_compression_desc, pnp.pdw_node_id, 
pnp.distribution_id, cls.segment_id, cls.column_id, cls.min_data_id, cls.max_data_id, cls.max_data_id-cls.min_data_id as difference
FROM sys.pdw_nodes_partitions AS pnp
   JOIN sys.pdw_nodes_tables AS Ntables ON pnp.object_id = NTables.object_id AND pnp.pdw_node_id = NTables.pdw_node_id
   JOIN sys.pdw_table_mappings AS Tmap  ON NTables.name = TMap.physical_name AND substring(TMap.physical_name,40, 10) = pnp.distribution_id
   JOIN sys.objects AS o ON TMap.object_id = o.object_id
   JOIN sys.pdw_nodes_column_store_segments AS cls ON pnp.partition_id = cls.partition_id AND pnp.distribution_id  = cls.distribution_id
   JOIN sys.columns as cols ON o.object_id = cols.object_id AND cls.column_id = cols.column_id
WHERE o.name = '<Table_Name>' and cols.name = '<Column_Name>' 
ORDER BY o.name, pnp.distribution_id, cls.min_data_id

```

> [!NOTE] 
> В упорядоченной таблице CCI новые данные, полученные из операций DML или загрузки данных, не сортируются автоматически.  Пользователи могут перестроить упорядоченный объект CCI для сортировки всех данных в таблице.  В хранилище данных SQL Azure перестроение индекса columnstore является автономной операцией.  Для секционированной таблицы перестроение выполняется по одной секции за раз.  Данные в перестроенной секции находятся в автономном режиме и недоступны до завершения перестроения для этого раздела. 

## <a name="query-performance"></a>Производительность запросов

Увеличение производительности запроса от упорядоченного объекта CCI зависит от шаблонов запросов, размера данных, объема отсортированных данных, физической структуры сегментов, а также класса DWU и ресурсов, выбранных для выполнения запроса.  Прежде чем выбирать столбцы упорядочения при проектировании упорядоченной таблицы CCI, пользователям следует ознакомиться со всеми этими факторами.

Запросы со всеми этими шаблонами обычно выполняются быстрее с упорядоченным CCI.  
1. Запросы имеют предикаты равенства, неравенства или диапазона
1. Столбцы предиката и упорядоченные столбцы CCI одинаковы.  
1. Столбцы предиката используются в том же порядке, что и порядковый номер столбца в упорядоченных столбцах CCI.  
 
В этом примере в таблице T1 имеется кластеризованный индекс columnstore, упорядоченный в последовательности Col_C, Col_B и Col_A.

```sql

CREATE CLUSTERED COLUMNSTORE INDEX MyOrderedCCI ON  T1
ORDER (Col_C, Col_B, Col_A)

```

Производительность запроса 1 может повыситься от заказанного объекта CCI, отличного от других 3 запросов. 

```sql
-- Query #1: 

SELECT * FROM T1 WHERE Col_C = 'c' AND Col_B = 'b' AND Col_A = 'a';

-- Query #2

SELECT * FROM T1 WHERE Col_B = 'b' AND Col_C = 'c' AND Col_A = 'a';

-- Query #3
SELECT * FROM T1 WHERE Col_B = 'b' AND Col_A = 'a';

-- Query #4
SELECT * FROM T1 WHERE Col_A = 'a' AND Col_C = 'c';

```

## <a name="data-loading-performance"></a>Производительность загрузки данных

Производительность загрузки данных в упорядоченную таблицу CCI аналогична секционированной таблице.  Загрузка данных в упорядоченную таблицу CCI может занять больше времени, чем неупорядоченная таблица CCI, из-за операции сортировки данных, однако запросы могут выполняться быстрее с упорядоченным CCI.  

Ниже приведен пример сравнения производительности при загрузке данных в таблицы с разными схемами.

![Performance_comparison_data_loading](media/performance-tuning-ordered-cci/cci-data-loading-performance.png)


Ниже приведен пример сравнения производительности между CCI и заказанным CCI.

![Performance_comparison_data_loading](media/performance-tuning-ordered-cci/occi_query_performance.png)

 
## <a name="reduce-segment-overlapping"></a>Уменьшить перекрытие сегментов

Число перекрывающихся сегментов зависит от размера данных для сортировки, объема доступной памяти и параметра максимальной степени параллелизма (MAXDOP) во время упорядоченного создания CCI. Ниже приведены параметры для уменьшения перекрытия сегмента при создании упорядоченного CCI.

- Используйте класс ресурсов xlargerc в более высоком DWU, чтобы обеспечить больше памяти для сортировки данных перед тем, как построитель индексов сжимает данные в сегменты.  В сегменте индекса невозможно изменить физическое расположение данных.  Отсутствует сортировка данных внутри сегмента или между сегментами.  

- Создайте упорядоченный CCI с MAXDOP = 1.  Каждый поток, используемый для упорядочения создания CCI, работает с подмножеством данных и сортирует его локально.  Нет глобальной сортировки по данным, отсортированным различными потоками.  Использование параллельных потоков позволяет сократить время создания упорядоченного объекта CCI, но создаст более пересекающиеся сегменты, чем использование одного потока.  В настоящее время параметр MAXDOP поддерживается только при создании упорядоченной таблицы CCI с помощью CREATE TABLE в качестве команды SELECT.  Создание упорядоченного объекта CCI с помощью команд CREATE INDEX или CREATE TABLE не поддерживает параметр MAXDOP. Например,

```sql
CREATE TABLE Table1 WITH (DISTRIBUTION = HASH(c1), CLUSTERED COLUMNSTORE INDEX ORDER(c1) )
AS SELECT * FROM ExampleTable
OPTION (MAXDOP 1);
```
- Предварительная сортировка данных по ключам сортировки перед их загрузкой в таблицы хранилища данных SQL Azure.


Ниже приведен пример упорядоченного распределения таблицы CCI с нулевым сегментом, перекрывающимся по приведенным выше рекомендациям. Упорядоченная таблица CCI создается в базе данных DWU1000c с помощью CTAS из таблицы 20 ГБ Heap, использующей MAXDOP 1 и xlargerc.  CCI упорядочивается по столбцу BIGINT без повторяющихся значений.  

![Segment_No_Overlapping](media/performance-tuning-ordered-cci/perfect-sorting-example.png)

## <a name="create-ordered-cci-on-large-tables"></a>Создание упорядоченного CCI в больших таблицах
Создание упорядоченного объекта CCI является автономной операцией.  Для таблиц без секций данные не будут доступны пользователям до тех пор, пока не завершится упорядоченный процесс создания CCI.   Для секционированных таблиц, так как подсистема создает упорядоченную секцию CCI по секциям, пользователи по-прежнему могут обращаться к данным в секциях, где упорядоченное создание CCI не выполняется.   С помощью этого параметра можно сократить время простоя при упорядоченном создании CCI в больших таблицах: 

1.  Создайте секции в целевой большой таблице (с именем Table_A).
2.  Создайте пустую упорядоченную таблицу CCI (с именем Table_B) с той же таблицей и схемой секционирования, что и таблица A.
3.  Переключение одной секции из таблицы A в таблицу B.
4.  Выполните инструкцию ALTER INDEX < Ordered_CCI_Index > ON < Table_B > Rebuild PARTITION = < Partition_ID > в таблице B, чтобы перестроить включенный в нее раздел.  
5.  Повторите шаги 3 и 4 для каждой секции в Table_A.
6.  После переключения всех секций с Table_A на Table_B и их перестроения, удаления Table_A и переименования Table_B в Table_A. 

## <a name="examples"></a>Примеры

**А. Проверка упорядоченных столбцов и порядкового номера заказа:**
```sql
SELECT object_name(c.object_id) table_name, c.name column_name, i.column_store_order_ordinal 
FROM sys.index_columns i 
JOIN sys.columns c ON i.object_id = c.object_id AND c.column_id = i.column_id
WHERE column_store_order_ordinal <>0
```

**Б. чтобы изменить порядковый номер столбца, добавьте или удалите столбцы из списка Order или измените значение с CCI на упорядоченный CCI:**
```sql
CREATE CLUSTERED COLUMNSTORE INDEX InternetSales ON  InternetSales
ORDER (ProductKey, SalesAmount)
WITH (DROP_EXISTING = ON)
```

## <a name="next-steps"></a>Дальнейшие действия
Дополнительные советы по разработке см. в статье [Проектные решения и методики программирования для хранилища данных SQL](sql-data-warehouse-overview-develop.md).
