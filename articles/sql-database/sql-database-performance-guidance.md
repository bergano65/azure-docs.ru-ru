---
title: Руководство по настройке производительности
description: Сведения об использовании рекомендаций по ручной настройке производительности запросов базы данных SQL Azure.
services: sql-database
ms.service: sql-database
ms.subservice: performance
ms.custom: ''
ms.devlang: ''
ms.topic: conceptual
author: juliemsft
ms.author: jrasnick
ms.reviewer: carlrab
ms.date: 01/25/2019
ms.openlocfilehash: 6e42911d05f387ea47b56b913e9a1868100c1b3c
ms.sourcegitcommit: ac56ef07d86328c40fed5b5792a6a02698926c2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/08/2019
ms.locfileid: "73821363"
---
# <a name="manual-tune-query-performance-in-azure-sql-database"></a>Ручная настройка производительности запросов в Базе данных SQL Azure

Выявив проблему с производительностью, возникшую для базы данных SQL, обратитесь к этой статье:

- Настройте приложение и примените некоторые рекомендации, которые могут увеличить производительность.
- Настройте базу данных, изменив индексы и запросы, чтобы повысить эффективность работы с данными.

В этой статье предполагается, что вы уже проработали [рекомендации Помощника по базам данных](sql-database-advisor.md) для Базы данных SQL Azure, а также [рекомендации по автоматической настройке](sql-database-automatic-tuning.md) для базы данных SQL Azure. В ней также предполагается, что вы ознакомились с [общими сведениями о мониторинге и настройке](sql-database-monitor-tune-overview.md) и другими статьями, описывающими устранение проблем с производительностью. Кроме того, в этой статье предполагается, что у вас нет ресурсов ЦП, а также проблемы производительности, которую можно устранить, увеличив объем вычислений или уровень служб, чтобы предоставить дополнительные ресурсы для базы данных.

## <a name="tune-your-application"></a>Настройка приложения

В традиционной локальной среде SQL Server процесс изначального планирования загрузки часто отделен от процесса запуска приложения в рабочей среде. Сначала приобретаются лицензии на оборудование и продукт, а затем настраивается производительность. При использовании Базы данных SQL Azure рекомендуется объединить процессы настройки и запуска приложения. Оплата только за используемые ресурсы позволяет настраивать приложение на использование минимального объема ресурсов, которые нужны в данный момент, а не выполнять избыточную подготовку согласно прогнозам будущего роста нагрузки на приложение, так как такие прогнозы часто ошибочны. Некоторые пользователи предпочитают не настраивать приложение и вместо этого используют избыточную подготовку ресурсов оборудования. Этот подход может подойти, если вы не желаете изменять ключевое приложение в период высокой нагрузки. Но настройка приложения позволяет минимизировать потребление ресурсов и снизить ежемесячные расходы благодаря новым уровням служб в Базе данных SQL Azure.

### <a name="application-characteristics"></a>Характеристики приложения

Уровни служб Базы данных SQL Azure предназначены для оптимизации стабильности и предсказуемости производительности приложения. Вместе с тем с помощью некоторых рекомендаций по настройке приложения можно настроить приложение для максимально эффективного использования ресурсов при определенном объеме вычислительных ресурсов. Многие приложения получают значительный прирост производительности после простого перехода на более высокий объем вычислительных ресурсов или уровень служб, в то время как для лучшей работы других приложений на новом уровне требуется дополнительная настройка. Для повышения производительности приложений со следующими характеристиками необходима дополнительная настройка:

- **Приложения с низкой производительностью из-за "нестабильной" работы**.

  Возможно, в такие приложения понадобится внести изменения, сократив число операций доступа к данным в Базе данных SQL. Например, производительность приложения можно улучшить за счет пакетной обработки нерегламентированных запросов или перемещения запросов в хранимые процедуры. Например, вы можете повысить производительность приложения с помощью таких методов, как пакетирование нерегламентированных запросов или перемещение запросов в хранимые процедуры. в разделе [Пакетные запросы](#batch-queries).

- **Базы данных с интенсивной рабочей нагрузкой, которые не могут работать на одном компьютере**.

   Базам данных, которые превышают использование ресурсов при использовании наивысшего объема вычислительных ресурсов уровня служб "Премиум", может быть полезно масштабировать рабочие нагрузки. Дополнительные сведения см. в разделах [Сегментирование баз данных](#cross-database-sharding) и [Функциональное секционирование](#functional-partitioning).

- **Приложения с неоптимальными запросами**.

  Приложения, особенно те, которые на уровне доступа к данным, используют плохо настроенные запросы, могут не получить выгоды за счет использования высокого объема вычислительных ресурсов. Больше пользы таким приложениям приносят стандартные методы оптимизации производительности запросов. Дополнительные сведения см. Дополнительные сведения см. в разделах [Отсутствующие индексы](#identifying-and-adding-missing-indexes) и [Настройка запросов и указания на них](#query-tuning-and-hinting).

- **Приложения с неоптимальной схемой доступа к данным**.

   Приложениям, в которых есть проблемы параллельного доступа к данным, например взаимоблокировка, нецелесообразно увеличивать объем вычислительных ресурсов. Рекомендуем уменьшить количество круговых путей к базе данных SQL Azure с помощью кэширования данных на стороне клиента, используя службу кэша Azure или другую технологию кэширования. раздел [Кэширование на уровне приложения](#application-tier-caching).

## <a name="tune-your-database"></a>Настройка базы данных

В этом разделе рассматриваются некоторые методы, которые можно использовать для настройки Базы данных SQL Azure с целью повышения производительности приложения и использования наименьшего объема вычислительных ресурсов. Некоторые из этих методов совпадают с традиционными рекомендациями по настройке SQL Server, однако есть и специфические методы настройки базы данных SQL Azure. В некоторых случаях можно изучить использование ресурсов в базе данных, чтобы настроить и улучшить традиционные методы SQL Server для работы в Базе данных SQL Azure.

### <a name="identifying-and-adding-missing-indexes"></a>Определение и добавление недостающих индексов

Одна из распространенных проблем производительности баз данных OLTP связана с физической схемой базы данных. Часто схемы базы данных создаются и поставляются без проверки масштабируемости по нагрузке или объему данных. К сожалению, производительность плана запроса, приемлемая при небольшом масштабе, может существенно снижаться при использовании объема данных уровня большой компании. Самый распространенный источник проблем связан с отсутствием индексов, которые позволили бы сортировать и ограничивать данные в запросе. Часто при этом сканируется вся таблица, в то время как поиска по индексу было бы достаточно.

В этом примере в выбранном плане запроса используется сканирование, хотя здесь было бы достаточно поиска.

```sql
DROP TABLE dbo.missingindex;
CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
DECLARE @a int = 0;
SET NOCOUNT ON;
BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO dbo.missingindex(col2) VALUES (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION;
    GO
SELECT m1.col1
    FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
    WHERE m1.col2 = 4;
```

![План запроса c отсутствующими индексами](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

База данных SQL Azure может помочь выявить условия, при которых индекс становится необходимым. Динамические административные представления, встроенные в Базу данных SQL Azure, учитывают во время компиляции запроса случаи, когда индекс мог бы значительно снизить стоимость, связанную с выполнением запроса. Во время выполнения запроса База данных SQL отслеживает, как часто выполнялся план запроса, а также вычисляет разницу между выполненным планом запроса и возможным планом с индексом. Эти представления можно использовать, чтобы быстро выяснить, какие изменения схемы базы данных могли бы существенно уменьшить рабочую нагрузку для базы данных.

Этот запрос можно использовать для оценки потенциально отсутствующих индексов:

```sql
SELECT
   CONVERT (varchar, getdate(), 126) AS runtime
   , mig.index_group_handle
   , mid.index_handle
   , CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
        (migs.user_seeks + migs.user_scans)) AS improvement_measure
   , 'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
        CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
        (' + ISNULL (mid.equality_columns,'')
        + CASE WHEN mid.equality_columns IS NOT NULL
        AND mid.inequality_columns IS NOT NULL
        THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '') + ')'
        + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement
   , migs.*
   , mid.database_id
   , mid.[object_id]
FROM sys.dm_db_missing_index_groups AS mig
   INNER JOIN sys.dm_db_missing_index_group_stats AS migs
      ON migs.group_handle = mig.index_group_handle
   INNER JOIN sys.dm_db_missing_index_details AS mid
      ON mig.index_handle = mid.index_handle
 ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC
```

В этом примере при выполнении запроса возникло такое предложение:

```sql
CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  
```

После его создания инструкция SELECT выбирает другой план, в котором используется поиск вместо сканирования, а затем выполняет план более эффективно.

![План запроса c исправленными индексами](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

Важно понимать, что пропускная способность общей среды более ограничена, чем пропускная способность выделенного сервера. Вы можете минимизировать избыточное число операций ввода-вывода и максимально использовать ресурсы каждого объема вычислительных ресурсов, доступные в рамках уровней служб "База данных SQL Azure". Улучшение физической схемы базы данных может значительно уменьшить задержку для определенных запросов, улучшить пропускную способность при параллельных запросах, обрабатываемых на единицу масштабирования, и минимизировать затраты, необходимые на выполнение одного запроса. Дополнительные сведения о динамических административных представлениях для отсутствующих индексов см. в разделе [sys.dm_db_missing_index_details](https://msdn.microsoft.com/library/ms345434.aspx).

### <a name="query-tuning-and-hinting"></a>Настройка запросов и указания на них

Оптимизатор запросов в Базе данных SQL Azure напоминает традиционный оптимизатор запросов SQL Server. Большинство рекомендаций по настройке запросов и ограничения оптимизатора запросов применимы к Базе данных SQL Azure. Настроив запросы в Базе данных SQL Azure, можно снизить общие требования к ресурсам. С помощью настройки можно снизить затраты на приложение, так как в результате можно будет использовать более низкий объем вычислительных ресурсов.

Примером является то, как оптимизатор запросов вносит параметры "на лету". Это распространено в SQL Server и также применяется к Базе данных SQL Azure. Во время компиляции оптимизатор запросов вычисляет текущее значение параметра с целью создания более оптимального плана запроса. Хотя такая стратегия часто позволяет создать более быстрый план запроса, чем план, скомпилированный без известных значений параметров, сейчас в SQL Server и Базе данных SQL Azure она работает несовершенно. Иногда параметр сканируется, а иногда нет, но при этом созданный план неэффективен для полного набора значений параметров в рабочей нагрузке. Майкрософт предусматривает использование указаний запросов (директив), которые позволяют указать, следует ли изменить поведение по умолчанию. Часто использование указаний позволяет устранить проблемы, когда работа SQL Server и Базы данных SQL Azure не подходит для конкретной рабочей нагрузки.

В следующем примере показано, как обработчик запросов может создать план, который не соответствует требованиям к производительности и ресурсам. В этом примере также показано, что при использовании указания запроса можно сократить время выполнения запроса и снизить требования к ресурсам для Базы данных SQL.

```sql
DROP TABLE psptest1;
CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));
DECLARE @a int = 0;
SET NOCOUNT ON;
BEGIN TRANSACTION
   WHILE @a < 20000
   BEGIN
     INSERT INTO psptest1(col2) values (1);
     INSERT INTO psptest1(col2) values (@a);
     SET @a += 1;
   END
   COMMIT TRANSACTION
   CREATE INDEX i1 on psptest1(col2);
GO

CREATE PROCEDURE psp1 (@param1 int)
   AS
   BEGIN
      INSERT INTO t1 SELECT * FROM psptest1
      WHERE col2 = @param1
      ORDER BY col2;
    END
    GO

CREATE PROCEDURE psp2 (@param2 int)
   AS
   BEGIN
      INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
      ORDER BY col2
      OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
   END
   GO

CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
GO
```

Код установки создает таблицу с неравномерным распределением данных. Оптимальный план запроса зависит от выбранного параметра. К сожалению, при кэшировании плана запрос не всегда повторно компилируется в зависимости от наиболее подходящего значения параметра. Таким образом, может получиться так, что будет кэширован неоптимальный план, который будет использоваться во многих случаях, когда можно было бы использовать более эффективный план. После этого план запроса создает две хранимые процедуры, которые идентичны друг другу, за исключением того, что одна из них содержит специальное указание запроса.

```sql
-- Prime Procedure Cache with scan plan
EXEC psp1 @param1=1;
TRUNCATE TABLE t1;

-- Iterate multiple times to show the performance difference
DECLARE @i int = 0;
WHILE @i < 1000
   BEGIN
      EXEC psp1 @param1=2;
      TRUNCATE TABLE t1;
      SET @i += 1;
    END
```

Прежде чем приступать ко второй части примера, мы советуем подождать около 10 минут, чтобы в итоговых данных телеметрии результаты были очевидными.

```sql
EXEC psp2 @param2=1;
TRUNCATE TABLE t1;

DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp2 @param2=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END
```

Каждая часть примера пытается выполнить параметризованную вставку 1000 раз (это необходимо для создания достаточной нагрузки). При выполнении хранимых процедур обработчик запросов проверяет значение параметра, переданное в процедуру во время первой компиляции ("вставка на лету"). Обработчик кэширует результирующий план и использует его в дальнейшем, даже если значение параметра будет другим. Оптимальный план может подойти не для всех случаев. Иногда нужно указывать оптимизатору, какой план выбрать, чтобы этот план был относительно универсальным, а не просто подходящим для определенного случая, когда впервые происходит компиляция запроса. В этом примере изначальный план создает сканирование, при котором считываются все строки, чтобы найти значение, которое отвечает параметру.

![Настройка запроса с использованием плана сканирования](./media/sql-database-performance-guidance/query_tuning_1.png)

Так как процедура выполнена с использованием значения 1, результирующий план был оптимальным для значения 1, но неоптимальным для всех остальных значений в таблице. Если вы будете выбирать каждый план случайным образом, скорее всего, результат не будет оптимальным, так как план будет выполняться медленнее и задействовать больше ресурсов.

При выполнении теста с параметром `SET STATISTICS IO` со значением `ON` логическое сканирование в этом примере будет проходить в фоновом режиме. Вы можете увидеть, что план выполнил 1148 операций чтения (что является неэффективным, если обычно нужно вернуть только одну строку).

![Настройка запроса с использованием логического сканирования](./media/sql-database-performance-guidance/query_tuning_2.png)

Во второй части примера используется указание запроса, которое позволяет дать оптимизатору инструкцию использовать конкретное значение во время компиляции. В этом случае обработчик запросов принудительно игнорирует значение, которое передается в качестве параметра, и вместо этого использует значение `UNKNOWN`. Это значение со средней частотой в таблице (независимо от искажения распределения). В результате мы получим план на основе поиска, который работает быстрее и использует меньше ресурсов, чем план из части 1 этого примера.

![Настройка запроса с помощью указания запроса](./media/sql-database-performance-guidance/query_tuning_3.png)

Просмотреть результат можно в таблице **sys.resource_stats** (между временем выполнения теста и появлением данных в таблице есть задержка). В этом примере первая часть выполнялась в рамках временного окна 22:25:00, а вторая часть — в 22:35:00. В первой части использовано больше ресурсов, чем во второй (в силу повышения эффективности).

```sql
SELECT TOP 1000 *
FROM sys.resource_stats
WHERE database_name = 'resource1'
ORDER BY start_time DESC
```

![Пример результатов настройки запроса](./media/sql-database-performance-guidance/query_tuning_4.png)

> [!NOTE]
> В этом примере преднамеренно использовались небольшие значения, однако последствия неоптимальных параметров могут быть существенными, особенно для больших баз данных. Разница для быстрых и медленных запросов в некоторых случаях может достигать от нескольких секунд до нескольких часов.

Вы можете просмотреть таблицу **sys.resource_stats**, чтобы определить, использует ли один тест больше ресурсов, чем другой. При сравнении данных между тестами необходимо установить интервалы, чтобы они не группировались в одном 5-минутном окне в представлении **sys.resource_stats**. Цель расчетов — минимизировать общее использование ресурсов, а не пиковую нагрузку. Обычно оптимизация части кода с целью уменьшения задержки выполнения также приводит к сокращению использования ресурсов. Убедитесь, что изменения, внесенные в приложение, необходимы и что они не оказывают негативное влияние на работу приложения при использовании указаний запроса.

Если рабочая нагрузка содержит ряд повторяющихся запросов, то часто бывает целесообразно отследить и проверить оптимальность планов, так как это позволит уменьшить минимальный размер ресурсов, необходимых базе данных. После проверки иногда пересматривайте планы, чтобы убедиться, что их производительность не ухудшилась. Дополнительные сведения об указаниях запроса (Transact-SQL) см. [в этой статье](https://msdn.microsoft.com/library/ms181714.aspx).

### <a name="cross-database-sharding"></a>Сегментирование баз данных

Так как База данных SQL Azure выполняется на стандартном оборудовании, ограничения емкости для отдельной базы данных будут ниже, чем в традиционной локальной среде SQL Server. Некоторые пользователи используют техники сегментирования, чтобы расширить операции базы данных среди нескольких баз данных, если размеры в пределах границы отдельной базы данных не соответствуют в Базе данных SQL Azure. Большинство клиентов, использующих сегментирование в Базе данных SQL Azure, разбивают данные одного измерения на несколько баз данных. При использовании этого подхода необходимо понимать, что часто приложения OLTP выполняют транзакции, которые применимы только к одной строке или небольшой группе строк внутри одной схемы.

> [!NOTE]
> База данных SQL теперь предоставляет библиотеку для упрощения сегментирования. Дополнительные сведения см. в статье [Обзор клиентской библиотеки для эластичных баз данных](sql-database-elastic-database-client-library.md).

Например, если база данных содержит сведения об имени клиента, заказе и цене (как можно увидеть в стандартном примере базы данных Northwind, который используется для SQL Server), эти данные можно разбить на несколько баз данных, группируя вместе сведения о клиенте и заказе. Это гарантирует, что данные клиента останутся в пределах отдельной базы данных. Приложение должно разбивать заказчиков по разным базам данных и эффективно распределять нагрузку. В результате можно не только не превышать имеющееся ограничение максимального размера базы данных, но и обрабатывать в Базе данных SQL Azure рабочие нагрузки, которые существенно превышают ограничения различных объемов вычислительных ресурсов, если каждая отдельная база данных будет работать в соответствии с ограничениями DTU.

Несмотря на то что сегментирование баз данных не снижает общую нагрузку для решения, такой подход очень эффективен для поддержки очень больших решений, распределенных по нескольким базам данных. Каждую базу данных можно запускать с разным объемом вычислительных ресурсов для поддержки очень больших "эффективных" баз данных с высокими требованиями к ресурсам.

### <a name="functional-partitioning"></a>Функциональное секционирование

Пользователи SQL Server часто объединяют несколько функций в отдельной базе данных. Например, если приложение содержит логику управления запасами склада, то база данных может содержать логику, связанную с запасами, отслеживанием заказов на покупку, хранимыми процедурами, индексированными или материализованными представлениями для управления ежемесячными отчетами. Такой подход позволяет легко администрировать базы данных и выполнять такие операции, как резервное копирование. Однако в этом случае нужно также изменить размер оборудования, чтобы распределять пиковую нагрузку функций одного приложения.

Если в Базе данных SQL Azure используется масштабируемая архитектура, лучше распределить функции приложения по разным базам данных. При использовании этого метода приложения масштабируются независимо друг от друга. По мере повышения нагрузки на приложение (и нагрузки на базу данных) администратор сможет определить объемы вычислительных ресурсов отдельно для каждой функции одного приложения. Такая архитектура позволит приложению расширяться за пределы одного сервера за счет распределения нагрузки по разным серверам.

### <a name="batch-queries"></a>Пакетные запросы

Для приложений, которые получают доступ к данным с использованием частых нерегламентированных запросов большого объема, время отклика значительно увеличивается за счет взаимодействия по сети между уровнем приложения и уровнем Базы данных SQL Azure. Даже если приложение и База данных SQL Azure находятся в одном центре обработки данных, сетевая задержка между ними может увеличиться пропорционально количеству операций доступа к данным. Чтобы уменьшить количество циклических операций доступа к данным, попробуйте выполнить пакетную обработку нерегламентированных запросов или скомпилировать их в качестве хранимых процедур. Если выполнить пакетную обработку нерегламентированных запросов, несколько запросов будут отсылаться как один большой пакет в Базу данных SQL Azure за одну операцию. Выполнив компилирование нерегламентированных запросов в одну хранимую процедуру, можно достигнуть того же результата, что и при пакетной обработке. Использование хранимой процедуры также позволяет расширить возможности кэширования планов запросов в Базе данных SQL Azure, чтобы снова использовать хранимую процедуру.

Некоторые приложения требуют большого количества операций записи. Иногда можно уменьшить общую нагрузку операций ввода-вывода на базы данных путем правильной пакетной обработки операций записи. Часто для этого нужно просто использовать явные транзакции вместо автоматических в хранимых процедурах и пакетах нерегламентированных запросов. Оценку различных подходов см. в статье [Как повысить производительность приложений базы данных SQL с помощью пакетной обработки](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx). Поэкспериментируйте со своей рабочей нагрузкой, чтобы найти оптимальную модель пакетной обработки. Необходимо учитывать, что гарантии согласованности транзакций разных моделей могут немного отличаться. Чтобы определить наиболее оптимальную рабочую нагрузку, которая минимизирует использование ресурсов, необходимо добиться правильного сочетания компромиссов согласованности и производительности.

### <a name="application-tier-caching"></a>Кэширование на уровне приложения

Некоторые приложения базы данных содержат рабочие нагрузки, выполняющие много операций чтения. Уровни кэширования могут снизить нагрузку на базу данных, а вслед за ней и объем вычислительных ресурсов, необходимый для поддержки базы данных с помощью Базы данных SQL Azure. [Кэш Azure для Redis](https://azure.microsoft.com/services/cache/)позволяет при рабочих нагрузках с большим количеством операций чтения считывать данные один раз (или, в зависимости от конфигурации, один раз на каждом сервере) и хранить их не в базе данных SQL. Это помогает снизить нагрузку на базу данных (загрузка ЦП и число операций ввода-вывода), однако это может повлиять на согласованность транзакций, так как данные в кэше могут быть не синхронизированы с данными в базе данных. Для многих приложений определенный уровень несогласованности приемлем, однако это подходит не для всех рабочих нагрузок. Мы советуем внимательно изучить требования к приложению, прежде чем использовать стратегию кэширования на уровне приложения.

## <a name="next-steps"></a>Дальнейшие действия

- Дополнительные сведения об уровнях служб на основе единиц DTU см. в статье о [модели приобретения на основе единиц DTU](sql-database-service-tiers-dtu.md).
- Дополнительные сведения об уровнях служб на основе виртуальных ядер см. в разделе [Модель приобретения на основе виртуальных ядер](sql-database-service-tiers-vcore.md).
- Дополнительные сведения о пулах эластичных баз данных Azure см. в статье [Что такое пул эластичных БД Azure?](sql-database-elastic-pool.md)
- Сведения о производительности и пулах эластичных баз данных см. в статье [Когда следует использовать эластичный пул?](sql-database-elastic-pool-guidance.md)