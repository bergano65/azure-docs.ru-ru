---
title: Сеансы обмена сообщениями служебной шины Azure | Документация Майкрософт
description: В этой статье описывается, как с помощью сеансов сообщений обеспечить согласованную и упорядоченную обработку несвязанных последовательностей связанных сообщений.
ms.topic: article
ms.date: 01/20/2021
ms.openlocfilehash: 6d316571d69d2e1e73ddca4ccca53c116ee8fa5f
ms.sourcegitcommit: b39cf769ce8e2eb7ea74cfdac6759a17a048b331
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/22/2021
ms.locfileid: "98680759"
---
# <a name="message-sessions"></a>Сеансы обмена сообщениями
Сеансы службы "Служебная шина Microsoft Azure" обеспечивают согласованную и упорядоченную обработку несвязанных последовательностей связанных сообщений. Сеансы можно использовать в методе **простой очередности (FIFO)** и методе **запроса и ответа**. В этой статье показано, как использовать сеансы для реализации этих методов при использовании Служебной шины. 

> [!NOTE]
> Ценовая категория "Базовый" Служебной шины не поддерживает сеансы, а категории "Стандартный" и "Премиум" — поддерживают. Различия между этими ценовыми категориями приведены на странице [цен на Служебную шину](https://azure.microsoft.com/pricing/details/service-bus/).

## <a name="first-in-first-out-fifo-pattern"></a>Метод простой очереди (FIFO)
Чтобы реализовать надежный механизм FIFO в Служебной шине, необходимо использовать сеансы. В Служебной шине не регламентируется характер связи между сообщениями и не указывается конкретная модель, определяющая, где начинается или заканчивается последовательность сообщений.

Любой отправитель может создать сеанс при отправке сообщений в очередь или раздел, задав свойству [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) какой-либо определяемый приложением идентификатор, уникальный в рамках сеанса. На уровне протокола AMQP 1.0 это значение соответствует свойству *group-id*.

В очередях или подписках с поддержкой сеансов сеансы создаются при наличии по крайней мере одного сообщения, для которого указан [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) сеанса. Для созданного сеанса нет определенного интервала времени или API, определяющего его срок действия или существования. Теоретически, сообщение для сеанса может быть получено сегодня, а следующее — через год, и если значение **SessionId** совпадает, то с точки зрения служебной шины это тот же самый сеанс.

Обычно в приложении четко определено, где начинается и заканчивается набор связанных сообщений. Однако Служебная шина не устанавливает какие-либо конкретные правила для этого.

Например, чтобы разграничить последовательность для передачи файла, можно задать для свойства **Label** первого сообщения значение **start**, для промежуточных сообщений задать для этого свойства значение **content**, а для последнего сообщения — значение **end**. Относительное положение сообщений с содержимым может быть вычислено как разница между значением *SequenceNumber* текущего сообщения и значением *SequenceNumber* сообщения **start**.

Функция сеансов в служебной шине позволяет выполнить специальную операцию получения посредством [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Для включения этой функции нужно задать свойство [requiresSession](/azure/templates/microsoft.servicebus/namespaces/queues#property-values) для очереди или подписки с помощью Azure Resource Manager или установить соответствующий флаг на портале. Это необходимо сделать прежде, чем пытаться использовать операции связанных API.

На портале флаг устанавливается с помощью следующего флажка:

![Снимок экрана: диалоговое окно "Создание очереди" с выбранным параметром "включить сеансы", выделенным красным цветом.][2]

> [!NOTE]
> Если сеансы включены в очередь или подписку, клиентские приложения могут * больше **не** отправлять и получать обычные сообщения. Все сообщения должны быть отправлены в рамках сеанса (путем установки идентификатора сеанса) и получены путем получения сеанса.

Интерфейсы API для сеансов существуют в клиентах очереди и подписки. Существует императивная модель, управляющая получением сеансов и сообщений, и модель на основе обработчиков, аналогичная _OnMessage *, которая скрывает сложность управления циклом получения.

### <a name="session-features"></a>Функции сеансов

Сеансы обеспечивают параллельное демультиплексирование потоков сообщений с сохранением и гарантией порядка доставки.

![Схема, показывающая, как функции сеансов сохраняют упорядоченную доставку.][1]

Получатель [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) создается клиентом, принимающим сеанс. Клиент вызывает [QueueClient.AcceptMessageSession](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesession#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSession) или [QueueClient.AcceptMessageSessionAsync](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesessionasync#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSessionAsync) в C#. В реактивной модели обратного вызова он регистрирует обработчик сеанса.

Когда объект [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) принимается и хранится в клиенте, этот клиент накладывает монопольную блокировку на все сообщения со значением [SessionId](/dotnet/api/microsoft.servicebus.messaging.messagesession.sessionid#Microsoft_ServiceBus_Messaging_MessageSession_SessionId) этого сеанса, имеющиеся в очереди или подписке, а также на все сообщения с этим значением **SessionId**, которые продолжают поступать во время сеанса.

Блокировка снимается, когда вызывается функция **Close** или **CloseAsync**. Если же приложение не может выполнить операцию закрытия, блокировка снимается, когда истекает ее срок действия. Блокировка сеанса должна рассматриваться как монопольная блокировка файла. Это означает, что приложение должно закрыть сеанс, как только он стал не нужен и (или) оно не ожидает поступления новых сообщений.

Когда несколько параллельных получателей извлекают сообщения из очереди, сообщения, относящиеся к определенному сеансу, отправляются в конкретный получатель, который в настоящее время наложил блокировку для этого сеанса. Благодаря этой операции поток сообщений с чередованием, находящийся в одной очереди или подписке, четко демультиплексируется для различных получателей. Эти получатели могут находиться на разных клиентских компьютерах, так как управление блокировкой осуществляется на стороне службы, внутри Служебной шины.

На предыдущем рисунке показано три параллельных приемника сеансов. У одного сеанса с `SessionId` = 4 нет активного владеющего клиента. Это означает, что сообщения не будут доставлены из этого конкретного сеанса. Сеанс работает по-разному, как и подочередь.

Блокировка сеанса, накладываемая получателем сеанса, — это "зонтик" для блокировки сообщений, используемый для режима согласования *PeekLock*. Только один получатель может блокировать сеанс. У получателя может быть много поступающих сообщений, но эти сообщения будут получены по порядку. Если сообщение отбрасывается, то это же сообщение обслуживается повторно при следующей операции получения.

### <a name="message-session-state"></a>Состояние сеанса обмена сообщениями

При обработке рабочих процессов в крупномасштабных высокодоступных облачных системах обработчик рабочих процессов, связанный с определенным сеансом, должен обладать механизмами восстановления после непредвиденных сбоев, а также иметь возможность возобновлять частично выполненную работу в другом процессе или на другом компьютере.

Функция состояния сеанса позволяет добавлять определяемые приложением заметки для сеанса обмена сообщениями внутри брокера, чтобы записанное состояние обработки, относящееся к этому сеансу, становилось мгновенно доступным при получении этого сеанса новым обработчиком.

С точки зрения служебной шины состояние сеанса обмена сообщениями — непрозрачный двоичный объект, который может содержать данные, размер которых равен размеру одного сообщения, что составляет 256 КБ для служебной шины категории "Стандартный" и 1 МБ для служебной шины категории "Премиум". Состояние обработки относительно сеанса может сохраняться в состоянии сеанса, или состояние сеанса может указывать на некоторое место хранения либо запись базы данных, где содержатся эти сведения.

Интерфейсы API для управления состоянием сеанса, [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) и [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate#Microsoft_ServiceBus_Messaging_MessageSession_GetState), можно найти в объекте [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Сеанс, для которого ранее не было задано состояние сеанса, возвращает в интерфейс API **GetState** **пустую** ссылку. Очистка заданного ранее состояния сеанса выполняется с помощью [SetState(null)](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_).

Состояние сеанса не изменяется до очистки (возвращается значение **NULL**), даже если потреблены все сообщения в сеансе.

Все существующие сеансы в очереди или подписке могут быть перечислены с помощью метода **SessionBrowser** в интерфейсе API Java и с помощью метода [GetMessageSessions](/dotnet/api/microsoft.servicebus.messaging.queueclient.getmessagesessions#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessions) в интерфейсах API [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) и [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) в клиенте .NET Framework.

Состояние сеанса, хранящееся в очереди или подписке, учитывается при подсчете квоты хранилища этой сущности. Поэтому, когда приложение завершает работу с сеансом, рекомендуется очищать его сохраненное состояние, чтобы избежать затрат на внешнее управление.

### <a name="impact-of-delivery-count"></a>Влияние числа доставок

Определение числа доставок на сообщение в контексте сеансов немного отличается от определения в случае отсутствия сеансов. Ниже приведена таблица, в которой кратко описывается, когда число доставок увеличивается.

| Сценарий | Число доставок сообщений увеличивается |
|----------|---------------------------------------------|
| Сеанс был принят, но блокировка сеанса истекла (из-за превышения времени ожидания). | Да |
| Сеанс был принят, сообщения в сеансе не были обработаны (даже если они заблокированы) и сеанс был закрыт. | Нет |
| Сеанс был принят, сообщения были обработаны, а затем сеанс был явным образом закрыт. | Недоступно (это стандартный поток; здесь сообщения удаляются из сеанса). |

## <a name="request-response-pattern"></a>Метод "запроса и ответа"
[Метод запроса и ответа](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html) — это общепринятая модель интеграции, которая позволяет приложению-отправителю передать запрос и предоставляет получателю возможность правильно отправить ответ в приложение-отправитель. Для этой модели обычно требуется кратковременная очередь или раздел, в который приложение отправляет ответы. В этом сценарии сеансы представляют собой простое альтернативное решение со сравнимой семантикой. 

Несколько приложений могут отправлять запросы в одну очередь запросов с заданным параметром заголовка, который уникально идентифицирует приложение-отправитель. Приложение-получатель может обрабатывать запросы, поступающие в очередь, и отправлять ответы в очередь с поддержкой сеансов, задавая для идентификатора сеанса значение уникального идентификатора, переданного отправителем в сообщении запроса. Приложение, которое отправило запрос, может затем принимать сообщения по определенному идентификатору сеанса и правильно обрабатывать ответы.

> [!NOTE]
> Приложение, которое отправляет первоначальные запросы, должно знать этот идентификатор сеанса и использовать `SessionClient.AcceptMessageSession(SessionID)` для блокировки сеанса, в котором оно ожидает ответ. В качестве идентификатора сеанса рекомендуется использовать идентификатор GUID, который уникальным образом идентифицирует экземпляр приложения. В очереди не должно быть обработчиков сеансов или `AcceptMessageSession(timeout)`, чтобы обеспечить блокировку и обработку ответов соответствующими получателями.

## <a name="next-steps"></a>Дальнейшие действия

- Примеры использования клиента .NET Framework для обработки сообщений с поддержкой сеансов можно изучить в этих разделах: [Примеры для Microsoft.Azure.ServiceBus](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.Azure.ServiceBus/Sessions) и [Примеры для Microsoft.ServiceBus.Messaging](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/Sessions). 

Дополнительные сведения об обмене сообщениями через служебную шину см. в следующих статьях:

* [Очереди, разделы и подписки служебной шины](service-bus-queues-topics-subscriptions.md)
* [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md)
* [Как использовать разделы и подписки служебной шины](service-bus-dotnet-how-to-use-topics-subscriptions.md)

[1]: ./media/message-sessions/sessions.png
[2]: ./media/message-sessions/queue-sessions.png
