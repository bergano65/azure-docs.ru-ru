---
title: Краткое руководство. Использование очередей Служебной шины Azure с Python
description: Узнайте, как использовать очереди Служебной шины Azure с Python.
services: service-bus-messaging
documentationcenter: python
author: axisc
manager: timlt
editor: spelluru
ms.assetid: b95ee5cd-3b31-459c-a7f3-cf8bcf77858b
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: python
ms.topic: quickstart
ms.date: 11/05/2019
ms.author: aschhab
ms.custom: seo-python-october2019
ms.openlocfilehash: d0f579fcd82860380f1aaa651a61c0259d075a0d
ms.sourcegitcommit: 827248fa609243839aac3ff01ff40200c8c46966
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73748528"
---
# <a name="quickstart-use-azure-service-bus-queues-with-python"></a>Краткое руководство. Использование очередей Служебной шины Azure с Python

[!INCLUDE [service-bus-selector-queues](../../includes/service-bus-selector-queues.md)]

Из этой статьи вы узнаете, как с помощью Python создавать очереди Служебной шины Azure, отправлять в них сообщения и получать сообщения из них. 

Дополнительные сведения о библиотеках Служебной шины Azure для Python см. в [этой статье](/python/api/overview/azure/servicebus?view=azure-python).

## <a name="prerequisites"></a>Предварительные требования
- Подписка Azure. Вы можете активировать [преимущества подписчика Visual Studio или MSDN](https://azure.microsoft.com/pricing/member-offers/msdn-benefits-details/?WT.mc_id=A85619ABF) либо зарегистрироваться для получения [бесплатной учетной записи](https://azure.microsoft.com/free/?WT.mc_id=A85619ABF).
- Пространство имен Служебной шины Azure, созданное с помощью инструкций в [руководстве по созданию раздела и подписок Служебной шины с помощью портала Azure](service-bus-quickstart-topics-subscriptions-portal.md). Скопируйте основную строку подключения из экрана **Политики общего доступа**. Она понадобится далее в этой статье. 
- Python 3.4x или более поздней версии с установленным пакетом [Служебной шины Azure для Python][Python Azure Service Bus package]. Дополнительные сведения см. в [руководстве по установке Python](/azure/python/python-sdk-azure-install). 

## <a name="create-a-queue"></a>Создание очереди

Объект **ServiceBusClient** позволяет работать с очередями. Чтобы программным образом получить доступ к Служебной шине, добавьте в начало файла Python следующую строку:

```python
from azure.servicebus import ServiceBusClient
```

Чтобы создать объект **ServiceBusClient**, добавьте приведенный ниже код. Замените `<connectionstring>` значением основной строки подключения к Служебной шине. Это значение можно найти на [портале Azure][Azure portal] в разделе **Политики общего доступа** в пространстве имен Служебной шины.

```python
sb_client = ServiceBusClient.from_connection_string('<connectionstring>')
```

В следующем коде метод `create_queue` объекта **ServiceBusClient** используется для создания очереди с именем `taskqueue` с параметрами по умолчанию:

```python
sb_client.create_queue("taskqueue")
```

С помощью параметров можно переопределить параметры очереди по умолчанию, например срок жизни сообщения или максимальный размер раздела. Следующий код создает очередь с именем `taskqueue` с максимальным размером очереди 5 ГБ и сроком жизни, равным 1 минуте:

```python
sb_client.create_queue("taskqueue", max_size_in_megabytes=5120,
                       default_message_time_to_live=datetime.timedelta(minutes=1))
```

## <a name="send-messages-to-a-queue"></a>Отправка сообщений в очередь

Чтобы отправить сообщение в очередь Служебной шины, приложение вызывает метод `send` для объекта **ServiceBusClient**. Приведенный ниже пример кода создает клиент очереди и отправляет тестовое сообщение в очередь `taskqueue`. Замените `<connectionstring>` значением основной строки подключения к Служебной шине. 

```python
from azure.servicebus import QueueClient, Message

# Create the QueueClient
queue_client = QueueClient.from_connection_string("<connectionstring>", "taskqueue")

# Send a test message to the queue
msg = Message(b'Test Message')
queue_client.send(msg)
```

### <a name="message-size-limits-and-quotas"></a>Квоты и ограничения на размер сообщений

Очереди служебной шины поддерживают максимальный размер сообщения 256 КБ для [уровня "Стандартный"](service-bus-premium-messaging.md) и 1 МБ для [уровня Premium](service-bus-premium-messaging.md). Максимальный размер заголовка, который содержит стандартные и настраиваемые свойства приложения, — 64 КБ. Число сообщений в очереди может быть любым, но действует ограничение на общий размер сообщений в очереди. Этот размер очереди, определяемый в момент ее создания, не должен превышать 5 ГБ. 

Дополнительные сведения о квотах см. в статье [Квоты на служебную шину][Service Bus quotas].

## <a name="receive-messages-from-a-queue"></a>Получение сообщений из очереди

Клиент очереди получает сообщения из очереди с помощью метода `get_receiver` для объекта **ServiceBusClient**. Приведенный ниже пример кода создает клиент очереди и получает тестовое сообщение из очереди `taskqueue`. Замените `<connectionstring>` значением основной строки подключения к Служебной шине. 

```python
from azure.servicebus import QueueClient, Message

# Create the QueueClient
queue_client = QueueClient.from_connection_string("<connectionstring>", "taskqueue")

# Receive the message from the queue
with queue_client.get_receiver() as queue_receiver:
    messages = queue_receiver.fetch_next(timeout=3)
    for message in messages:
        print(message)
        message.complete()
```

### <a name="use-the-peek_lock-parameter"></a>Использование параметра peek_lock

Необязательный параметр `peek_lock` метода `get_receiver` определяет, удаляет ли Служебная шина сообщения из очереди по мере их чтения. *PeekLock* — это режим получения сообщений по умолчанию (параметр `peek_lock` имеет значение **True**). В этом режиме сообщения читаются (просматриваются) и блокируются без удаления из очереди. После этого каждое сообщение необходимо явно завершить, чтобы удалить его из очереди.

Чтобы удалять сообщения из очереди по мере их чтения, для параметра `peek_lock` метода `get_receiver` необходимо задать значения **False**. Удаление сообщений в ходе операции получения является самой простой моделью, но работает только в том случае, если приложение допускает пропуск сообщений в случае сбоя. Чтобы понять это поведение, рассмотрим сценарий, в котором объект-получатель выдает запрос на получение и выходит из строя до его обработки. Если сообщение было удалено при получении, то когда после своего перезапуска приложение снова начнет обрабатывать сообщения, оно пропустит сообщение, полученное до сбоя.

Если приложение не допускает пропуска сообщений, процесс получения становится двухэтапной операцией. PeekLock находит следующее сообщение, блокирует его, чтобы другие получатели не могли его принять, а затем возвращает его приложению. После обработки или сохранения сообщения приложение завершает второй этап процесса получения, вызывая метод `complete` объекта **Message**.  Метод `complete` помечает сообщение как использованное и удаляет его из очереди.

## <a name="handle-application-crashes-and-unreadable-messages"></a>Обработка сбоев приложения и нечитаемых сообщений

служебная шина предоставляет функции, помогающие корректно выполнить восстановление после ошибок в приложении или трудностей, возникших при обработке сообщения. Если по какой-либо причине приложению-получателю не удается обработать сообщение, оно вызывает метод `unlock` для объекта **Message**. Служебная шина разблокирует сообщение в очереди и снова делает его доступным для получения в том же или другом приложении.

Кроме того, существует время ожидания сообщений, заблокированных в очереди. Если приложение не сможет обработать сообщение в течение времени ожидания (например, при сбое приложения), Служебная шина автоматически разблокирует сообщение и снова сделает его доступным для получения.

Если в приложении происходит сбой после обработки сообщения, но перед вызовом метода `complete`, сообщение повторно доставляется в приложение после его перезапуска. Такая реакция на событие часто называется *по крайней мере одна обработка*. Каждое приложение обрабатывается по крайней мере один раз, но в некоторых случаях одно и то же сообщение может быть доставлено повторно. Если сценарий не допускает обработки дубликатов, вы можете использовать свойство **MessageId** сообщения, которое остается постоянным при всех попытках доставки. Это позволяет обрабатывать повторную доставку сообщения. 

> [!TIP]
> Вы можете управлять ресурсами служебной шины с помощью [обозревателя служебной шины](https://github.com/paolosalvatori/ServiceBusExplorer/). Обозреватель Служебной шины позволяет без труда подключаться к пространству имен Служебной шины и управлять сущностями обмена сообщениями. Средство предоставляет дополнительные возможности, например функции импорта и экспорта и возможность проверять разделы, очереди, подписки, службы ретрансляции, центры уведомлений и концентраторы событий.

## <a name="next-steps"></a>Дополнительная информация

Вы ознакомились с основами использования очередей Служебной шины. Дополнительные сведения см. в статье [Очереди, разделы и подписки служебной шины][Queues, topics, and subscriptions].

[Azure portal]: https://portal.azure.com
[Python Azure Service Bus package]: https://pypi.python.org/pypi/azure-servicebus  
[Queues, topics, and subscriptions]: service-bus-queues-topics-subscriptions.md
[Service Bus quotas]: service-bus-quotas.md
