---
title: Оптимизация затрат путем автоматизации уровней доступа к хранилищу BLOB-объектов Azure
description: Создавайте автоматические правила для перемещения данных между горячими, замечательными и архивными уровнями.
author: mhopkins-msft
ms.author: mhopkins
ms.date: 10/29/2020
ms.service: storage
ms.subservice: common
ms.topic: conceptual
ms.reviewer: yzheng
ms.custom: devx-track-azurepowershell, references_regions
ms.openlocfilehash: a4a338a4d13715ba1ff7cb30c011757d5050ba05
ms.sourcegitcommit: 3bdeb546890a740384a8ef383cf915e84bd7e91e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93100075"
---
# <a name="optimize-costs-by-automating-azure-blob-storage-access-tiers"></a>Оптимизация затрат путем автоматизации уровней доступа к хранилищу BLOB-объектов Azure

Для каждого набора данных существуют уникальные требования к жизненному циклу. На ранних этапах жизненного цикла данных обращение к ним происходит часто. Но по мере устаревания данных потребность в доступе снижается очень быстро. Некоторые данные хранятся в облаке почти без использования, и после сохранения к ним обращаются крайне редко. Некоторые данные устаревают через несколько дней или месяцев после их создания, а другие наборы данных активно считываются и изменяются на протяжении всего времени существования. Управление жизненным циклом хранилища BLOB-объектов Azure предлагает обширную политику на основе правил для учетных записей GPv2 и хранилища BLOB-объектов. Эти политики позволяют переводить данные на новые уровни доступа и удалять их по завершении жизненного цикла.

Политика управления жизненным циклом поддерживает следующие возможности.

- Переход больших двоичных объектов с холодного на горячий немедленно при доступе для оптимизации производительности 
- Перенос больших двоичных объектов, версий больших двоичных объектов и моментальных снимков больших двоичных объектов на более новый уровень хранилища (горячий для холодного, горячий в архив или стильный), если он не был доступен или изменен в течение определенного периода времени для оптимизации затрат
- Удаление больших двоичных объектов, версий больших двоичных объектов и моментальных снимков больших двоичных объектов в конце их жизненного цикла
- Определение правил, выполняемых раз в день, на уровне учетной записи хранения.
- Применение правил к контейнерам или подмножеству больших двоичных объектов (с использованием префиксов имен или [тегов индекса больших двоичных объектов](storage-manage-find-blobs.md) в качестве фильтров)

Рассмотрим ситуацию, когда данные часто обращаются на ранних стадиях жизненного цикла, но иногда через две недели. Данные, которые хранятся больше месяца, запрашиваются крайне редко. В этом сценарии для ранних этапов лучше всего выбрать горячий уровень хранилища. Для случайного доступа наиболее подходящим является наиболее подходящее хранилище. Архивное хранилище — это лучший вариант уровня по истечении возраста данных в течение месяца. Выбирая уровни хранилища в зависимости от возраста данных, вы сможете создать наиболее экономичный вариант хранилища для конкретных потребностей. Чтобы достичь перемещения данных на более холодные уровни, можно использовать правила политики управления жизненным циклом.

[!INCLUDE [storage-multi-protocol-access-preview](../../../includes/storage-multi-protocol-access-preview.md)]

>[!NOTE]
>Если требуется, чтобы данные оставались доступными для чтения, например при использовании StorSimple, не настраиваете политику для перемещения больших двоичных объектов на уровень архива.

## <a name="availability-and-pricing"></a>Доступность и расценки

Функция управления жизненным циклом доступна во всех регионах Azure для учетных записей общего назначения v2 (GPv2), учетных записей хранения BLOB-объектов, учетных записей хранения блочных BLOB-объектов класса Premium и учетных записей Azure Data Lake Storage 2-го поколения. В портал Azure можно обновить существующую учетную запись общего назначения (GPv1) до учетной записи GPv2. Дополнительные сведения об учетных записях хранения см. в статье [Общие сведения об учетной записи хранения](../common/storage-account-overview.md).

Функция управления жизненным циклом не взимается. Клиентам выставляются счета за обычные операции для вызовов API [уровня большого двоичного объекта](https://docs.microsoft.com/rest/api/storageservices/set-blob-tier) . Операция удаления бесплатна. Дополнительные сведения см. на странице [цен на блочные BLOB-объекты](https://azure.microsoft.com/pricing/details/storage/blobs/).

## <a name="add-or-remove-a-policy"></a>Добавление или удаление политики

Добавить, изменить или удалить политику можно с помощью любого из следующих методов.

* [Портал Azure](https://portal.azure.com)
* [Azure PowerShell](https://github.com/Azure/azure-powershell/releases)
* [Azure CLI](https://docs.microsoft.com/cli/azure/install-azure-cli)
* [REST API](https://docs.microsoft.com/rest/api/storagerp/managementpolicies);

Политику можно прочитать или записать полностью. Частичные обновления не поддерживаются. 

> [!NOTE]
> Если вы настроили для учетной записи хранения правила брандмауэра, запросы на управление жизненным циклом могут быть заблокированы. Вы можете разблокировать эти запросы, предоставив исключения для доверенных служб Майкрософт. Дополнительные сведения см. в разделе об исключениях в статье [Настройка брандмауэров службы хранилища Azure и виртуальных сетей](https://docs.microsoft.com/azure/storage/common/storage-network-security#exceptions).

В этой статье показано, как управлять политикой с помощью портала и методов PowerShell.

# <a name="portal"></a>[Портал](#tab/azure-portal)

Существует два способа добавления политики с помощью портал Azure. 

* [Представление списка портал Azure](#azure-portal-list-view)
* [Представление кода портал Azure](#azure-portal-code-view)

#### <a name="azure-portal-list-view"></a>Представление списка портал Azure

1. Войдите на [портал Azure](https://portal.azure.com).

1. В портал Azure найдите и выберите свою учетную запись хранения. 

1. В разделе **Служба BLOB-объектов** выберите **Управление жизненным циклом** , чтобы просмотреть или изменить правила.

1. Перейдите на вкладку **представление списка** .

1. Выберите **Добавить правило** и назовите правило в форме **сведения** . Можно также задать значения параметров **область правила** , **Тип большого двоичного объекта** и **подтип большого двоичного объекта** . В следующем примере задается область для фильтрации больших двоичных объектов. Это приводит к добавлению вкладки **набора фильтров** .

   :::image type="content" source="media/storage-lifecycle-management-concepts/lifecycle-management-details.png" alt-text="Управление жизненным циклом Добавление страницы сведений о правиле в портал Azure":::

1. Выберите **базовые BLOB-объекты** , чтобы задать условия для правила. В следующем примере большие двоичные объекты перемещаются в очень удобном хранилище, если они не были изменены в течение 30 дней.

   :::image type="content" source="media/storage-lifecycle-management-concepts/lifecycle-management-base-blobs.png" alt-text="Страница базовых BLOB-объектов управления жизненным циклом в портал Azure":::

   Параметр **Последний доступ** доступен в предварительной версии в следующих регионах:

    - Центральная Франция
    - Восточная Канада
    - Центральная Канада

   > [!IMPORTANT]
   > Предварительная версия отслеживания времени последнего доступа предназначена только для использования в рабочей среде. Соглашения об уровне обслуживания (SLA) для рабочих сред сейчас недоступны.
   
   Чтобы использовать **Последний доступ** к параметру, на странице **Управление жизненным циклом** в портал Azure выберите **отслеживание доступа включено** . Дополнительные сведения о **последнем доступном** параметре см. в разделе [Перемещение данных на основе даты последнего доступа (Предварительная версия)](#move-data-based-on-last-accessed-date-preview).

1. Если вы выбрали **ограничить большие двоичные объекты с фильтрами** на странице **сведений** , выберите **фильтр установить** , чтобы добавить необязательный фильтр. В следующем примере выполняется фильтрация больших двоичных объектов в контейнере *милифециклеконтаинер* , начинающихся с "log".

   :::image type="content" source="media/storage-lifecycle-management-concepts/lifecycle-management-filter-set.png" alt-text="Страница &quot;набор фильтров управления жизненным циклом&quot; в портал Azure":::

1. Нажмите кнопку **Добавить** , чтобы добавить новую политику.

#### <a name="azure-portal-code-view"></a>Представление кода портал Azure
1. Войдите на [портал Azure](https://portal.azure.com).

1. В портал Azure найдите и выберите свою учетную запись хранения.

1. В разделе **Служба BLOB-объектов** выберите **Управление жизненным циклом** , чтобы просмотреть или изменить политику.

1. Следующий JSON является примером политики, которую можно вставлять на вкладку **представление кода** .

   ```json
   {
     "rules": [
       {
         "enabled": true,
         "name": "move-to-cool",
         "type": "Lifecycle",
         "definition": {
           "actions": {
             "baseBlob": {
               "tierToCool": {
                 "daysAfterModificationGreaterThan": 30
               }
             }
           },
           "filters": {
             "blobTypes": [
               "blockBlob"
             ],
             "prefixMatch": [
               "mylifecyclecontainer/log"
             ]
           }
         }
       }
     ]
   }
   ```

1. Щелкните **Сохранить**.

1. Дополнительные сведения об этом примере JSON см. в разделах [Политика](#policy) и [правила](#rules) .

# <a name="powershell"></a>[PowerShell](#tab/azure-powershell)

Следующий скрипт PowerShell можно использовать для добавления политики в учетную запись хранения. Переменная `$rgname` должна быть инициализирована с помощью имени группы ресурсов. Переменная `$accountName` должна быть инициализирована с помощью имени учетной записи хранения.

```powershell
#Install the latest module
Install-Module -Name Az -Repository PSGallery

#Initialize the following with your resource group and storage account names
$rgname = ""
$accountName = ""

#Create a new action object
$action = Add-AzStorageAccountManagementPolicyAction -BaseBlobAction Delete -daysAfterModificationGreaterThan 2555
$action = Add-AzStorageAccountManagementPolicyAction -InputObject $action -BaseBlobAction TierToArchive -daysAfterModificationGreaterThan 90
$action = Add-AzStorageAccountManagementPolicyAction -InputObject $action -BaseBlobAction TierToCool -daysAfterModificationGreaterThan 30
$action = Add-AzStorageAccountManagementPolicyAction -InputObject $action -SnapshotAction Delete -daysAfterCreationGreaterThan 90

# Create a new filter object
# PowerShell automatically sets BlobType as “blockblob” because it is the only available option currently
$filter = New-AzStorageAccountManagementPolicyFilter -PrefixMatch ab,cd

#Create a new rule object
#PowerShell automatically sets Type as “Lifecycle” because it is the only available option currently
$rule1 = New-AzStorageAccountManagementPolicyRule -Name Test -Action $action -Filter $filter

#Set the policy
Set-AzStorageAccountManagementPolicy -ResourceGroupName $rgname -StorageAccountName $accountName -Rule $rule1
```

# <a name="template"></a>[Шаблон](#tab/template)

Управление жизненным циклом можно определить с помощью шаблонов Azure Resource Manager. Ниже приведен пример шаблона для развертывания учетной записи хранения RA-GRS GPv2 с политикой управления жизненным циклом.

```json
{
  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {},
  "variables": {
    "storageAccountName": "[uniqueString(resourceGroup().id)]"
  },
  "resources": [
    {
      "type": "Microsoft.Storage/storageAccounts",
      "name": "[variables('storageAccountName')]",
      "location": "[resourceGroup().location]",
      "apiVersion": "2019-04-01",
      "sku": {
        "name": "Standard_RAGRS"
      },
      "kind": "StorageV2",
      "properties": {
        "networkAcls": {}
      }
    },
    {
      "name": "[concat(variables('storageAccountName'), '/default')]",
      "type": "Microsoft.Storage/storageAccounts/managementPolicies",
      "apiVersion": "2019-04-01",
      "dependsOn": [
        "[variables('storageAccountName')]"
      ],
      "properties": {
        "policy": {...}
      }
    }
  ],
  "outputs": {}
}
```

---

## <a name="policy"></a>Политика

Политика управления жизненным циклом представляет собой набор правил, оформленный в виде документа JSON.

```json
{
  "rules": [
    {
      "name": "rule1",
      "enabled": true,
      "type": "Lifecycle",
      "definition": {...}
    },
    {
      "name": "rule2",
      "type": "Lifecycle",
      "definition": {...}
    }
  ]
}
```

Политика — это набор правил.

| Имя параметра | Тип параметра | Примечания |
|----------------|----------------|-------|
| `rules`        | Массив объектов правил | В политике требуется по крайней мере одно правило. В политике можно определить до 100 правил.|

Каждое правило в политике имеет несколько параметров:

| Имя параметра | Тип параметра | Примечания | Обязательно |
|----------------|----------------|-------|----------|
| `name`         | Строка |Имя правила может включать до 256 буквенно-цифровых символов. В именах правил учитывается регистр. Имя должно быть уникальным в пределах политики. | Верно |
| `enabled`      | Логическое значение | Необязательное логическое значение, которое позволяет временно отключить правило. Значение по умолчанию — true, если оно не задано. | Неверно | 
| `type`         | Значение перечисления | Текущий допустимый тип — `Lifecycle` . | Верно |
| `definition`   | Объект, который определяет правило жизненного цикла | Каждое определение состоит из набора фильтров и набора действий. | Верно |

## <a name="rules"></a>Правила

Каждое определение правила состоит из набора фильтров и набора действий. [Набор фильтров](#rule-filters) ограничивает действие правила определенным набором объектов в контейнере или имен объектов. [Набор операций](#rule-actions) вводит в действие уровень или удаляет действия в отфильтрованном наборе объектов.

### <a name="sample-rule"></a>Пример правила

В следующем примере правила выполняется фильтрация учетной записи для выполнения действий с объектами, которые существуют внутри `container1` и начинаются с `foo` .

>[!NOTE]
>- Управление жизненным циклом поддерживает блочные и добавочные типы больших двоичных объектов.<br>
>- Управление жизненным циклом не влияет на системные контейнеры, такие как $logs и $web.

- установить для BLOB-объекта холодный уровень доступа через 30 дней после последнего изменения;
- установить для BLOB-объекта архивный уровень доступа через 90 дней после последнего изменения;
- удалить BLOB-объект спустя 2555 дней (7 лет) после последнего изменения;
- Удалить предыдущие версии BLOB-объектов, 90 дней после создания

```json
{
  "rules": [
    {
      "enabled": true,
      "name": "rulefoo",
      "type": "Lifecycle",
      "definition": {
        "actions": {
          "version": {
            "delete": {
              "daysAfterCreationGreaterThan": 90
            }
          },
          "baseBlob": {
            "tierToCool": {
              "daysAfterModificationGreaterThan": 30
            },
            "tierToArchive": {
              "daysAfterModificationGreaterThan": 90
            },
            "delete": {
              "daysAfterModificationGreaterThan": 2555
            }
          }
        },
        "filters": {
          "blobTypes": [
            "blockBlob"
          ],
          "prefixMatch": [
            "container1/foo"
          ]
        }
      }
    }
  ]
}
```

### <a name="rule-filters"></a>Фильтры правила

Фильтры ограничивают действие правила определенным подмножеством BLOB-объектов в учетной записи хранения. Если определено несколько фильтров, для всех фильтров применяется логическая операция `AND`.

Доступны следующие фильтры:

| Имя фильтра | Тип фильтра | Примечания | Обязательный |
|-------------|-------------|-------|-------------|
| blobTypes   | Массив предустановленных значений перечисления. | Текущий выпуск поддерживает `blockBlob` и `appendBlob` . Поддерживается только удаление, но `appendBlob` Set Tier не поддерживается. | Да |
| prefixMatch | Массив строк для сопоставления префиксов. Каждое правило может определять до 10 префиксов. Строка префикса должно начинаться с имени контейнера. Например, если нужно сопоставить все большие двоичные объекты в `https://myaccount.blob.core.windows.net/container1/foo/...` правиле, префиксматч имеет значение `container1/foo` . | Если не определить Префиксматч, правило применяется ко всем BLOB-объектам в учетной записи хранения. | Нет |
| блобиндексматч | Массив значений словаря, состоящий из ключа тега индекса больших двоичных объектов и условий значения для сопоставления. Каждое правило может определять до 10 условий тега индекса больших двоичных объектов. Например, если вы хотите сопоставить все большие двоичные объекты `Project = Contoso` с `https://myaccount.blob.core.windows.net/` для правила, блобиндексматч имеет значение `{"name": "Project","op": "==","value": "Contoso"}` . | Если не определить Блобиндексматч, правило применяется ко всем BLOB-объектам в учетной записи хранения. | Нет |

> [!NOTE]
> Индекс больших двоичных объектов доступен в общедоступной предварительной версии и доступен в регионах " **Центральная Канада** ", " **Восточная Канада** ", " **Франция Central** " и " **Франция** ". Дополнительные сведения об этой функции, а также известных проблемах и ограничениях см. в статье [Управление данными в хранилище BLOB-объектов Azure и их поиск с помощью индекса больших двоичных объектов (предварительная версия)](storage-manage-find-blobs.md).

### <a name="rule-actions"></a>Действия правила

Действия применяются к отфильтрованным BLOB-объектам при выполнении условия выполнения.

Управление жизненным циклом поддерживает распределение и удаление больших двоичных объектов, предыдущих версий больших двоичных объектов и моментальных снимков больших двоичных объектов. Определите по крайней мере одно действие для каждого правила в базовых BLOB-объектах, предыдущих версиях BLOB-объектов или моментальных снимках больших двоичных объектов.

| Действие                      | Базовый BLOB-объект                                  | Моментальный снимок      | Версия
|-----------------------------|--------------------------------------------|---------------|---------------|
| tierToCool                  | Поддерживается для объекта `blockBlob`                  | Поддерживается     | Поддерживается     |
| енаблеаутотиертохотфромкул | Поддерживается для объекта `blockBlob`                  | Не поддерживается | Не поддерживается |
| tierToArchive               | Поддерживается для объекта `blockBlob`                  | Поддерживается     | Поддерживается     |
| удалить                      | Поддерживается для `blockBlob` и `appendBlob` | Поддерживается     | Поддерживается     |

>[!NOTE]
>Если для одного BLOB-объекта определено более одного действия, управление жизненным циклом применяет к нему более дешевое из этих действий. Например, действие `delete` дешевле, чем действие `tierToArchive`; а действие `tierToArchive` дешевле, чем действие `tierToCool`.

Условия выполнения основаны на возраст. Базовые BLOB-объекты используют время последнего изменения, версии BLOB-объектов используют время создания версии, а моментальные снимки BLOB-объектов используют время создания моментального снимка для отслеживания возраста.

| Условие выполнения действия               | Значение условия                          | Описание                                                                      |
|------------------------------------|------------------------------------------|----------------------------------------------------------------------------------|
| daysAfterModificationGreaterThan   | Целочисленное значение, указывающее возраст в днях | Условие для действий базового большого двоичного объекта                                              |
| daysAfterCreationGreaterThan       | Целочисленное значение, указывающее возраст в днях | Условие для действий версии BLOB-объекта и моментальных снимков BLOB-объектов                         |
| дайсафтерластакцесстимегреатерсан | Целочисленное значение, указывающее возраст в днях | образца Условие для основных действий большого двоичного объекта при включенном времени последнего доступа |

## <a name="examples"></a>Примеры

Следующие примеры демонстрируют несколько типичных сценариев для правил политики жизненного цикла.

### <a name="move-aging-data-to-a-cooler-tier"></a>Перемещение старых данных на более холодный уровень

В следующем примере показано перемещение блочных BLOB-объектов с префиксом имени `container1/foo` или `container2/bar`. Эта политика перемещает BLOB-объекты, которые не изменялись более 30 дней, на холодный уровень, а которые не изменялись в течение 90 дней — на архивный уровень:

```json
{
  "rules": [
    {
      "name": "agingRule",
      "enabled": true,
      "type": "Lifecycle",
      "definition": {
        "filters": {
          "blobTypes": [ "blockBlob" ],
          "prefixMatch": [ "container1/foo", "container2/bar" ]
        },
        "actions": {
          "baseBlob": {
            "tierToCool": { "daysAfterModificationGreaterThan": 30 },
            "tierToArchive": { "daysAfterModificationGreaterThan": 90 }
          }
        }
      }
    }
  ]
}
```

### <a name="move-data-based-on-last-accessed-date-preview"></a>Перемещение данных на основе даты последнего доступа (Предварительная версия)

Вы можете включить отслеживание времени последнего доступа, чтобы сохранить запись о том, когда большой двоичный объект будет прочитан или записан в последний раз. Время последнего доступа можно использовать в качестве фильтра для управления распределением и хранением данных больших двоичных объектов.

Параметр **Последний доступ** доступен в предварительной версии в следующих регионах:

 - Центральная Франция
 - Восточная Канада
 - Центральная Канада

> [!IMPORTANT]
> Предварительная версия отслеживания времени последнего доступа предназначена только для использования в рабочей среде. Соглашения об уровне обслуживания (SLA) для рабочих сред сейчас недоступны.

Чтобы использовать **Последний доступ** к параметру, на странице **Управление жизненным циклом** в портал Azure выберите **отслеживание доступа включено** .

#### <a name="how-last-access-time-tracking-works"></a>Как работает отслеживание времени последнего доступа

Когда отслеживание времени последнего доступа включено, свойство большого двоичного объекта с именем `LastAccessTime` обновляется при чтении или записи большого двоичного объекта. Операция [получения большого двоичного объекта](/rest/api/storageservices/get-blob) рассматривается как операция доступа. [Получение свойств большого двоичного](/rest/api/storageservices/get-blob-properties)объекта, [Получение метаданных большого двоичного объекта](/rest/api/storageservices/get-blob-metadata)и [Получение тегов больших двоичных объектов](/rest/api/storageservices/get-blob-tags) не являются операциями доступа и, следовательно, не обновляют время последнего доступа.

Чтобы снизить влияние на задержку доступа чтения, только первое считывание последних 24 часов обновляет время последнего доступа. Последующие операции чтения в том же 24-часовом периоде не обновляют время последнего доступа. При изменении большого двоичного объекта между операциями чтения Последнее время доступа является более свежим из двух значений.

В следующем примере большие двоичные объекты перемещаются в стильный хранилище, если к ним нет доступа в течение 30 дней. `enableAutoTierToHotFromCool`Свойство является логическим значением, указывающим, следует ли автоматически переносить большой двоичный объект с уровня "холодного" обратно на "горячий", если доступ к нему осуществляется снова после того, как он будет доступен для охлаждения.

```json
{
  "enabled": true,
  "name": "last-accessed-thirty-days-ago",
  "type": "Lifecycle",
  "definition": {
    "actions": {
      "baseBlob": {
        "enableAutoTierToHotFromCool": true,
        "tierToCool": {
          "daysAfterLastAccessTimeGreaterThan": 30
        }
      }
    },
    "filters": {
      "blobTypes": [
        "blockBlob"
      ],
      "prefixMatch": [
        "mylifecyclecontainer/log"
      ]
    }
  }
}
```

#### <a name="storage-account-support"></a>Поддержка учетных записей хранения

Отслеживание времени последнего доступа доступно для следующих типов учетных записей хранения:

 - Учетные записи хранения общего назначения версии 2
 - Блокировать учетные записи хранения BLOB-объектов
 - Учетные записи хранения BLOB-объектов

Если ваша учетная запись хранения является учетной записью общего назначения v1, используйте портал Azure для обновления до учетной записи общего назначения версии 2.

Учетные записи хранения с иерархическим пространством имен, которые включены для использования с Azure Data Lake Storage 2-го поколения, пока не поддерживаются.

#### <a name="pricing-and-billing"></a>Цены и выставление счетов

Каждое обновление времени последнего доступа считается [другой операцией](https://azure.microsoft.com/pricing/details/storage/blobs/).

### <a name="archive-data-after-ingest"></a>Архивировать данные после приема

Некоторые данные хранятся в облаке почти без использования. Следующая политика жизненного цикла настроена для архивации данных вскоре после приема. В этом примере выполняется перевод блочных BLOB-объектов в учетной записи хранения в контейнере `archivecontainer` в архивный уровень. Переход выполняется с помощью больших двоичных объектов за 0 дней после последнего изменения:

> [!NOTE] 
> Рекомендуется передать большие двоичные объекты непосредственно на уровне архива, чтобы повысить эффективность. Вы можете использовать заголовок x-MS-Access-уровня для [PutBlob](https://docs.microsoft.com/rest/api/storageservices/put-blob) или [PutBlockList](https://docs.microsoft.com/rest/api/storageservices/put-block-list) с оставшейся версией 2018-11-09 и более поздней или нашей последней клиентской библиотекой хранилища BLOB-объектов. 

```json
{
  "rules": [
    {
      "name": "archiveRule",
      "enabled": true,
      "type": "Lifecycle",
      "definition": {
        "filters": {
          "blobTypes": [ "blockBlob" ],
          "prefixMatch": [ "archivecontainer" ]
        },
        "actions": {
          "baseBlob": {
              "tierToArchive": { "daysAfterModificationGreaterThan": 0 }
          }
        }
      }
    }
  ]
}

```

### <a name="expire-data-based-on-age"></a>Устаревание данных на основе возраста

Ожидается, что срок действия некоторых данных истекает в днях или месяцах после создания. Вы можете настроить политику управления жизненным циклом, чтобы удалять устаревшие данные при достижении определенного возраста. В следующем примере показана политика, которая удаляет все блочные BLOB-объекты старше 365 дней.

```json
{
  "rules": [
    {
      "name": "expirationRule",
      "enabled": true,
      "type": "Lifecycle",
      "definition": {
        "filters": {
          "blobTypes": [ "blockBlob" ]
        },
        "actions": {
          "baseBlob": {
            "delete": { "daysAfterModificationGreaterThan": 365 }
          }
        }
      }
    }
  ]
}
```

### <a name="delete-data-with-blob-index-tags"></a>Удаление данных с помощью тегов индекса больших двоичных объектов
Некоторые данные должны быть просрочены только в том случае, если они явно помечены для удаления. Политику управления жизненным циклом можно настроить для истечения срока действия данных, помеченных атрибутами ключ/значение индекса больших двоичных объектов. В следующем примере показана политика, которая удаляет все блочные BLOB-объекты, помеченные `Project = Contoso` . Дополнительные сведения об индексе больших двоичных объектов см. в статье [Управление данными в хранилище BLOB-объектов Azure и их поиск с помощью индекса больших двоичных объектов (предварительная версия)](storage-manage-find-blobs.md).

```json
{
    "rules": [
        {
            "enabled": true,
            "name": "DeleteContosoData",
            "type": "Lifecycle",
            "definition": {
                "actions": {
                    "baseBlob": {
                        "delete": {
                            "daysAfterModificationGreaterThan": 0
                        }
                    }
                },
                "filters": {
                    "blobIndexMatch": [
                        {
                            "name": "Project",
                            "op": "==",
                            "value": "Contoso"
                        }
                    ],
                    "blobTypes": [
                        "blockBlob"
                    ]
                }
            }
        }
    ]
}
```

### <a name="manage-versions"></a>Управление версиями

Для данных, изменяемых и доступ к которым осуществляется регулярно в течение всего времени существования, можно включить управление версиями хранилища BLOB-объектов для автоматического обслуживания предыдущих версий объекта. Можно создать политику для уровня или удалить предыдущие версии. Возраст версии определяется путем оценки времени создания версии. Это правило политики используется для предыдущих версий в контейнере ( `activedata` 90 дней или более ранних после создания версии до уровня "стильный") и удаляет предыдущие версии с 365 дней или более ранних версий.

```json
{
  "rules": [
    {
      "enabled": true,
      "name": "versionrule",
      "type": "Lifecycle",
      "definition": {
        "actions": {
          "version": {
            "tierToCool": {
              "daysAfterCreationGreaterThan": 90
            },
            "delete": {
              "daysAfterCreationGreaterThan": 365
            }
          }
        },
        "filters": {
          "blobTypes": [
            "blockBlob"
          ],
          "prefixMatch": [
            "activedata"
          ]
        }
      }
    }
  ]
}
```

## <a name="faq"></a>ВОПРОСЫ И ОТВЕТЫ

**Я создал новую политику, почему действия не выполняются немедленно?**

Платформа выполняет политики жизненного цикла один раз в день. После настройки политики для первого выполнения некоторых действий может потребоваться до 24 часов.

**Сколько времени требуется для выполнения действий при обновлении существующей политики?**

Обновленная политика вступает в силу до 24 часов. Когда политика вступит в силу, выполнение действий может занять до 24 часов. Поэтому выполнение действий политики может занять до 48 часов.

**Я вручную повторно занесли в архив большой двоичный объект, как предотвратить его временное перемещение на архивный уровень?**

При перемещении большого двоичного объекта с одного уровня доступа на другой его время последнего изменения не изменяется. Если вы вручную восстанавливаете архивный BLOB-объект на "горячем" уровне, он перемещается обратно на уровень архива с помощью подсистемы управления жизненным циклом. Отключите правило, которое временно влияет на этот большой двоичный объект, чтобы предотвратить его архивацию. Повторно включите правило, когда большой двоичный объект можно безопасно переместить обратно на архивный уровень. Вы также можете скопировать большой двоичный объект в другое расположение, если он должен постоянно оставаться на активном или холодном уровне.

## <a name="next-steps"></a>Дальнейшие действия

Узнайте, как восстанавливать данные после случайного удаления:

- [Soft delete for Azure Storage blobs](../blobs/storage-blob-soft-delete.md) (Обратимое удаление больших двоичных объектов службы хранилища Azure)

Узнайте, как управлять данными и находить их с помощью индекса больших двоичных объектов:

- [Управление данными в хранилище BLOB-объектов Azure и их поиск с помощью индекса BLOB-объектов](storage-manage-find-blobs.md)
