---
title: Разработка высокодоступных приложений с использованием геоизбыточного хранилища с доступом для чтения (RA-ГЗРС или RA-GRS) | Документация Майкрософт
description: Как использовать хранилище Azure RA-ГЗРС или RA-GRS для проектирования высокодоступного приложения, достаточно гибкого для работы с простоями.
services: storage
author: tamram
ms.service: storage
ms.topic: conceptual
ms.date: 08/14/2019
ms.author: tamram
ms.reviewer: artek
ms.subservice: common
ms.openlocfilehash: a6d724f834fb8a4c54cd613c61ca90a77a36bdea
ms.sourcegitcommit: 2d9a9079dd0a701b4bbe7289e8126a167cfcb450
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2019
ms.locfileid: "71673114"
---
# <a name="designing-highly-available-applications-using-read-access-geo-redundant-storage"></a>Разработка высокодоступных приложений с помощью геоизбыточного хранилища с доступом для чтения

Характерной чертой облачных инфраструктур, таких как служба хранилища Azure, является то, что они предоставляют высокодоступную платформу для размещения приложений. Разработчикам облачных приложений необходимо внимательно обдумать, как эффективно использовать эту платформу, чтобы обеспечить высокий уровень доступности приложений пользователям. Эта статья посвящена тому, как разработчики могут использовать один из геоизбыточных вариантов репликации Azure, чтобы обеспечить высокую доступность приложений службы хранилища Azure.

Учетные записи хранения, настроенные для геоизбыточной репликации, синхронно реплицируются в основном регионе, а затем асинхронно реплицируются в дополнительный регион, который находится в сотнях миль. Служба хранилища Azure предлагает два типа геоизбыточной репликации:

* [Хранилище, избыточное в геопоясе (гзрс) (Предварительная версия)](storage-redundancy-gzrs.md) , обеспечивает репликацию для сценариев, требующих высокой доступности и максимальной устойчивости. Данные реплицируются синхронно в трех зонах доступности Azure в основном регионе с помощью хранилища, избыточного в пределах зоны (ZRS), а затем реплицируются асинхронно в дополнительный регион. Для доступа на чтение к данным в дополнительном регионе включите хранилище, избыточное в геозону с доступом на чтение (RA-ГЗРС).
* [Геоизбыточное хранилище (GRS)](storage-redundancy-grs.md) обеспечивает межрегиональную репликацию для защиты от региональных простоев. Данные реплицируются синхронно три раза в основном регионе с помощью локально избыточного хранилища (LRS), а затем реплицируются асинхронно в дополнительный регион. Для доступа на чтение к данным в дополнительном регионе включите геоизбыточное хранилище с доступом на чтение (RA-GRS).

В этой статье показано, как спроектировать приложение, чтобы решить сбой в основном регионе. Если основной регион становится недоступным, приложение может адаптироваться для выполнения операций чтения в дополнительном регионе. Прежде чем приступить к работе, убедитесь, что ваша учетная запись хранения настроена для RA-GRS или RA-ГЗРС.

Сведения о том, с какой дополнительной копией сопоставляется каждый основной регион, см. в статье [Непрерывность бизнес-процессов и аварийное восстановление (BCDR) в парах регионов Azure](https://docs.microsoft.com/azure/best-practices-availability-paired-regions).

Эта статья содержит фрагменты кода и ссылку на полный пример в конце, который можно скачать и запустить.

## <a name="application-design-considerations-when-reading-from-the-secondary"></a>Рекомендации по проектированию приложений при чтении с сервера-получателя

Цель этой статьи — показать, как создать приложение, которое будет работать (хотя и с ограниченными возможностями) даже в случае серьезной аварии в основном центре обработки данных. Вы можете разработать приложение, которое будет устранять временные или длительные проблемы, считывая данные из дополнительного региона, при возникновении ошибки, из-за которой невозможно считать данные из основного региона. Когда основной регион снова станет доступным, приложение сможет считывать данные из него, как и прежде.

Учитывайте следующие ключевые моменты при проектировании приложения для RA-GRS или RA-ГЗРС:

* Служба хранилища Azure сохраняет в дополнительном регионе доступную только для чтения копию данных, хранящихся в основном регионе. Как отмечалось выше, расположение этого дополнительного региона определяет служба хранилища.

* Доступная только для чтения копия [согласована в конечном счете](https://en.wikipedia.org/wiki/Eventual_consistency) с данными в основной области.

* Для больших двоичных объектов, таблиц и очередей можно отправить запрос в дополнительный регион, чтобы получить значение *Last Sync Time*. Оно указывает, когда произошла последняя репликация из основного региона в дополнительный. (Это не поддерживается для файлов Azure, которые в настоящее время не обеспечивают избыточности RA-GRS.)

* Клиентскую библиотеку хранилища можно использовать для чтения и записи данных в основном или дополнительном регионе. Можно также автоматически перенаправлять запросы на чтение в дополнительный регион, если истекло время ожидания запроса на чтение в основном регионе.

* Если основной регион становится недоступным, вы можете запустить отработку отказа учетной записи. При выполнении отработки отказа в дополнительный регион нужно изменить записи DNS, указывающие на основной регион, чтобы они указывали на дополнительный регион. После завершения отработки отказа для учетных записей GRS и RA-GRS восстанавливается доступ на запись. Дополнительные сведения см. в статье [Disaster recovery and storage account failover (preview) in Azure Storage](storage-disaster-recovery-guidance.md) (Аварийное восстановление и отработка отказа учетной записи хранения (предварительная версия) в службе хранилища Azure).

> [!NOTE]
> Управляемая клиентом отработка отказа (Предварительная версия) пока недоступна в регионах, поддерживающих ГЗРС/RA-ГЗРС, поэтому клиенты не могут управлять событиями отработки отказа учетной записи ГЗРС и RA-ГЗРС. Во время предварительной версии Корпорация Майкрософт будет управлять событиями отработки отказа, затрагивающими учетные записи ГЗРС/RA-ГЗРС.

### <a name="using-eventually-consistent-data"></a>Использование данных, согласованных в конечном счете

Предлагаемое решение предполагает, что вполне допустимо вернуть вызывающему приложению потенциально устаревшие данные. Так как данные в дополнительном регионе являются согласованными в конечном счете, основной регион может стать недоступным до того, как завершится репликация обновления в дополнительный регион.

Например, предположим, что клиент успешно отправил обновление, но в основном регионе произошел сбой, прежде чем обновление распространилось на дополнительный регион. Когда клиент запрашивает чтение данных назад, он получает устаревшие данные из дополнительного региона, а не из обновленных данных. На этапе разработки приложения вам нужно решить, допустимо ли это, и если допустимо, — определить способ уведомления клиента. 

Далее в этой статье объясняется, как проверить время последней синхронизации данных в дополнительном регионе, чтобы определить, актуальны ли они.

### <a name="handling-services-separately-or-all-together"></a>Отдельная или совместная обработка служб

Хотя это маловероятно, возможна ситуация, когда одна служба станет недоступна, в то время как другие службы будут по-прежнему работать в полнофункциональном режиме. Можно обрабатывать повторные попытки и режим только для чтения для каждой службы отдельно (большие двоичные объекты, очереди, таблицы) или универсально для всех служб хранилища.

Например, при использовании очередей и больших двоичных объектов в приложении можно добавить отдельный код для каждой из этих сущностей, обрабатывающий ошибки, допускающие повторение. Затем, если произойдет ошибка службы BLOB-объектов и потребуется повторить попытку, а служба очередей останется работоспособной, будет затронута только та часть приложения, которая обрабатывают большие двоичные объекты. Если вы решите универсально обрабатывать все повторные попытки операций служб хранилища и вызов к службе BLOB-объектов вернет ошибку, допускающую повторение, то будут запросы и к службе BLOB-объектов, и к службе очередей.

В конечном счете решение зависит от сложности приложения. Можно не обрабатывать сбои каждой отдельной службы, а вместо этого перенаправлять запросы на чтение для всех служб хранилища в дополнительный регион чтения и запускать приложение в режиме только для чтения при обнаружении проблемы в работе какой-либо службы хранения в основном регионе.

### <a name="other-considerations"></a>Дополнительные рекомендации

Ниже приведены дополнительные рекомендации, которые будут рассмотрены в оставшейся части этой статьи.

* Обработка повторных запросов на чтение с помощью шаблона автоматического выключения.

* Согласованные в конечном счете данные и время последней синхронизации.

* Тестирование

## <a name="running-your-application-in-read-only-mode"></a>Выполнение приложения в режиме только для чтения

Чтобы эффективно подготовиться к сбою в основном регионе, необходимо иметь возможность обрабатывать как неудачные запросы на чтение, так и неудачные запросы на обновление (в данном случае это означает, что операции вставки, обновления и удаления). В случае сбоя основного региона запросы на чтение могут быть перенаправляться в дополнительный регион. Но запросы на обновление невозможно перенаправить в дополнительный центр обработки данных, так как он доступен только для чтения. По этой причине необходимо разработать приложение, выполняемое в режиме только для чтения.

Например, можно установить флаг, который будет проверяться перед отправкой любых запросов на обновление в службу хранилища Azure. Пр поступлении запроса на обновление его можно пропустить и вернуть пользователю соответствующий ответ. Можно даже полностью отключить определенные функции до устранения проблемы и уведомить пользователей, что эти функции будут временно недоступны.

Если принято решение отдельно обрабатывать ошибки каждой службы, то необходимо также реализовать возможность запуска службой приложения в режиме только для чтения. Например, для каждой службы можно создать флаги режима только для чтения, которые можно включать и отключать. Затем вы сможете управлять этими флагами в соответствующих частях кода.

Возможность запуска приложения в режиме только для чтения имеет еще одно преимущество — дает возможность ограничить функциональность во время обновления основного приложения. Можно активировать запуск приложения в режиме только для чтения и указать дополнительный центр обработки данных. Это гарантирует, что никто не получит доступ к данным в основном регионе, пока выполняется обновление.

## <a name="handling-updates-when-running-in-read-only-mode"></a>Обработка обновлений в режиме только для чтения

Существует множество способов обработки запросов на обновление в режиме только для чтения. Мы не сможем подробно рассмотреть их все, но в целом существует несколько шаблонов, которые вам стоит принять во внимание.

1. Можно ответить пользователям и сообщить, что в настоящее время обновления не принимаются. Например, система управления контактами может предоставлять клиентам доступ к контактной информации, но не сохранять изменения.

2. Можно поставить обновления в очередь в другом регионе. В этом случае отложенные запросы на обновление нужно будет записывать в очередь в другом регионе, а затем каким-то образом обрабатывать их после возобновления работы основного центра обработки данных. В этом сценарии следует сообщить пользователю, что запрошенное обновление поставлено в очередь для последующей обработки.

3. Можно записывать обновления в учетную запись хранения в другом регионе. А когда возобновится работоспособность основного центра обработки данных, каким-либо образом объединить эти обновления с основными данными, в зависимости от их структуры. Например, если создаются отдельные файлы с меткой даты и времени в имени, их можно скопировать обратно в основной регион. Это подходит для некоторых рабочих нагрузок, например ведения журнала и данных Интернета вещей.

## <a name="handling-retries"></a>Обработка повторных попыток

Клиентская библиотека службы хранилища Azure помогает определить, какие ошибки можно повторить. Например, ошибка 404 (ресурс не найден) может быть повторена, так как повторная попытка, скорее всего, приведет к успешному выполнению. С другой стороны, ошибка 500 не может быть повторена, так как это ошибка сервера, которая может просто быть временной проблемой. Для получения дополнительных сведений ознакомьтесь с [открытым кодом класса ExponentialRetry](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) в клиентской библиотеке службы хранилища для .NET. (Найдите метод ShouldRetry.)

### <a name="read-requests"></a>Запросы на чтение

В случае проблем с основным хранилищем запросы на чтение можно перенаправлять в дополнительное хранилище. Как было отмечено выше в разделе [Использование данных, согласованных в конечном счете](#using-eventually-consistent-data), для вашего приложения должно быть приемлемым чтение потенциально устаревших данных. При использовании клиентской библиотеки хранилища для доступа к данным из базы данных-получателя можно указать поведение повтора запроса на чтение, задав для свойства **LocationMode** одно из следующих значений:

* **PrimaryOnly** (по умолчанию);

* **PrimaryThenSecondary**;

* **SecondaryOnly**;

* **SecondaryThenPrimary**.

Если для параметра **LocationMode** задано значение **примарисенсекондари**, то в случае сбоя первоначального запроса на чтение к первичной конечной точке с ошибкой, которую можно повторить, клиент автоматически выполняет еще один запрос чтения к дополнительной конечной точке. Если ошибка возникла из-за времени ожидания сервера, то клиенту придется дождаться, пока не истечет время ожидания, прежде чем служба вернет ему сообщение об ошибке, допускающей повторение.

По сути, решая, как реагировать на ошибки, допускающие повторение, следует учитывать два сценария:

* Это изолированная проблема, и последующие запросы к основной конечной точке не вернут ошибку, допускающую повторение. Например, такая ситуация может сложиться при временной ошибке в сети.

    В этом сценарии присвоение **LocationMode** значения **PrimaryThenSecondary** почти не скажется на производительности, так как это происходит редко.

* Это проблема в работе по крайней мере одной из служб хранилища в основном регионе, и все последующие запросы к этой службе в основном регионе, скорее всего, какое-то время будут возвращать ошибки, допускающие повторение. Примером этого является ситуация, когда основной регион полностью недоступен.

    В этом сценарии производительность снижается, так как все запросы на чтение сначала будут пытаться использовать основную конечную точку и ждать истечения времени ожидания, а затем переключаться на дополнительную конечную точку.

В таких сценариях следует выявлять текущие проблемы с основной конечной точки и отправлять все запросы на чтение напрямую к дополнительной конечной точке, присвоив свойству **LocationMode** значение **SecondaryOnly**. На данном этапе следует также изменить режим запуска приложения на "только для чтения". Этот подход известен как [шаблон автоматического выключения](/azure/architecture/patterns/circuit-breaker).

### <a name="update-requests"></a>Запросы на обновление

Шаблон автоматического выключения может также применяться для запросов на обновление. Тем не менее запросы на обновление невозможно перенаправлять в дополнительное хранилище, которое доступно только для чтения. Для этих запросов следует оставить используемое по умолчанию значение свойства **LocationMode** — **PrimaryOnly**. Чтобы обработать данные ошибки, можно применить метрики для этих запросов (например, 10 ошибок подряд) и по достижении порога переключать приложение в режим только для чтения. Эти же методы можно использовать для возвращения в режим обновления, как описано в следующем разделе о шаблоне автоматического выключения.

## <a name="circuit-breaker-pattern"></a>Шаблон автоматического выключения

С помощью шаблона автоматического выключения в приложении можно предотвратить повторное выполнение операции, которая, вероятнее всего, будет приводить к повторным сбоям. Это позволяет приложению продолжать работу, а не тратить время на повторение операций по нарастающей. Шаблон также обнаружит, когда будет исправлена ошибка, и в этот момент приложение сможет повторить операцию.

### <a name="how-to-implement-the-circuit-breaker-pattern"></a>Как реализовать шаблон автоматического выключения

Для выявления проблемы в работе основной конечной точки можно отслеживать, как часто клиент сталкивается с ошибками, допускающими повторение. Так как все случаи разные, необходимо определить пороговое значение для переключения на дополнительную конечную точку и запуска приложения в режиме только для чтения. Например, можно выполнять переключение при 10 сбоев подряд, после которых запрос по-прежнему не выполнен. Другой пример: переключение при сбое 90 % запросов в течение 2 минут.

В первом случае можно просто считать число ошибок, и если запрос успешно выполняется до достижения порога, сбрасывать это значение до нуля. Во втором случае для реализации переключения можно использовать объект MemoryCache (в .NET). Для каждого запроса добавьте CacheItem в кэш, задайте значение для успешного (1) или неудачного выполнения (0) и задайте срок действия в 2 минуты от текущего времени (или установленное ограничение времени). По истечении срока действия запись автоматически удаляется. Это обеспечит скользящее окно в 2 минуты. Каждый раз при отправке запроса к службе хранилища сначала используется запрос Linq через объект MemoryCache для вычисления процента успешных операций путем суммирования значений и деления их на количество. Когда процент успешных операций опустится ниже некоторого порога (например, 10 %), следует присвоить свойству **LocationMode** для запросов на чтение значение **SecondaryOnly** и переключить приложение в режим только для чтения, прежде чем продолжить.

Пороговое число ошибок, которое определяет, когда нужно переключить приложение, может отличаться для различных служб в приложении. Поэтому рекомендуется сделать пороговые значения настраиваемыми параметрами. Кроме того, нужно решить, как обрабатывать ошибки, допускающие повторение, от каждой службы — по-отдельности или вместе, как было описано ранее.

Вам следует решить, как будут обрабатываться несколько экземпляров одного приложения и какие действия будут выполняться при обнаружении ошибок, допускающих повторение, в каждом экземпляре. Например, одно приложение может быть загружено на 20 виртуальных машин. Каждый экземпляр будет обрабатываться отдельно? Если в работе одного экземпляра возникают проблемы, требуется ли ответное действие только для этого экземпляра, или вы хотите, чтобы все экземпляры попытались выполнить одинаковое ответное действие в случае проблемы с одним экземпляром? Отдельная обработка экземпляров гораздо проще, чем одновременное координирование ответных действий всех экземпляров, но конкретная реализация зависит от архитектуры приложения.

### <a name="options-for-monitoring-the-error-frequency"></a>Способы мониторинга частоты ошибок

Существует три основных способа мониторинга частоты повторов в основном регионе, позволяющих определить, когда нужно переключиться на дополнительный регион и запустить приложение в режиме только для чтения.

* Добавьте обработчик события [**Retrying**](https://docs.microsoft.com/dotnet/api/microsoft.azure.cosmos.table.operationcontext.retrying) для объекта [**OperationContext**](https://docs.microsoft.com/java/api/com.microsoft.applicationinsights.extensibility.context.operationcontext), передаваемого в запросы к хранилищу. Этот метод показан в этой статье и используется в соответствующем примере. Данные события активируются, когда клиент повторяет запрос, что позволяет отслеживать, как часто клиент сталкивается с ошибками, допускающими повторение, на основной конечной точке.

    ```csharp
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

* В методе [**Evaluate**](https://docs.microsoft.com/dotnet/api/microsoft.azure.cosmos.table.iextendedretrypolicy.evaluate) в пользовательской политике повтора можно выполнять пользовательский код всякий раз, когда происходит повторная попытка. Помимо записи повторных попыток это также дает возможность изменить их режим.

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
            || ((statusCode >= 300 && statusCode < 500 && statusCode != 408)
            || statusCode == 501 // Not Implemented
            || statusCode == 505 // Version Not Supported
            ))
        {
            // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

* Третий подход заключается в реализации пользовательского компонента мониторинга в приложении, который постоянно проверяет связь с конечной точкой основного хранилища с помощью фиктивных запросов на чтение (например, запросов на чтение большого двоичного объекта небольшого размера), чтобы определить его работоспособность. Это может потребовать какое-то количество ресурсов, но не значительное. При обнаружении ошибки, которая достигла порога, выполняется переключение в режим **SecondaryOnly** с доступом только для чтения.

В какой-то момент потребуется переключиться обратно на основную конечную точку и разрешить обновления. Если используется один из первых двух методов, описанных выше, то можно просто переключиться обратно на основную конечную точку и включить режим обновления после истечения произвольного периода времени или выполнения произвольного количества операций. После этого можно будет снова задействовать логику повторных попыток. В случае устранения проблемы будет по-прежнему использоваться основная конечная точка с возможностью обновления данных. Если проблема не устранена, то после нарушения установленных вами условий будет выполнено повторное переключение на дополнительную конечную точку и включен режим только для чтения.

В третьем сценарии, когда при проверке связи конечная точка основного хранилища восстановит работоспособность, можно будет активировать переключение обратно в режим **PrimaryOnly** и не запрещать обновления.

## <a name="handling-eventually-consistent-data"></a>Обработка данных, согласованных в конечном счете

Геоизбыточное хранилище работает путем репликации транзакций из базы данных-источника в дополнительный регион. Репликация гарантирует, что данные во дополнительном регионе *согласованы в конечном счете*. Это означает, что все транзакции в основном регионе в конечном итоге появятся и в дополнительном регионе, но перед этим возможна задержка, и нет никакой гарантии, что транзакции поступят в дополнительный регион в том же порядке, в котором они первоначально были применены в основном регионе. Если транзакции поступают в дополнительный регион не по порядку, то вы *можете* рассматривать данные в этом регионе как несогласованные, пока служба не наверстает упущенное.

В следующей таблице приведен пример того, что может произойти при обновлении сведений о сотруднике, чтобы сделать его членом роли " *Администраторы* ". В этом примере требуется обновить сущность **employee** и изменить в сущности **administrator role** общее число администраторов. Обратите внимание на то, как обновления применяются не по порядку в дополнительном регионе.

| **Time** | **Транзакция**                                            | **Репликация**                       | **Last Sync Time** | **Результат** |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| T0       | Транзакция А: <br> вставка сущности <br> сотрудника в основном регионе. |                                   |                    | Транзакция А вставлена в основной регион,<br> но еще не реплицирована. |
| T1       |                                                            | Транзакция А <br> реплицирована в<br> дополнительный регион. | T1 | Транзакция А реплицирована в дополнительный регион. <br>Значение Last Sync Time обновлено.    |
| T2       | Транзакция Б:<br>Обновление<br> обновление сущности сотрудника<br> в основном регионе.  |                                | T1                 | Транзакция Б записана в основной регион,<br> но еще не реплицирована.  |
| T3       | Транзакция В:<br> Обновление <br>Администратор<br>сущности роли в<br>primary |                    | T1                 | Транзакция В записана в основной регион,<br> но еще не реплицирована.  |
| *T4*     |                                                       | Транзакция В <br>реплицирована в<br> дополнительный регион. | T1         | Транзакция В реплицирована в дополнительный регион.<br>Значение Last Sync Time не обновлено, так как <br>транзакция Б еще не реплицирована.|
| *T5*     | Чтение сущностей <br>из дополнительного региона.                           |                                  | T1                 | Вы получаете устаревшее значение для <br> сущности employee, так как транзакция Б <br> еще не реплицирована. Вы получаете новое значение для<br> сущности administrator role, так как<br> транзакция В реплицирована. Значение Last Sync Time<br> все еще не обновлено, так как транзакция Б<br> не реплицирована. Можно считать сущность<br>administrator role несогласованной, <br>так как ее дата и время превышают <br>значение Last Sync Time. |
| *T6*     |                                                      | Транзакция Б<br> реплицирована в<br> вторичный | T6                 | *T6* — всех транзакции вплоть до В <br>реплицированы, значение Last Sync Time<br> обновлено. |

В этом примере предполагается, что клиент переключается на чтение из дополнительного региона на этапе T5. На этом этапе он может успешно считать сущность **administrator role**, но она содержит число администраторов, которое не согласовано с числом сущностей **employee**, которые на данный момент помечены как администраторы в дополнительном регионе. Клиент просто может отобразить это значение с риском, что оно является несогласованным. Кроме того, клиент может попытаться определить, что сущность **administrator role** является потенциально несогласованной, так как обновления были выполнены не по порядку, и затем информировать пользователей об этом.

Чтобы выявить потенциальную несогласованность данных, клиент может использовать значение *Last Sync Time*, которое можно получить в любое время с помощью запроса к службе хранилища. Оно указывает время, когда данные в дополнительном регионе были согласованными в последний раз и когда служба применила все транзакции, предшествующие этому моменту времени. В примере, показанном выше, после того, как служба вставляет сущность **employee** в дополнительный регион, время последней синхронизации (Last Sync Time) принимает значение *T1*. Значение *T1* сохраняется до момента обновления службой сущности **employee** в дополнительном регионе, после чего Last Sync Time принимает значение *T6*. Если клиент получает время последней синхронизации при чтении сущности на этапе *T5*, то может сравнить его с меткой времени сущности. Если метка времени сущности превышает время последней синхронизации, то сущность является потенциально несогласованной, и вы можете выполнить соответствующее действие для приложения. Чтобы использовать это поле, необходимо знать, когда было завершено последнее обновление в основном регионе.

## <a name="getting-the-last-sync-time"></a>Получение времени последней синхронизации

Вы можете использовать PowerShell или Azure CLI, чтобы получить время последней синхронизации, чтобы определить, когда данные были записаны в базу данных-получатель.

### <a name="powershell"></a>PowerShell

Чтобы получить время последней синхронизации для учетной записи хранения с помощью PowerShell, установите модуль предварительной версии службы хранилища Azure, который поддерживает получение статистики георепликации. Пример:

```powershell
Install-Module Az.Storage –Repository PSGallery -RequiredVersion 1.1.1-preview –AllowPrerelease –AllowClobber –Force
```

Затем проверьте свойство **жеорепликатионстатс. ластсинктиме** учетной записи хранения. Не забудьте заменить значения заполнителей собственными значениями:

```powershell
$lastSyncTime = $(Get-AzStorageAccount -ResourceGroupName <resource-group> `
    -Name <storage-account> `
    -IncludeGeoReplicationStats).GeoReplicationStats.LastSyncTime
```

### <a name="azure-cli"></a>Azure CLI

Чтобы получить время последней синхронизации для учетной записи хранения с помощью Azure CLI, проверьте свойство **жеорепликатионстатс. ластсинктиме** учетной записи хранения. Параметр `--expand` используется для возврата значений свойств, вложенных в **жеорепликатионстатс**. Не забудьте заменить значения заполнителей собственными значениями:

```azurecli
$lastSyncTime=$(az storage account show \
    --name <storage-account> \
    --resource-group <resource-group> \
    --expand geoReplicationStats \
    --query geoReplicationStats.lastSyncTime \
    --output tsv)
```

## <a name="testing"></a>Тестирование

Важно проверить, правильно ли приложение работает при обнаружении ошибок, допускающих повторение. Например, нужно проверить, что приложение переходит на дополнительный регион и переключается в режим только для чтения, когда обнаруживает неполадку, и переключается обратно, когда основной регион снова становится доступным. Для этого требуется способ моделирования ошибок, допускающих повторение, и управления их частотой.

Для перехвата и изменения ответов HTTP в сценарии можно использовать [Fiddler](https://www.telerik.com/fiddler). Этот сценарий может определять ответы от основной конечной точки и заменять код состояния HTTP значением, которое клиентская библиотека службы хранилища распознает как ошибку, допускающую повторение. В этом фрагменте кода показан простой пример сценария Fiddler, который перехватывает ответы, получаемые на запросы на чтение к таблице **employeedata**, чтобы возвращать код состояния 502.

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

Вы можете расширить этот пример, перехватывая более широкий диапазон запросов и изменяя **responseCode** только некоторых из них, чтобы точнее имитировать реальную ситуацию. Дополнительные сведения о настройке сценариев Fiddler см. в разделе [Modifying a Request or Response](https://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) (Изменение запроса или ответа) в документации по Fiddler.

Если вы сделали настраиваемыми пороговые значения для переключения приложения в режим только для чтения, то вам будет проще тестировать его поведение на определенных объемах непроизводственных транзакций.

## <a name="next-steps"></a>Следующие шаги

* Дополнительные сведения о способах чтения из дополнительного региона, включая еще один пример задания свойства время последней синхронизации, см. в статье [параметры избыточности службы хранилища Azure и Геоизбыточное хранилище с доступом на чтение](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).

* Полный пример, демонстрирующий переключение между основной и вторичной конечными точками, см. в статье [примеры Azure: использование шаблона автоматического выключения с хранилищем RA-GRS](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).
