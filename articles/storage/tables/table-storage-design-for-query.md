---
title: Создание табличного хранилища Azure для запросов | Документация Майкрософт
description: Проектирование таблиц для запросов в хранилище таблиц Azure. Выберите подходящий ключ секции, оптимизируйте запросы и отсортируйте данные для службы таблиц.
services: storage
author: tamram
ms.author: tamram
ms.service: storage
ms.topic: article
ms.date: 04/23/2018
ms.subservice: tables
ms.openlocfilehash: 43ae21d97bc9d8292270ae62006e649f4bcf540b
ms.sourcegitcommit: 96918333d87f4029d4d6af7ac44635c833abb3da
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/04/2020
ms.locfileid: "93316158"
---
# <a name="design-for-querying"></a>Разработка для запросов
в решениях службы таблиц может быть связана с большим количеством операций чтения, записи или сочетания этих двух видов нагрузки. В этой статье рассматриваются вопросы, которые необходимо учесть при разработке службы таблиц для эффективной поддержки операций чтения. Как правило, схема, поддерживающая операции чтения, также эффективна для операций записи. Тем не менее, при реализации поддержки операций записи следует придерживаться дополнительных рекомендаций, которые приводятся в статье [Design for data modification](table-storage-design-for-modification.md) (Проектирование изменения данных).

Хорошей отправной точкой для разработки решения службы таблиц с эффективным чтением данных является вопрос о том, какие запросы потребуется выполнить приложению для получения необходимых данных из службы таблиц.  

> [!NOTE]
> Для службы таблиц очень важно правильно заранее спроектировать решение, поскольку его последующие изменения связаны с реализацией трудных и дорогостоящих процессов. Например, чтобы устранить проблемы с производительностью в реляционной базе данных, можно просто добавить индексы в существующую базу данных. Но этот вариант неприемлем для службы таблиц.  
> 
> 

В этом разделе рассматриваются основные вопросы, которые необходимо учитывать при проектировании таблиц для выполнения запросов. В этом разделе затрагиваются следующие темы.

* [Влияние выбора свойств PartitionKey и RowKey на производительность запросов](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [Выбор соответствующего свойства PartitionKey](#choosing-an-appropriate-partitionkey)
* [Оптимизация запросов для службы таблиц](#optimizing-queries-for-the-table-service)
* [Сортировка данных в службе таблиц](#sorting-data-in-the-table-service)

## <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a>Влияние выбора свойств PartitionKey и RowKey на производительность запросов
В следующих примерах предполагается, что сущности сотрудников хранятся в службе таблиц согласно приведенной далее структуре (для большей ясности во многих примерах свойство **Timestamp** опущено).  

| *Имя столбца* | *Data type* |
| --- | --- |
| **PartitionKey** (Название отдела) |Строка |
| **RowKey** (идентификатор сотрудника) |Строка |
| **FirstName** |Строка |
| **LastName** |Строка |
| **Age** |Целое число |
| **EmailAddress** |Строка |

В статье [Общие сведения о Хранилище таблиц Azure](table-storage-overview.md) описываются некоторые ключевые особенности службы таблиц Azure, оказывающие прямое влияние на процесс разработки запросов. С их учетом были сформулированы следующие общие рекомендации по разработке запросов службы таблиц. Обратите внимание, что синтаксис фильтрации, используемый в приведенных ниже примерах, взят из REST API службы таблиц. Дополнительные сведения см. в статье о [сущностях запроса](/rest/api/storageservices/Query-Entities).  

* Запрос * **Point** _ является наиболее эффективным уточняющим запросом для использования и рекомендуется для использования при поиске большого количества томов или уточняющих запросов, для которых требуется наименьшая задержка. Такой запрос может использовать индексы для более эффективного поиска отдельных сущностей, указывая как значения _ *PartitionKey* *, так и **RowKey** . Например: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  
* Второй лучший — * **запрос Range** _, который использует _ *PartitionKey* * и фильтры для диапазона значений **RowKey** , чтобы получить более одной сущности. Значение **PartitionKey** определяет конкретный раздел, а значения **RowKey** определяют подмножество сущностей в этом разделе. Например: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  
* Третье лучше — * **Проверка секций** _, которая использует _ *PartitionKey* * и фильтры в другом неключевом свойстве и может возвращать более одной сущности. Значение **PartitionKey** определяет конкретный раздел и значения свойств, выбранные для подмножества сущностей в этом разделе. Например: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  
* * **Таблица Scan** _ не включает в себя _ *PartitionKey* * и является очень неэффективной, поскольку она ищет все секции, составляющие таблицу, в свою очередь для любых совпадающих сущностей. Просмотр таблицы будет осуществляться независимо от того, использует фильтр свойство **RowKey** или нет. Например: $filter=LastName eq 'Jones'  
* Запросы, возвращающие несколько сущностей, возвращают их отсортированными по свойствам **PartitionKey** и **RowKey**. Чтобы избежать повторной сортировки сущностей в клиенте, выберите свойство **RowKey** , которое определяет самый распространенный порядок сортировки.  

Обратите внимание, что использование **or** для указания фильтра на основе **RowKey** приведет к запуску просмотра раздела и не будет обрабатываться как запрос диапазона. Поэтому следует избегать запросов, использующих следующие фильтры: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322').  

Примеры кода на стороне клиента с использованием клиентской библиотеки хранилища для выполнения запросов см. в следующих разделах.  

* [Выполнение точечного запроса с помощью клиентской библиотеки хранилища](table-storage-design-patterns.md#executing-a-point-query-using-the-storage-client-library)
* [Извлечение нескольких сущностей с помощью LINQ](table-storage-design-patterns.md#retrieving-multiple-entities-using-linq)
* [Проекция на стороне сервера](table-storage-design-patterns.md#server-side-projection)  

Примеры кода на стороне клиента, который может обрабатывать несколько типов сущностей, хранящихся в одной таблице, см. в следующем разделе:  

* [Работа с разными типами сущностей](table-storage-design-patterns.md#working-with-heterogeneous-entity-types)  

## <a name="choosing-an-appropriate-partitionkey"></a>Выбор соответствующего свойства PartitionKey
Выбранное свойство **PartitionKey** должно сбалансировать необходимость использования транзакций группы сущностей (для обеспечения согласованности) и требование к распределению сущностей по нескольким разделам (для построения масштабируемого решения).  

С одной стороны, все сущности можно хранить в одном разделе, но это может ограничить масштабируемость решения, а служба таблиц не сможет балансировать нагрузку запросов. С другой стороны, в каждом разделе можно хранить одну сущность, что обеспечит значительную масштабируемость решения и распределение нагрузки запросов, но не позволит использовать транзакции группы сущностей.  

Идеальное свойство **PartitionKey** позволяет применять эффективные запросы и располагает достаточным количеством разделов для обеспечения масштабируемости решения. Вы поймете, что сущности имеют соответствующее свойство, которое распределяет их по необходимому количеству разделов.

> [!NOTE]
> Например, в системе, где хранятся сведения о пользователях или сотрудниках, идентификатор пользователя (UserID) может быть выражен подходящим значением PartitionKey. Использовать тот или иной идентификатор пользователя (UserID) в качестве ключа раздела могут сразу несколько сущностей. Все сущности, в которых хранятся данные о пользователе, группируются в один раздел. В результате все операции с этими сущностями выполняются через транзакции группы сущностей, но масштабируемость остается высокой.
> 
> 

При выборе свойства **PartitionKey** необходимо учесть ряд дополнительных аспектов, которые имеют отношение к операциям вставки, обновления и удаления сущностей. Дополнительные сведения см. в разделе [Design for data modification](table-storage-design-for-modification.md) (Проектирование изменения данных).  

## <a name="optimizing-queries-for-the-table-service"></a>Оптимизация запросов для службы таблиц
Служба таблиц автоматически индексирует сущности с помощью значений **PartitionKey** и **RowKey** в одном кластеризованном индексе. Именно поэтому точечные запросы самые эффективные. Однако не существует индексов, отличных от кластеризованного индекса, использующего значения **PartitionKey** и **RowKey**.

Многие разработки должны соответствовать требованиям по включению поиска сущностей на основании нескольких условий. Например, поиск сущностей сотрудников на основе адреса электронной почты, кода сотрудника или фамилии. Шаблоны, описанные в разделе [Шаблоны для разработки таблиц](table-storage-design-patterns.md), обеспечивают соответствие этим типам требований и описывают способы работы с тем фактом, что в службе таблиц отсутствуют вторичные индексы.  

* [Шаблон вторичного индекса внутри раздела](table-storage-design-patterns.md#intra-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений **RowKey** (в одной секции) для обеспечения быстрого и эффективного поиска и альтернативных порядков сортировки с использованием различных значений **RowKey** .  
* [Шаблон вторичного индекса в разных разделах](table-storage-design-patterns.md#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений **RowKey** в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  
* [Шаблон сущностей индекса](table-storage-design-patterns.md#index-entities-pattern) — поддержка сущностей индекса для выполнения эффективных операций поиска, возвращающих списки сущностей.  

## <a name="sorting-data-in-the-table-service"></a>Сортировка данных в службе таблиц
Служба таблиц возвращает сущности, отсортированные по возрастанию сначала на основе **PartitionKey** , а затем на основе **RowKey**. Эти ключи являются строковыми значениями. Чтобы правильно отсортировать числовые значения, их необходимо преобразовать в значения фиксированной длины и заполнить нулями. Например, если значение идентификатора сотрудника, используемое в качестве **RowKey** , является целочисленным значением, необходимо преобразовать идентификатор сотрудника **123** в **00000123**.  

Многие приложения предъявляют требования к использованию данных, отсортированных в разных порядках. Например, сотрудники могут быть отсортированы по имена или по дате присоединения. Следующие шаблоны предназначены для выбора альтернативных порядков сортировки для сущностей.  

* [Шаблон вторичного индекса внутри раздела](table-storage-design-patterns.md#intra-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений RowKey (в одном разделе) для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений RowKey.  
* [Шаблон вторичного индекса в разных разделах](table-storage-design-patterns.md#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений RowKey в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений RowKey.
* [Шаблон для заключительного фрагмента журнала](table-storage-design-patterns.md#log-tail-pattern) — извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения **RowKey** , выполняющего сортировку по дате и времени в обратном порядке.  

## <a name="next-steps"></a>Дальнейшие действия

- [Шаблоны проектирования таблиц](table-storage-design-patterns.md)
- [Моделирование отношений](table-storage-design-modeling.md)
- [Шифрование данных таблиц](table-storage-design-encrypt-data.md)
- [Разработка для изменения данных](table-storage-design-for-modification.md)