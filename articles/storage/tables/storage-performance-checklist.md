---
title: Контрольный список для обеспечения масштабируемости и производительности Хранилища таблиц в службе хранилища Azure
description: Контрольный список проверенных методов для работы с Хранилищем таблиц при разработке высокопроизводительных приложений.
services: storage
author: tamram
ms.service: storage
ms.topic: overview
ms.date: 10/10/2019
ms.author: tamram
ms.subservice: tables
ms.openlocfilehash: b36ed2cac7e5009a0581091252b36dcd5af81bd7
ms.sourcegitcommit: bb65043d5e49b8af94bba0e96c36796987f5a2be
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/16/2019
ms.locfileid: "72389990"
---
# <a name="performance-and-scalability-checklist-for-table-storage"></a>Контрольный список для обеспечения масштабируемости и производительности для Хранилища таблиц

Корпорация Майкрософт создала ряд проверенных методик для разработки высокопроизводительных приложений для работы с Хранилищем таблиц. Этот контрольный список определяет основные методики, которые помогут разработчикам оптимизировать производительность. Учитывайте эти рекомендации при проектировании приложения и на протяжении всего процесса разработки.

Служба хранилища Azure имеет целевые показатели по масштабируемости и производительности, выраженные в объемах, скорости транзакций и пропускной способности. Дополнительные сведения о целевых показателях масштабируемости для службы хранилища Azure см. в [этой статье](../common/storage-scalability-targets.md?toc=%2fazure%2fstorage%2ftables%2ftoc.json).

## <a name="checklist"></a>Контрольный список

В этой статье проверенные методы повышения производительности собраны в контрольный список, который пригодится вам при разработке приложения, работающего с Хранилищем таблиц.

| Готово | Категория | Рекомендации по проектированию |
| --- | --- | --- |
| &nbsp; |Целевые показатели масштабируемости |[Можно ли спроектировать приложение так, чтобы количество используемых учетных записей хранения не превышало максимальное значение?](#maximum-number-of-storage-accounts) |
| &nbsp; |Целевые показатели масштабируемости |[Удастся ли вам избежать приближения к предельным значениям емкости и количеству транзакций?](#capacity-and-transaction-targets) |
| &nbsp; |Сеть |[Имеют ли клиентские устройства достаточно высокую пропускную способность и достаточно низкую задержку для достижения необходимой производительности?](#throughput) |
| &nbsp; |Сеть |[Имеют ли клиентские устройства достаточно высокое качество связи?](#link-quality) |
| &nbsp; |Сеть |[Размещено ли клиентское приложение в том же регионе, что и учетная запись хранения?](#location) |
| &nbsp; |Прямой клиентский доступ |[Используются ли подписанные URL-адреса (SAS) и общий доступ к ресурсам независимо от источника (CORS) для организации прямого доступа к службе хранилища Azure?](#sas-and-cors) |
| &nbsp; |Пакетная обработка |[Объединяются ли обновления приложения с использованием транзакций группы сущностей?](#batch-transactions) |
| &nbsp; |Конфигурация .NET |[Используется ли .NET Core 2.1 или более поздней версии, чтобы обеспечить оптимальную производительность?](#use-net-core) |
| &nbsp; |Конфигурация .NET |[Вы настроили свой клиент на использование достаточного количества одновременных подключений?](#increase-default-connection-limit) |
| &nbsp; |Конфигурация .NET |[Настроено ли для приложений .NET использование достаточного количества потоков?](#increase-minimum-number-of-threads) |
| &nbsp; |Parallelism |[Ограничен ли параллелизм достаточным образом, чтобы нагрузка не превышала возможности клиента и не приближалась к целевым показателям масштабируемости?](#unbounded-parallelism) |
| &nbsp; |Средства |[Используются ли последние версии клиентских библиотек и инструментов, предоставленных корпорацией Майкрософт?](#client-libraries-and-tools) |
| &nbsp; |Повторы |[Используется ли политика повтора с экспоненциальной задержкой для ошибок регулирования и превышения времени ожидания?](#timeout-and-server-busy-errors) |
| &nbsp; |Повторы |[Ваше приложение избегает повторов неповторяемых ошибок?](#non-retryable-errors) |
| &nbsp; |Целевые показатели масштабируемости |[Вы приближаетесь к целевым показателям масштабируемости для сущностей в секунду?](#table-specific-scalability-targets) |
| &nbsp; |Конфигурация |[Используете ли вы JSON в запросах таблиц?](#use-json) |
| &nbsp; |Конфигурация |[Отключен ли алгоритм Nagle для повышения производительности небольших запросов?](#disable-nagle) |
| &nbsp; |Таблицы и секции |[Вы правильно разделили свои данные?](#schema) |
| &nbsp; |Горячие секции |[Вы избегаете использования инкрементируемых и декрементируемых шаблонов?](#append-only-and-prepend-only-patterns) |
| &nbsp; |Горячие секции |[Вы распределяете свои вставки и обновления по нескольким разделам?](#high-traffic-data) |
| &nbsp; |Область запроса |[Вы спроектировали свою схему таким образом, чтобы в большинстве случаев использовать точечные запросы, а табличные запросы использовать редко?](#query-scope) |
| &nbsp; |Плотность запросов |[Ваши запросы обычно только сканируют и возвращают строки, которые будет использовать приложение?](#query-density) |
| &nbsp; |Ограничение возвращаемых данных |[Используете ли вы фильтрацию, чтобы избежать возвращения ненужных сущностей?](#limiting-the-amount-of-data-returned) |
| &nbsp; |Ограничение возвращаемых данных |[Используете ли вы проекцию, чтобы избежать возвращения ненужных свойств?](#limiting-the-amount-of-data-returned) |
| &nbsp; |Денормализация |[Вы денормализовали свои данные таким образом, чтобы избежать неэффективных или множественных запросов чтения при попытке получения данных?](#denormalization) |
| &nbsp; |Вставка, обновление и удаление |[Вы применяете пакетную обработку запросов, которые должны быть транзакционными или могут быть выполнены в одно и то же время, чтобы уменьшить число циклов обработки?](#batching) |
| &nbsp; |Вставка, обновление и удаление |[Вы избегаете извлечения сущности только для того, чтобы определить, какую операцию следует выполнить: вставку или обновление?](#upsert) |
| &nbsp; |Вставка, обновление и удаление |[Рассматривали ли вы возможность хранения ряда данных, которые будут часто извлекаться в качестве свойств вместе с единственной сущностью, а не в виде множества сущностей?](#storing-data-series-in-a-single-entity) |
| &nbsp; |Вставка, обновление и удаление |[Для сущностей, которые всегда будут извлекаться вместе и могут быть записаны в пакеты (например, данные временных рядов), рассматривали ли вы возможность использования больших двоичных объектов вместо таблиц?](#storing-structured-data-in-blobs) |

## <a name="scalability-targets"></a>Целевые показатели масштабируемости

Если приложение достигает одного из целевых показателей масштабируемости или превышает его, оно может столкнуться с увеличением задержки транзакций или запуском механизма регулировки количества запросов. Когда служба хранилища Azure применяет регулирование для приложения, она начинает возвращать коды ошибки 503 — Server busy (сервер занят) или 500 — Operation timeout (время ожидания операции истекло). Этих ошибок можно избежать, строго соблюдая ограничения для целевых показателей масштабируемости. Это важная часть стратегии по повышению производительности приложения.

Дополнительные сведения о целевых показателях масштабируемости для службы таблиц см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure для учетных записей хранения](/azure/storage/common/storage-scalability-targets?toc=%2fazure%2fstorage%2ftables%2ftoc.json#azure-table-storage-scale-targets).

### <a name="maximum-number-of-storage-accounts"></a>Максимальное количество учетных записей хранения

Если количество учетных записей хранения приближается к максимальному разрешенному количеству для вашего сочетания подписки и региона, используете ли вы несколько учетных записей хранения на каждый сегмент, чтобы повысить скорость приема, передачи, количество операций ввода-вывода в секунду (IOPS) или емкость хранилища? Для такой ситуации корпорация Майкрософт рекомендует увеличить ограничения по учетным записям хранения, если это возможно, чтобы сократить количество учетных записей хранения для рабочей нагрузки. Запрос на увеличение ограничений на количество учетных записей хранения следует направлять в [службу поддержки Azure](https://azure.microsoft.com/support/options/). Дополнительные сведения см. в [объявлении об учетных записях хранения большего размера и большего масштаба](https://azure.microsoft.com/blog/announcing-larger-higher-scale-storage-accounts/).

### <a name="capacity-and-transaction-targets"></a>Целевые показатели емкости и транзакций

Если приложение достигает целевых показателей масштабируемости, когда речь идет об одной учетной записи хранения, рассмотрите вопрос об использовании одного из следующих подходов:  

- Пересмотрите рабочую нагрузку, которая приводит к достижению приложением целевого показателя масштабируемости или его превышению. Вы можете спроектировать его по-другому, чтобы использовать меньшую полосу пропускания или производительность, или меньшее количество транзакций?
- Если приложение должно превышать какой-то из целевых показателей масштабируемости, создайте несколько учетных записей хранения и сегментируйте между ними данные приложения. При использовании этого подхода необходимо разработать приложение таким образом, чтобы в будущем для балансировки нагрузки в него можно было добавлять другие учетные записи хранения. Плата взимается только за потребление, то есть объем хранимых и передаваемых данных и совершенные транзакции, но не за сами учетные записи хранения.
- Если приложение приближается к целевым показателям пропускной способности, попробуйте применить сжатие данных на стороне клиента, чтобы снизить пропускную способность, требуемую для отправки данных в службу хранилища Azure.
    Этот способ снижает нагрузку на пропускную способность и повышает производительность сети, но может ухудшать общую производительность. Оцените, как дополнительная работа по сжатию и распаковке данных на стороне клиента влияет на производительность. Не забывайте также, что хранение данных в сжатом виде может усложнить устранение неполадок, так как затрудняет просмотр данных с помощью стандартных инструментов.
- Если приложение достигает целевых показателей масштабируемости, обязательно примените экспоненциальную задержку для повторов. Лучше всего сделать так, чтобы приложение не приближалось к целевым показателям масштабируемости. Для этого примените описанные в этой статье рекомендации. Если же потребуется выполнить регулирование, экспоненциальная задержка позволит избежать слишком частых повторов, которые только ухудшают ситуацию. Дополнительные сведения см. в разделе о [превышении времени ожидания и ошибках занятости сервера](#timeout-and-server-busy-errors).

## <a name="table-specific-scalability-targets"></a>Целевые показатели масштабирования для таблиц

В дополнение к ограничениям пропускной способности всей учетной записи хранения таблицы имеют следующее ограничение масштабируемости. Система будет распределять нагрузку по мере увеличения трафика, но если трафик имеет внезапные вспышки, вы будете не в состоянии получить немедленно весь объем пропускной способности. Если метод работает скачками, следует ожидать применения технологии регулировки запросов и (или) тайм-ауты во время скачков по мере того, как служба хранилища автоматически распределяет нагрузку по таблице. Медленное повышение, как правило, дает лучшие результаты, поскольку предоставляет системное время для распределения нагрузки.

## <a name="networking"></a>Сеть

Физические ограничения сети, в которой работает приложение, оказывают существенное влияние на производительность. В следующих разделах описаны некоторые ограничения, с которыми могут столкнуться пользователи.  

### <a name="client-network-capability"></a>Возможности клиентской сети

Пропускная способность и качество сетевого подключения являются важными факторами, влияющими на производительность приложения, как описано в следующих разделах.

#### <a name="throughput"></a>Пропускная способность

Что касается полосы пропускания, частой проблемой являются возможности клиента. Очень крупные экземпляры Azure имеют сетевые карты, обладающие большими возможностями, поэтому если необходимы более высокие сетевые ограничения от одной машины, следует рассмотреть возможность использования более крупного экземпляра или большего количества виртуальных машин. Если локальное приложение будет обращаться к службе хранилища Azure, примените ту же стратегию. Оцените сетевые возможности клиентского устройства и подключения к расположению службы хранилища Azure, а затем увеличьте их до необходимого уровня или учтите эти ограничения при проектировании приложения.

#### <a name="link-quality"></a>Качество связи

Помните, что состояние любой используемой сети, приводящее к ошибкам и потере пакетов, снижает эффективную пропускную способность.  Использование инструмента WireShark или NetMon может помочь в диагностике этой проблемы.  

### <a name="location"></a>Location

В любой распределенной среде наилучшее быстродействие достигается при нахождении клиента рядом с сервером. Для доступа к хранилищу Azure с наименьшей задержкой лучшим местом для клиента будет его нахождение в том же регионе Azure. Например, если ваше веб-приложение Azure использует службу хранилища Azure, обе службы лучше разместить в пределах одного региона (западная часть США, Юго-Восточная Азия и т. д.). Совместное размещение ресурсов уменьшает задержку и снижает стоимость, так как трафик в пределах одного региона остается бесплатным.  

Если же клиентские приложения, которые используют службу хранилища Azure, не размещены в Azure (например, приложения для мобильных устройств или локальные корпоративные службы), учетную запись хранения следует разместить в регионе, максимально приближенном к этим клиентам, так как это может снизить задержку. Если клиенты разбросаны по всему миру (например, часть в Северной Америке, а остальные в Европе), обдумайте вариант с несколькими учетными записями хранения, по одной в каждом регионе. Такой подход легче реализовать, если данные, которые хранят приложения, предназначены для отдельных пользователей, и не требуют репликации между учетными записями хранения.

## <a name="sas-and-cors"></a>SAS и CORS

Предположим, что вам нужно создать код JavaScript, который выполняется в веб-браузере пользователя или приложении на мобильном телефоне и обращается к данным в службе хранилища Azure. Один из вариантов — создать приложение-службу, которое выполнит роль прокси-сервера. Устройство пользователя проходит проверку подлинности в этой службе, которая, в свою очередь, предоставляет доступ к ресурсам службы хранилища Azure. Таким образом, на небезопасных устройствах можно не сообщать ключи своей учетной записи хранения. Но такой подход создает значительную нагрузку на приложение-службу, через которое проходят все данные, передаваемые между пользовательским устройством и службой хранилища Azure.

Вы можете обойтись без приложения-службы прокси-сервера, обращаясь к службе хранилища Azure с использованием подписанных URL-адресов (SAS). С технологией SAS вы можете разрешить пользовательскому устройству напрямую обращаться к службе хранилища Azure с маркером ограниченного доступа. Например, если пользователь хочет отправить фотографию в приложение, приложение-служба создаст SAS и отправит его на устройство пользователя. Маркер SAS может предоставлять разрешение на запись в ресурс службы хранилища Azure в течение указанного интервала времени. По истечении этого времени маркер SAS становится недействительным. Дополнительные сведения о подписанных URL-адресах см. в статье об [использование подписанных URL-адресов SAS в службе хранилища Azure](../common/storage-sas-overview.md).  

Обычно браузер не разрешает выполнять в коде JavaScript некоторые операции, например запись данных, в домене, отличном от домена размещения страницы с этим кодом. Эта политика использования одного источника не позволяет вредоносному коду с любой веб-страницы получить доступ к данным, размещенным на другой странице. Но при создании облачного решения политика использования одного источника становится неудобным ограничением. Реализуемая на уровне браузера технология CORS (общий доступ к ресурсам независимо от источника) позволяет целевому домену сообщать браузеру, что он доверяет запросам, поступающим из определенных исходных доменов.

Предположим, что выполняемое в Azure веб-приложение обращается к ресурсу в учетной записи хранения Azure. В этом сценарии веб-приложение выполняет роль исходного домена, а учетная запись хранения является целевым доменом. Вы можете настроить CORS для любой из служб хранилища Azure, чтобы она сообщала веб-браузеру о том, что служба хранилища Azure доверяет запросам, поступающим из исходного домена. Дополнительные сведения о технологии CORS см. в статье [Cross-Origin Resource Sharing (CORS) support for Azure Storage](/rest/api/storageservices/Cross-Origin-Resource-Sharing--CORS--Support-for-the-Azure-Storage-Services) (Поддержка общего доступа к ресурсам независимо от источника (CORS) для службы хранилища Azure).  
  
Технологии SAS и CORS помогают избавиться от лишней нагрузки на веб-приложения.  

## <a name="batch-transactions"></a>Пакетные транзакции

Служба таблиц поддерживает пакетные транзакции для сущностей, которые находятся в одной таблице и принадлежат к одной группе секций. Дополнительные сведения см. в статье [о выполнении транзакций для группы сущностей](/rest/api/storageservices/performing-entity-group-transactions).

## <a name="net-configuration"></a>Конфигурация .NET

В данном разделе перечислены несколько быстрых параметров конфигурации, которые можно использовать для значительного повышения производительности при использовании платформы .NET Framework.  При использовании других языков проверьте, применяются ли в выбранном языке подобные концепции.  

### <a name="use-net-core"></a>Использование .NET Core

Для разработки приложений, взаимодействующих со службой хранилища Azure, используйте .NET Core 2.1 или более поздних версий, в которых реализованы некоторые улучшения производительности. Мы рекомендуем использовать .NET Core 3.x всегда, когда это возможно.

Дополнительные сведения о повышении производительности в .NET Core вы можете получить в следующих записях блога:

- [о повышении производительности в .NET Core 3.0](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/);
- [о повышении производительности в .NET Core 2.1](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/).

### <a name="increase-default-connection-limit"></a>Увеличение стандартного ограничения на количество подключений

В языке .NET указанный ниже код увеличивает ограничение количества подключений по умолчанию (которое обычно соответствует 2 в клиентской среде или 10 в серверной среде) до 100. В обычном случае следует установить значение, приблизительно соответствующее количеству потоков, используемых приложением.  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

Ограничение количества подключений должно быть установлено до открытия каких-либо подключений.  

Что касается других языков программирования, то для определения механизма установки ограничения числа подключений см. документацию по соответствующему языку.  

Дополнительные сведения см. в записи блога [Web Services: Concurrent Connections ](https://blogs.msdn.microsoft.com/darrenj/2005/03/07/web-services-concurrent-connections/) (Веб-службы: параллельные подключения).  

### <a name="increase-minimum-number-of-threads"></a>Увеличение минимального количества потоков

Если вы используете синхронные вызовы с асинхронными задачами, есть смысл увеличить количество потоков в пуле потоков:

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

См. описание метода [ThreadPool.SetMinThreads](/dotnet/api/system.threading.threadpool.setminthreads).  

## <a name="unbounded-parallelism"></a>Неограниченный параллелизм

Параллелизм часто очень полезен для повышения производительности, но следует с настороженностью относиться к неограниченному параллелизму, то есть к отсутствию ограничений на количество потоков или параллельных запросов. Обязательно ограничьте количество параллельных запросов на отправку или скачивание данных, на доступ к нескольким секциям в одной учетной записи хранения и на доступ к нескольким элементам в одной секции. При неограниченном параллелизме приложение сможет превысить возможности клиентского устройства или целевые показатели масштабируемости для учетных записей хранения, что приведет к увеличению задержек и применению регулирования.  

## <a name="client-libraries-and-tools"></a>Клиентские библиотеки и средства

Для повышения производительности всегда используйте самые последние версии клиентских библиотек и средств, предоставляемых корпорацией Майкрософт. Клиентские библиотеки службы хранилища Azure доступны для многих языков. Обозреватель службы хранилища также поддерживает PowerShell и Azure CLI. Корпорация Майкрософт активно развивает эти клиентские библиотеки и средства, оптимизируя их производительность, поддерживая их согласованность с последними версиями служб и реализуя внутреннюю поддержку для многих проверенных методов повышения производительности. Дополнительные сведения см. в [документации по службе хранилища Azure](/azure/storage/#reference).

## <a name="handle-service-errors"></a>Обработка ошибок службы

Служба хранилища Azure возвращает ошибку, если ей не удается обработать запрос. Понимание ошибок, которые возвращает служба хранилища Azure, и соответствующих сценариев, помогает оптимизировать производительность.

### <a name="timeout-and-server-busy-errors"></a>Ошибки времени ожидания и занятости сервера

Служба хранилища Azure может применять регулирование к приложению, когда его загрузка приближается к ограничениям масштабируемости. В некоторых случаях служба хранилища Azure не может обработать запрос из-за некоторого временного состояния. В обоих случаях служба может вернуть ошибку 503 — Server Busy (сервер занят) или 500 — Timeout (время ожидания истекло). Эти же ошибки могут возникать, когда служба перераспределяет сегменты данных для повышения пропускной способности. В большинстве случаев при получении таких ошибок приложению следует повторить операцию, которая их вызвала. Но если служба хранилища Azure применяет к приложению регулирование из-за превышения целевых показателей масштабируемости или по другим причинам, долго не позволяющим службе обработать запрос, агрессивная стратегия повторов только усугубит проблему. Мы рекомендуем использовать экспоненциальную задержку для политики повтора. Во всех клиентских библиотеках именно такое поведение является вариантом по умолчанию. Например, приложение может повторить действие через 2 секунды, затем через 4 секунды, затем через 10 секунд, затем через 30 секунд, а затем полностью отказаться от повторения. Это позволяет приложению значительно снизить нагрузку на службу и не усугублять проблемы, связанные с регулированием.  

Ошибки подключения могут вызывать немедленные повторы, так как они не являются результатом регулирования количества запросов и, как ожидается, будут временными.  

### <a name="non-retryable-errors"></a>Ошибки без возможности повтора

Клиентские библиотеки обрабатывают повторы с учетом того, допускает ли ошибка возможность повтора. Но если вы напрямую обращаетесь к REST API службы хранилища Azure, учитывайте ограничение на повтор для некоторых ошибок. Например, ошибка 400 — Bad Request (ошибка запроса) означает, что отправленный клиентским приложением запрос имеет неправильный формат и его невозможно обработать. Повторная отправка такого запроса каждый раз будет возвращать тот же ответ, и в таком повторе нет смысла. Если вы напрямую вызываете REST API службы хранилища Azure, учитывайте возможные варианты ошибок и применимость повторов для них.

Дополнительные сведения о кодах ошибок в службе хранилища Azure вы найдете в статье [Status and Error Codes](/rest/api/storageservices/status-and-error-codes2) (Коды ошибок и состояний).

## <a name="configuration"></a>Конфигурация

В этом разделе перечислены несколько параметров быстрой настройки, которые можно использовать для значительного увеличения производительности в Хранилище таблиц:

### <a name="use-json"></a>Использование JSON

Начиная со службы хранилища версии 2013-08-15, для передачи данных таблицы Хранилище таблиц поддерживает формат JSON вместо формата AtomPub на базе XML. Использование JSON может уменьшить размеры полезной нагрузки на 75 %, а следовательно сильно увеличить производительность приложения.

Дополнительные сведения см. в статьях [Windows Azure Tables: Introducing JSON ](https://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) (Таблицы Azure в Windows. Введение в JSON) и [Payload Format for Table Service Operations](https://msdn.microsoft.com/library/azure/dn535600.aspx) (Формат полезных данных для операций службы таблиц).

### <a name="disable-nagle"></a>Отключение алгоритма Нейгла

Алгоритм Нейгла широко применяется во всех TCP/IP-сетях в качестве средства повышения производительности сети. Тем не менее он не является оптимальным во всех случаях (включая высокоинтерактивные среды). Алгоритм Нейгла оказывает негативное влияние на производительность запросов к службе таблиц Azure, и при возможности его следует отключать.

## <a name="schema"></a>Схема

Формат представления и запроса данных является самым важным фактором, влияющим на производительность Хранилища таблиц. Поскольку приложения отличаются друг от друга, в данном разделе излагаются некоторые общие проверенные подходы, которые относятся к:

- конструктору таблиц;
- эффективным запросам;
- эффективным обновлениям данных.

### <a name="tables-and-partitions"></a>Таблицы и секции

Таблицы разделены на разделы. Каждая сущность, хранящаяся в разделе, совместно использует один ключ раздела и имеет уникальный ключ строки для своей идентификации внутри этого раздела. Разделы предоставляют преимущества, но также вводят ограничения по масштабируемости.

- Преимущества: Вы можете обновить сущности в одной секции в рамках одной неделимой пакетной транзакции, содержащей до 100 отдельных операций хранения (общий размер ограничен 4 МБ). Предполагая некоторое количество сущностей, которые будут получены, также можно более эффективно запросить данные, хранящиеся внутри одного раздела, чем данные, охватывающие несколько разделов (в то время как чтение по дальнейшим рекомендациям необходимо проводить по запрашиваемым табличным данным).
- Ограничения масштабируемости. Невозможно сбалансировать нагрузку доступа к сущностям, хранящимся в одной секции, поскольку секции поддерживают неделимые пакетные транзакции. По этой причине целевой показатель масштабируемости для отдельного раздела таблицы ниже, чем для службы таблиц в целом.

Учитывая эти характеристики таблиц и разделов, следует принять следующие принципы проектирования:

- Располагайте в одной секции данные, которые клиентское приложение часто обновляет или запрашивает в одном логическом блоке работы. Например, разместите в одной секции данные, если приложение накапливает операции записи или выполняет атомарные пакетные операции. Кроме того, данные, находящиеся в одном разделе, могут быть с большим успехом запрошены в одном обращении, чем данные, которые находятся в разных разделах.
- Данные, которые клиентское приложение не вставляет, не обновляет и не запрашивает в одном логическом блоке работы (одном запросе или пакетном обновлении), можно размещать в отдельных секциях. Не забывайте, что не существует ограничения на количество ключей секции в одной таблице, так что несколько миллионов ключей секции не станут проблемой и не ухудшат производительность. Например, если приложение является популярным веб-сайтом с механизмом входа пользователя в систему, в качестве ключа раздела может хорошо подойти идентификатор пользователя.

#### <a name="hot-partitions"></a>Горячие секции

Горячий раздел — это раздел, который получает несоразмерный процент трафика на одну учетную запись и не может распределять нагрузку между разделами, так как является единственным разделом. Обычно горячие разделы создаются одним из двух способов:

#### <a name="append-only-and-prepend-only-patterns"></a>Инкрементируемые и декрементируемые шаблоны

"Инкрементируемый" шаблон предполагает, что весь (или почти весь) трафик для определенного ключа секции увеличивается и уменьшается в зависимости от текущего времени. Примером может служить ситуация, при которой приложение использует текущую дату в качестве ключа секции для данных журнала. Это приводит к тому, что все операции вставки выполняются в последнем секции таблицы и система не может распределять нагрузку. Если объем трафика в этом разделе превышает целевой показатель масштабируемости на уровне раздела, это приведет к включению механизма регулировки количества запросов. Обеспечение отправки трафика к нескольким секциям — более удачный вариант, чем включение механизма распределения нагрузки при запросах по всей таблице.

#### <a name="high-traffic-data"></a>Данные с интенсивным трафиком

Если схема создания разделов приводит к созданию одного раздела, в котором имеются только данные, которые используются значительно чаще, чем данные в других разделах, по мере достижения этим разделом целевого показателя масштабируемости для одного раздела можно также обнаружить, что включен механизм регулировки количества запросов. Лучше всего сделать так, чтобы в схеме секционирования не было отдельных секций, приближающихся к целевым показателям масштабируемости.

### <a name="querying"></a>Выполнение запроса

В этом разделе описываются проверенные подходы, касающиеся выполнения запросов Хранилища таблиц.

#### <a name="query-scope"></a>Область запроса

Существует несколько способов для определения диапазона сущностей для запросов. В следующем списке описаны все варианты для области действия запроса.

- **Точечные запросы** извлекают ровно одну сущность, указывая одновременно ключ секции и ключ строки нужной сущности. Эти запросы являются эффективными, и их следует использовать везде, где это возможно.
- **Запросы разделов**. Запрос раздела — это запрос, который извлекает набор данных, совместно использующих общий ключ раздела. Как правило, в запросе указывается диапазон значений ключа строки или — в дополнение к ключу раздела — диапазон значений для свойства некоторой сущности. Такие запросы менее эффективны, чем точечные запросы, и их следует использовать с осторожностью.
- **Табличные запросы**. Табличный запрос — это запрос, который извлекает набор сущностей, не использующих совместно общий ключ раздела. Эти запросы не являются эффективными, и, если это возможно, следует избегать их использования.

В целом, старайтесь избегать сканирования (запросы, превышающие одну сущность), но если это необходимо, попытайтесь организовать данные таким образом, чтобы сканирование извлекало необходимые данные без сканирования или возвращения значительного количества ненужных сущностей.

#### <a name="query-density"></a>Плотность запросов

Еще одним важным фактором в эффективности запроса является соотношение между количеством возвращенных сущностей и количеством сканированных сущностей, использованных при поиске возвращаемого набора. Если приложение выполняет табличный запрос с фильтром для значения свойства, которое соответствует только 1 % совместно используемых данных, запрос будет сканировать по 100 сущностей для каждой одной сущности, которую он возвращает. Все рассмотренные ранее целевые показатели масштабируемости таблицы относятся к количеству сканированных сущностей, а не к количеству возвращенных сущностей. Это означает, что низкая плотность запроса может легко привести к регулированию количества запросов приложения к Хранилищу таблиц, потому что для извлечения искомой сущности придется сканировать слишком много сущностей. Для получения дополнительной информации о том, как избежать регулирования, см. раздел [Денормализация](#denormalization) ниже.

#### <a name="limiting-the-amount-of-data-returned"></a>Ограничение объема возвращаемых данных

Если известно, что запрос возвращает сущности, которые не нужны клиентскому приложению, постарайтесь применить фильтр для снижения размера возвращаемого набора. Несмотря на то, что не возвращаемые клиенту сущности учитываются в подсчете ограничений масштабируемости, производительность приложения увеличится из-за снижения полезной нагрузки на сеть и сокращения количества сущностей, которые должно обрабатывать клиентское приложение. Не забывайте, что целевые показатели масштабируемости относятся к количеству сканируемых сущностей, поэтому выполнение запроса на фильтрацию большого количества сущностей, может вызвать регулирование количества запросов даже в том случае, если возвращается небольшое число сущностей. Дополнительные сведения о повышении эффективности запросов см. в разделе [Плотность запроса](#query-density).

Если клиентскому приложению необходим лишь ограниченный набор свойств из сущностей таблицы, для ограничения размера возвращаемого набора данных можно использовать проекцию. Как и в случае с фильтрацией, проекция помогает снизить нагрузку на сеть и обработку на стороне клиента.

#### <a name="denormalization"></a>Денормализация

В отличие от работы с реляционными базами данных, проверенные подходы для осуществления эффективного запроса данных таблицы ведут к денормализации данных. То есть дублирование одних данных в нескольких сущностях (для поиска данных можно использовать по одной сущности для каждого ключа) с целью минимизации количества сущностей, которые должен сканировать запрос для поиска необходимых клиенту данных, вместо того чтобы сканировать большое количество сущностей для поиска данных, необходимых приложению. Например, на веб-сайте электронной коммерции может понадобиться найти заказ как по идентификатору клиента (найти заказы данного клиента), так и по дате (найти заказы на определенную дату). В табличном хранилище лучше всего хранить сущность (или ссылку на нее) в двух видах: один с именем таблицы, ключом раздела и ключом строки для облегчения поиска по идентификатору клиента, один для облегчения его поиска по дате.  

### <a name="insert-update-and-delete"></a>Вставка, обновление и удаление

В этом разделе описываются проверенные методики для изменения сущностей, хранящихся в Хранилище таблиц.  

#### <a name="batching"></a>Пакетная обработка

Пакетные транзакции в службе хранилища Azure называются транзакциями группы сущностей. Все операции, выполняющиеся в транзакции группы сущностей, должны производиться в одном разделе и в одной таблице. Везде, где это возможно, используйте транзакции группы сущностей для пакетного выполнения операций вставки, обновления и удаления. Это сокращает количество запросов от клиентского приложения к серверу, снижает количество оплачиваемых транзакций (для целей выставления счетов транзакция группы сущностей считается одной транзакцией, но может содержать до 100 операций с хранилищем) и позволяет выполнять атомарные обновления (в транзакции группы сущностей все операции завершаются успешно или не выполняются вовсе). Использование транзакций групп сущностей дает большие преимущества в средах с большими задержками, например на мобильных устройствах.  

#### <a name="upsert"></a>Upsert

Используйте табличные операции **Upsert** как можно чаще. Существует два типа операций **Upsert**. Оба они могут быть более эффективными, чем обычные операции **Insert** и **Update**:  

- **InsertOrMerge**. Используйте эту операцию, если нужно передать подмножество свойств сущности, но неизвестно, существует ли она. Если сущность существует, она вызывает обновление свойств, включенных в операцию **Upsert** , и оставляет все имеющиеся свойства нетронутыми, если же сущность не существует, вставляется новая сущность. Это похоже на использование проекции в запросе, в котором нужно отправить только изменяющиеся свойства.
- **InsertOrReplace**. Используйте эту операцию, если нужно полностью передать новую сущность, но неизвестно, существует ли она. Используйте эту операцию, если известно, что новая сущность является абсолютно правильной, так как она полностью заменяет старую сущность. Например, необходимо обновить сущность, в которой хранится текущее местоположение пользователя, независимо от того, сохраняло ли ранее приложение данные о местоположении пользователя. В данном случае создается сущность с новым местоположением пользователя, а потребность в какой-либо информации из любой предыдущей сущности отсутствует.

#### <a name="storing-data-series-in-a-single-entity"></a>Хранение ряда данных в одной сущности

Иногда приложение хранит ряд данных, которые часто бывают необходимыми для их единовременного получения: например, приложение может отслеживать загрузку ЦП в течение долгого времени для того, чтобы построить волнообразный график из данных за последние 24 часа. Один подход заключается в том, чтобы для каждого часа иметь одну табличную сущность, при этом каждая сущность представляет определенный час и хранит значение загрузки ЦП для этого часа. Для построения этих данных приложению необходимо извлечь сущности, в которых хранятся данные за последние 24 часа.  

Кроме того, приложение может хранить данные о загрузке ЦП для каждого часа в виде отдельного свойства одной сущности: для ежечасного обновления приложение может использовать один вызов **InsertOrMerge Upsert**, чтобы обновить значение за последний час. Для построения этих данных приложению необходимо получить только одну сущность, а не 24, что означает повышение эффективности запроса. Дополнительные сведения об эффективности запросов см. в разделе [Плотность запроса](#query-scope).

#### <a name="storing-structured-data-in-blobs"></a>Хранение структурированных данных в BLOB-объектах

Если вы выполняете пакетные вставки с последующим извлечением целых диапазонов сущностей, попробуйте применить большие двоичные объекты вместо таблиц. Хорошим примером такой ситуации является файл журнала. Данные журнала за несколько минут можно укомплектовать в пакет, затем передать их в хранилище и извлекать партиями по несколько минут за раз. В этом случае производительность будет выше при работе с большими двоичными объектами, чем с таблицами, так как существенно снижается количество записываемых и (или) возвращаемых объектов и количество необходимых для этого запросов.  

## <a name="next-steps"></a>Дополнительная информация

- [Azure Storage scalability and performance targets for storage accounts](../common/storage-scalability-targets.md?toc=%2fazure%2fstorage%2ftables%2ftoc.json) (Целевые показатели масштабируемости и производительности службы хранилища Azure для учетных записей хранения)
- [Состояния и коды ошибок](/rest/api/storageservices/Status-and-Error-Codes2)
