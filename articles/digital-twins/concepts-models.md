---
title: Настраиваемые модели
titleSuffix: Azure Digital Twins
description: Узнайте, как в Azure Digital двойников используются пользовательские модели для описания сущностей в среде.
author: baanders
ms.author: baanders
ms.date: 3/12/2020
ms.topic: conceptual
ms.service: digital-twins
ms.openlocfilehash: 0a38f9b8135fed08a95df68f108e44c34fec6325
ms.sourcegitcommit: cd9754373576d6767c06baccfd500ae88ea733e4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2020
ms.locfileid: "94955333"
---
# <a name="understand-twin-models-in-azure-digital-twins"></a>Общие сведения о моделях двойника в Azure Digital двойников

Ключевой характеристикой Azure Digital двойников является возможность определения собственного словаря и создания графа двойника в самостоятельно определенных условиях вашего бизнеса. Эта возможность предоставляется с помощью пользовательских **моделей**. Модели можно рассматривать как существительные в описании мира. 

Модель похожа на **класс** в объектно-ориентированном языке программирования, определяя фигуру данных для одной конкретной концепции в реальной рабочей среде. Модели имеют имена (например, *комнаты* или *датчик температуры*) и содержат элементы, такие как свойства, данные телеметрии и события, и команды, которые описывают, что может делать сущность этого типа в вашей среде. Позже эти модели будут использоваться для создания [**цифровых двойников**](concepts-twins-graph.md) , представляющих определенные сущности, которые соответствуют этому описанию типа.

Модели цифровых двойников Azure представлены на **языке определения цифровых двойника** на основе JSON-LD (дтдл).  

## <a name="digital-twin-definition-language-dtdl-for-models"></a>Язык определения цифровых двойника (ДТДЛ) для моделей

Модели для Azure Digital двойников определяются с помощью языка определения цифровых двойников (ДТДЛ). ДТДЛ основан на JSON-LD и не зависит от языка программирования. ДТДЛ не является эксклюзивным для Azure Digital двойников, но также используется для представления данных устройства в других службах IoT, таких как [iot Plug and Play](../iot-pnp/overview-iot-plug-and-play.md). 

В Azure Digital двойников используется **дтдл _версии 2_**. Дополнительные сведения об этой версии ДТДЛ см. в документации по спецификациям на сайте GitHub: [*Digital двойников Definition Language (дтдл) — версия 2*](https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md). Использование ДТДЛ _версии 1_ с Azure Digital двойников теперь устарело.

> [!NOTE] 
> Не все службы, использующие ДТДЛ, реализуют одни и те же функции ДТДЛ. Например, IoT Plug and Play не использует функции ДТДЛ, предназначенные для графов, в то время как Azure Digital двойников в настоящее время не реализует команды ДТДЛ.
>
> Дополнительные сведения о функциях ДТДЛ, относящихся к Azure Digital двойников, см. в подразделе далее в этой статье, посвященной [особенностям реализации Azure Digital ДВОЙНИКОВ дтдл](#azure-digital-twins-dtdl-implementation-specifics).

## <a name="elements-of-a-model"></a>Элементы модели

В определении модели элемент кода верхнего уровня является **интерфейсом**. Это инкапсулирует всю модель, а остальная часть модели определяется в интерфейсе. 

Интерфейс модели ДТДЛ может содержать ноль, одно или несколько из следующих полей:
* Свойства **Свойства** — это поля данных, которые представляют состояние сущности (например, свойства во многих языках объектно-ориентированного программирования). Свойства имеют резервное хранилище и могут быть считаны в любое время.
* **Телеметрии** — поля телеметрии представляют измерения или события, и часто используются для описания считывания датчика устройства. В отличие от свойств, данные телеметрии не хранятся в цифровом двойника; Это ряд событий данных, привязанных к времени, которые должны обрабатываться по мере их возникновения. Дополнительные сведения о различиях между свойствами и данными телеметрии см. в разделе Свойства и данные [*телеметрии*](#properties-vs-telemetry) ниже.
* **Компонент Components** -Components позволяет при необходимости построить интерфейс модели как сборку других интерфейсов. Примером компонента является интерфейс *фронткамера* (и другая интерфейсная *Камера*), который используется при определении модели для *телефона*. Необходимо сначала определить интерфейс для *фронткамера* , как если бы он был собственной моделью, а затем ссылаться на него при определении *телефона*.

    Используйте компонент для описания того, что является неотъемлемой частью решения, но не требует отдельного удостоверения, и его не нужно создавать, удалять или переупорядочивать в графе двойника независимо друг от друга. Если требуется, чтобы сущности имели независимые существования на графе двойника, они представляют их как отдельные цифровые двойников различных моделей, Соединенные *связями* (см. следующий маркер).
    
    >[!TIP] 
    >Компоненты также можно использовать для Организации, чтобы сгруппировать наборы связанных свойств в интерфейсе модели. В этом случае каждый компонент можно считать пространством имен или папкой внутри интерфейса.
* Отношения « **связь-отношение** » позволяют представить, как цифровые двойника могут быть вовлечены в другие цифровые двойников. Отношения могут представлять различные семантические значения, например *Contains* ("этаж содержит комнату"), *выисбилледто* *("* охлаждение"), "(" для пользователя "и т. д.") и т. д. Связи позволяют решению предоставлять граф взаимосвязанных сущностей.

> [!NOTE]
> [Спецификация дтдл](https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md) также определяет **команды**, которые являются методами, которые могут быть выполнены в цифровом двойника (например, команда Reset) или команда для переключения вентилятора. Однако *команды в настоящее время не поддерживаются в Azure Digital двойников.*

### <a name="properties-vs-telemetry"></a>Сравнение свойств и телеметрии

Ниже приведены некоторые дополнительные рекомендации по различению полей **свойств** и **телеметрии** Дтдл в Azure Digital двойников.

Разница между свойствами и телеметрии для моделей Azure Digital двойников выглядит следующим образом:
* Ожидается, что в **свойствах** должно быть резервное хранилище. Это означает, что вы можете прочитать свойство в любое время и получить его значение. Если свойство доступно для записи, можно также сохранить значение в свойстве.  
* Данные **телеметрии** больше подобны потоку событий; это набор сообщений данных с короткими сроками существования. Если вы не настраиваете прослушивание события и действия, которые необходимо выполнить, в дальнейшем Трассировка события не выполняется. Вы не сможете вернуться к нему и прочитать его позже. 
  - В терминах C# данные телеметрии подобны событию C#. 
  - В терминах Интернета вещей телеметрические данные обычно представляют собой единое измерение, отправляемое устройством.

Данные **телеметрии** часто используются с устройствами Интернета вещей, так как многие устройства не поддерживают или заинтересованы в хранении значений измерений, которые они создают. Они просто отправляют их в виде потока событий телеметрии. В этом случае невозможно выполнить запрос на устройстве в любое время для последнего значения поля телеметрии. Вместо этого необходимо прослушивать сообщения с устройства и принимать меры по мере поступления сообщений. 

В результате при проектировании модели в Azure Digital двойников вы, вероятно, будете использовать **Свойства** в большинстве случаев для моделирования двойников. Это позволяет иметь резервное хранилище и возможность читать и запрашивать поля данных.

Данные телеметрии и свойства часто работают вместе для обработки входящих данных с устройств. Так как все входящие данные в Azure Digital двойников выполняются через [API-интерфейсы](how-to-use-apis-sdks.md), для считывания данных телеметрии или событий свойств с устройств, как правило, используется функция входящих данных, а в ответе — свойство ADT. 

Вы также можете опубликовать событие телеметрии из API цифровых двойников Azure. Как и в случае с другими данными телеметрии, это кратковременное событие, для обработки которого требуется прослушиватель.

### <a name="azure-digital-twins-dtdl-implementation-specifics"></a>Особенности реализации ДТДЛ в Azure Digital двойников

Чтобы модель ДТДЛ была совместима с Azure Digital двойников, она должна соответствовать этим требованиям.

* Все элементы ДТДЛ верхнего уровня в модели должны иметь тип *Interface*. Это обусловлено тем, что интерфейсы API модели Digital двойников могут получить объекты JSON, представляющие интерфейс или массив интерфейсов. В результате на верхнем уровне не допускаются другие типы элементов ДТДЛ.
* ДТДЛ для Azure Digital двойников не должен определять какие бы то ни было *команды*.
* Azure Digital двойников допускает только один уровень вложенности компонентов. Это означает, что интерфейс, используемый в качестве компонента, не может иметь самих компонентов. 
* Интерфейсы не могут быть определены встроенными в других интерфейсах ДТДЛ; они должны быть определены как отдельные сущности верхнего уровня с собственными идентификаторами. Затем, когда другой интерфейс хочет включить этот интерфейс как компонент или через наследование, он может ссылаться на его идентификатор.

Azure Digital двойников также не наблюдает за `writable` атрибутами в свойствах и связях. Хотя это значение можно задать в соответствии со спецификациями ДТДЛ, оно не используется в Azure Digital двойников. Вместо этого они всегда считаются доступными для записи внешними клиентами, которые имеют общие разрешения на запись в службу Digital двойников Azure.

## <a name="example-model-code"></a>Пример кода модели

Модели типов двойника могут быть написаны в любом текстовом редакторе. Язык ДТДЛ соответствует синтаксису JSON, поэтому необходимо хранить модели с расширением *. JSON*. Использование расширения JSON позволит многим текстовым редакторам программирования обеспечить базовую проверку синтаксиса и выделение для документов ДТДЛ. Существует также [расширение дтдл](https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.vscode-dtdl) , доступное для [Visual Studio Code](https://code.visualstudio.com/).

В этом разделе содержится пример типичной модели, написанной как интерфейс ДТДЛ. Модель описывает **планеты**, каждый из которых имеет имя, масса и температуру.
 
Учтите, что планеты также могут взаимодействовать с **лунами** , которые являются их вспомогательными, и могут содержать **кратерс**. В приведенном ниже примере `Planet` модель выражает соединения с другими сущностями, ссылаясь на две внешние модели — `Moon` и `Crater` . Эти модели также определяются в приведенном ниже примере кода, но хранятся очень просто, поэтому не следует полагаться на основной `Planet` пример.

```json
[
  {
    "@id": "dtmi:com:contoso:Planet;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Planet",
    "contents": [
      {
        "@type": "Property",
        "name": "name",
        "schema": "string"
      },
      {
        "@type": "Property",
        "name": "mass",
        "schema": "double"
      },
      {
        "@type": "Telemetry",
        "name": "Temperature",
        "schema": "double"
      },
      {
        "@type": "Relationship",
        "name": "satellites",
        "target": "dtmi:com:contoso:Moon;1"
      },
      {
        "@type": "Component",
        "name": "deepestCrater",
        "schema": "dtmi:com:contoso:Crater;1"
      }
    ]
  },
  {
    "@id": "dtmi:com:contoso:Crater;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
  },
  {
    "@id": "dtmi:com:contoso:Moon;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
  }
]
```

Поля модели:

| Поле | Описание |
| --- | --- |
| `@id` | Идентификатор модели. Значение должно быть в формате `dtmi:<domain>:<unique model identifier>;<model version number>` . |
| `@type` | Определяет тип описываемой информации. Для интерфейса используется тип *Interface*. |
| `@context` | Задает [контекст](https://niem.github.io/json/reference/json-ld/context/) для документа JSON. Модели должны использовать `dtmi:dtdl:context;2` . |
| `displayName` | используемых Позволяет при необходимости присвоить модели понятное имя. |
| `contents` | Все остальные данные интерфейса помещаются здесь в виде массива определений атрибутов. Каждый атрибут должен предоставлять `@type` (*свойство*, *телеметрию*, *команду*, *связь* или *компонент*) для определения того, какую информацию о интерфейсе он описывает, а затем набор свойств, определяющих фактический атрибут (например, `name` и `schema` для определения *Свойства*). |

> [!NOTE]
> Обратите внимание, что интерфейс компонента (*кратер* в этом примере) определен в том же массиве, что и интерфейс, который его использует (*Планета*). Компоненты должны быть определены таким образом в вызовах API, чтобы был найден интерфейс.

### <a name="possible-schemas"></a>Возможные схемы

Как и для дтдл, схема для атрибутов *свойств* и *телеметрии* может иметь стандартные примитивные типы — `integer` , `double` , `string` и, `Boolean` и другие типы, такие как `DateTime` и `Duration` . 

Помимо типов-примитивов, поля *свойств* и *телеметрии* могут иметь следующие сложные типы:
* `Object`
* `Map`
* `Enum`

Поля *телеметрии* также поддерживают `Array` .

### <a name="model-inheritance"></a>Наследование модели

Иногда может потребоваться дальнейшее специализацию модели. Например, может быть полезно иметь универсальное *пространство* модели, а также специализированные варианты *конференцерум* и *ГИМ*. Чтобы выразить специализацию, ДТДЛ поддерживает наследование: интерфейсы могут наследовать от одного или нескольких других интерфейсов. 

В следующем примере демонстрируется повторная модель *планеты* из предыдущего примера дтдл в качестве подтипа более крупной модели *целестиалбоди* . Сначала определяется "родительская" модель, а затем "дочерняя" модель строится на ней с помощью поля `extends` .

```json
[
  {
    "@id": "dtmi:com:contoso:CelestialBody;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Celestial body",
    "contents": [
      {
        "@type": "Property",
        "name": "name",
        "schema": "string"
      },
      {
        "@type": "Property",
        "name": "mass",
        "schema": "double"
      },
      {
        "@type": "Telemetry",
        "name": "temperature",
        "schema": "double"
      }
    ]
  },
  {
    "@id": "dtmi:com:contoso:Planet;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Planet",
    "extends": "dtmi:com:contoso:CelestialBody;1",
    "contents": [
      {
        "@type": "Relationship",
        "name": "satellites",
        "target": "dtmi:com:contoso:Moon;1"
      },
      {
        "@type": "Component",
        "name": "deepestCrater",
        "schema": "dtmi:com:contoso:Crater;1"
      }
    ]
  },
  {
    "@id": "dtmi:com:contoso:Crater;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
  }
]
```

В этом примере *целестиалбоди* вносит имя, масса и температуру в *планеты*. `extends`Раздел представляет собой имя интерфейса или массив имен интерфейсов (что позволяет расширять интерфейс наследовать от нескольких родительских моделей при необходимости).

После применения наследования расширяющий интерфейс предоставляет все свойства из всей цепочки наследования.

Расширяющий интерфейс не может изменять любые определения родительских интерфейсов; Он может добавлять только к ним. Он также не может переопределить возможность, уже определенную в любом из ее родительских интерфейсов (даже если возможности определены как одинаковые). Например, если родительский интерфейс определяет `double` свойство *массы*, то расширяющий интерфейс не может содержать объявление *массы*, даже если это также `double` .

## <a name="best-practices-for-designing-models"></a>Рекомендации по проектированию моделей

При проектировании моделей для отражения сущностей в вашей среде может быть полезно взглянуть на последствия создания [запросов](concepts-query-language.md) . Возможно, вам потребуется спроектировать свойства таким образом, чтобы избежать больших результирующих наборов из обхода графа. Также может потребоваться моделирование связей, которые будут ответить в одном запросе, как одноуровневые связи.

### <a name="validating-models"></a>Проверка моделей

[!INCLUDE [Azure Digital Twins: validate models info](../../includes/digital-twins-validate.md)]

## <a name="integrating-with-industry-standard-models"></a>Интеграция с моделями, основанными на отраслевых стандартах

Использование моделей, основанных на отраслевых стандартах, или использование стандартного представления онтологи, например RDF или OWL, обеспечивает обширную отправную точку при проектировании моделей цифровых двойников Azure. Использование отраслевых моделей также помогает при стандартизации и совместном использовании информации.

Для использования с Azure Digital двойников модель должна быть представлена на [**языке определения цифровых двойников**](concepts-models.md)на основе JSON-LD (дтдл). Поэтому в этой статье описывается, как представить стандартные отраслевые модели в ДТДЛ, интегрируя существующие отраслевые концепции с семантикой ДТДЛ, чтобы в Azure Digital двойников их можно было использовать. Затем модель ДТДЛ выступает в качестве источника истинности модели в Azure Digital двойников.

Существует два основных пути интеграции моделей отрасли с ДТДЛ в зависимости от ситуации.
* Если вы еще не создали модели, их можно спроектировать на основе **существующих дтдл онтологиес** , которые содержат язык, относящийся к вашей отрасли.
* Если у вас уже есть модели, основанные на отраслевых стандартах, **их необходимо преобразовать в дтдл** , чтобы перенести их в Azure Digital двойников.

Дополнительные сведения об этих процессах см. в разделе Практические руководства. [*Интеграция моделей, стандартных для отрасли*](how-to-integrate-models.md).

## <a name="next-steps"></a>Следующие шаги

См. раздел Управление моделями с помощью API-интерфейсов Дигиталтвинмоделс:
* [*Практическое руководство. Управление настраиваемыми моделями*](how-to-manage-model.md).

Или Узнайте, как создаются цифровые двойников на основе моделей:
* [*Основные понятия: Цифровые двойников и двойника Graph*](concepts-twins-graph.md)

