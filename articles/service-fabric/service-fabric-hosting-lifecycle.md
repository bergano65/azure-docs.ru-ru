---
title: Жизненный цикл активации и деактивации Azure Service Fabric
description: Сведения о жизненном цикле приложения и ServicePackage на узле.
author: tugup
ms.topic: conceptual
ms.date: 05/01/2020
ms.author: tugup
ms.openlocfilehash: d8585d0b39e4a4ef9cf77f40ea878ddb47bcb0de
ms.sourcegitcommit: beacda0b2b4b3a415b16ac2f58ddfb03dd1a04cf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/31/2020
ms.locfileid: "97831828"
---
# <a name="azure-service-fabric-hosting-life-cycle"></a>Жизненный цикл размещения Service Fabric Azure

В этой статье приведены общие сведения о событиях, происходящих в Azure Service Fabric при активации приложения на узле. В нем объясняются различные конфигурации кластера, управляющие поведением.

Прежде чем продолжить, убедитесь, что вы понимаете основные понятия и отношения, описанные в разделе [моделирование приложения в Service Fabric][a1]. 

> [!NOTE]
> В этой статье для специализированных способов используется определенная терминология. Если не указано иное:
>
> - Слово *реплика* относится к реплике службы с отслеживанием состояния или экземпляру службы без отслеживания состояния.
> - *CodePackage* обрабатывается как эквивалент процесса ServiceHost, который регистрирует serviceType. Он размещает реплики служб этого ServiceType.
>

## <a name="activate-an-applicationpackage-or-servicepackage"></a>Активация ApplicationPackage или ServicePackage

Чтобы активировать ApplicationPackage или ServicePackage, выполните следующие действия.

1. Скачайте ApplicationPackage (например, *ApplicationManifest.xml*).
2. Настройте среду для приложения. Эти шаги включают, например, создание пользователей.
3. Начать отслеживание приложения для деактивации.
4. Скачайте ServicePackage (например, *ServiceManifest.xml*, код, файлы конфигурации и пакеты данных).
5. Настройте среду для ServicePackage. Эти действия включают, например, настройку брандмауэра и выделение портов для конечных точек.
6. Начать отслеживание ServicePackage для деактивации.
7. Запустите SetupEntryPoint для содержащиеся и дождитесь его завершения.
8. Запустите Маинентрипоинт для содержащиеся.

### <a name="servicetype-blocklisting"></a>ServiceType Добавление
`ServiceTypeDisableFailureThreshold` Определяет число допустимых сбоев активации, загрузки и CodePackage. По достижении порогового значения ServiceType планируется для добавление. Первый сбой активации, сбой скачивания или CodePackageный сбой расписаний ServiceType добавление. 

`ServiceTypeDisableGraceInterval`Конфигурация определяет интервал отсрочки до того, как serviceType добавлен на узле. По мере выполнения этого процесса активация, Загрузка и перезагрузка CodePackage повторно выполняются параллельно. Повторное выполнение означает, например, что CodePackage запускается снова после сбоя или Service Fabric попытается загрузить пакеты снова.

Если ServiceType — добавлен, отображается сообщение об ошибке работоспособности: `'System.Hosting' reported Error for property 'ServiceTypeRegistration:ServiceType'. The ServiceType was disabled on the node.`

На узле снова включается ServiceType, если происходит одно из следующих событий:
- Активация выполнена. В противном случае достигается `ActivationMaxFailureCount` Максимальное число повторных попыток.
- Загрузка выполнена. В противном случае достигается `DeploymentMaxFailureCount` Максимальное число повторных попыток.
- CodePackage запускается и успешно регистрирует ServiceType.

`ActivationMaxFailureCount` и `DeploymentMaxFailureCount` — это максимальное число попыток Service Fabric, которые могут быть предприняты для активации или скачивания приложения на узле. По достижении максимального значения Service Fabric позволяет снова включить ServiceType для активации. 

Эти пороговые значения придают службе другую возможность активации. Если активация прошла успешную активацию, эта ошибка будет автоматически восстановлена. 

Вновь размещенная или активированная реплика может активировать новую операцию активации или скачивания. Это действие завершится с ошибкой или снова Добавление ServiceType.

> [!NOTE]
> Сбой CodePackage, который не регистрирует ServiceType, не влияет на ServiceType. Только сбойный CodePackage, на котором размещается реплика, влияет на ServiceType.
>

### <a name="codepackage-crash"></a>Сбой CodePackage
При сбое CodePackage Service Fabric использует перегрузку для повторного запуска. Режим отхода применяется независимо от того, зарегистрировал ли CodePackage тип с Service Fabricой средой выполнения.

Значение отхода равно `Min(RetryTime, ActivationMaxRetryInterval)` . Значение увеличивается в виде константных, линейных или экспоненциальных сумм на основе `ActivationRetryBackoffExponentiationBase` параметра конфигурации:

- **Константа**: Если `ActivationRetryBackoffExponentiationBase == 0` , то `RetryTime = ActivationRetryBackoffInterval` .
- **Линейный**: Если  `ActivationRetryBackoffExponentiationBase == 0` , то `RetryTime = ContinuousFailureCount ActivationRetryBackoffInterval` , где `ContinuousFailureCount` — количество сбоев CodePackage или сбоя активации.
- **Экспонента**: `RetryTime = (ActivationRetryBackoffInterval in seconds) * (ActivationRetryBackoffExponentiationBase ^ ContinuousFailureCount)` .
    
Поведением можно управлять, изменяя значения. Например, если требуется несколько попыток быстрого перезапуска, можно использовать линейные суммы, задав `ActivationRetryBackoffExponentiationBase` для значение `0` и задав `ActivationRetryBackoffInterval` для значение `10` . Поэтому в случае сбоя CodePackage интервал запуска будет равен 10 секундам. Если пакет продолжит работу, состояние отработки изменится на 20 секунд, 30 секунд, 40 секунд и т. д., пока активация CodePackage не будет выполнена или деактивируется CodePackage. 
    
Максимальное время, в течение которого Service Fabric отключается (то есть ожидает) после того, как ошибка будет управляться `ActivationMaxRetryInterval` .
    
Если CodePackage завершает работу и создает резервную копию, она должна оставаться в течение периода времени, указанного в `CodePackageContinuousExitFailureResetInterval` . По истечении этого интервала Service Fabric считает CodePackage работоспособным. Service Fabric перезаписывает предыдущие отчеты о работоспособности ошибок как ОК и сбрасывает `ContinuousFailureCount` .

### <a name="codepackage-not-registering-servicetype"></a>CodePackage не регистрирует ServiceType
Если CodePackage остается и ожидается регистрация ServiceType, но не Service Fabric создает отчет о работоспособности предупреждения после `ServiceTypeRegistrationTimeout` . Отчет указывает, что ServiceType не был зарегистрирован в течение ожидаемого периода времени.

### <a name="activation-failure"></a>Сбой активации
Когда Service Fabric находит ошибку во время активации, она всегда использует линейную отработку отказа, как в случае сбоя CodePackage. Операция активации обеспечивается после повторных попыток через следующие интервалы: (0 + 10 + 20 + 30 + 40) = 100 секунд. (Первая повторная попытка является немедленной.) После выполнения этой последовательности активация не производится повторно.
    
Максимальное количество переключений активации может быть `ActivationMaxRetryInterval` . Повторная попытка может быть выполнена `ActivationMaxFailureCount` .

### <a name="download-failure"></a>Сбой скачивания
Service Fabric всегда использует линейную откладывание при обнаружении ошибки во время загрузки. Операция активации обеспечивается после повторных попыток через следующие интервалы: (0 + 10 + 20 + 30 + 40) = 100 секунд. (Первая повторная попытка является немедленной.) После выполнения этой последовательности загрузка не будет повторена. 

Линейный отход для загрузки равен `ContinuousFailureCount`  *  `DeploymentRetryBackoffInterval` . Максимальное число переключений может быть равно `DeploymentMaxRetryInterval` . Как и активация, операции скачивания могут повторить попытку `ActivationMaxFailureCount` ограничения.

> [!NOTE]
> Перед изменением этих параметров учитывайте следующие примеры.
>
>* Если CodePackage поддерживает сбой и резервное копирование, ServiceType будет отключен. Но если в конфигурации активации есть быстрый перезапуск, CodePackage может быть несколько раз, прежде чем ServiceType действительно добавлен. 
>
>    Например, предположим, что ваш CodePackage, регистрирует ServiceType с Service Fabric, а затем завершается сбоем. В этом случае после того, как размещение получает регистрацию типа, `ServiceTypeDisableGraceInterval` период отменяется. Этот процесс может повторяться до тех пор, пока CodePackage не будет возвращено значение, превышающее `ServiceTypeDisableGraceInterval` период. Затем ServiceType будет добавлен на узле. Добавление ServiceType может занять больше времени, чем предполагается.
>
>* В случае активации, когда Service Fabric системе необходимо разместить реплику на узле, агент перенастройки запрашивает у подсистемы размещения активацию приложения. Он повторяет запрос на активацию каждые 15 секунд. (Длительность регулируется `RAPMessageRetryInterval` параметром конфигурации.) Service Fabric не может быть уверенным в том, что ServiceType был добавлен, только если операция активации в размещении занимает более длительный период, чем интервал повтора и `ServiceTypeDisableGraceInterval` . 
>
>    Например, предположим, что для кластера `ActivationMaxFailureCount` задано значение 5, а для параметра установлено значение `ActivationRetryBackoffInterval` 1 секунда. В этом случае операция активации будет возобновлена после интервалов (0 + 1 + 2 + 3 + 4) = 10 секунд. (Первая повторная попытка является немедленной.) После выполнения этой последовательности размещение обеспечивает повторную попытку. Операция активации завершается, повторная попытка не будет выполнена через 15 секунд. 
>
>    Service Fabric исчерпали все разрешенные попытки в течение 15 секунд. Таким образом, каждая повторная попытка из агента перенастройки создает новую операцию активации в подсистеме размещения, и шаблон продолжает повторяться. В результате ServiceType никогда не добавлен на узле. Так как ServiceType не будет добавлен на узле, реплика не будет перемещена и выполнена на другом узле.
> 

## <a name="deactivation"></a>Деактивация

Когда ServicePackage активируется на узле, он отменяется для деактивации. Деактивация работает двумя способами:

- **Периодическая деактивация**. в каждой `DeactivationScanInterval` системе система проверяет наличие пакетов служб, которые *никогда не* размещаются в реплике, и помечает их как кандидаты для деактивации.
- **Деактивация репликаклосе**: Если реплика закрыта, то активатор получает `DecrementUsageCount` . Значение счетчика равно 0, если в ServicePackage не размещена ни одна реплика, поэтому ServicePackage является кандидатом на деактивацию.

Режим активации определяет, когда кандидаты планируются на деактивацию. В общем режиме кандидаты на деактивацию планируются после `DeactivationGraceInterval` . В монопольном режиме они планируются после `ExclusiveModeDeactivationGraceInterval` . Если между этими временами происходит новое размещение реплики, деактивация отменяется. 

Дополнительные сведения см. в разделе [монопольный режим и общий режим][a2].

### <a name="periodic-deactivation"></a>Периодическая деактивация
Ниже приведены некоторые примеры периодической деактивации.

* **Пример 1**. Предположим, что деактиватор запускает сканирование во время T ( `DeactivationScanInterval` ). Следующая проверка будет по адресу 2T. Предположим, что активация ServicePackage была выполнена в T + 1. В этом ServicePackage не размещена реплика, поэтому ее необходимо деактивировать. 

    Чтобы быть кандидатом на деактивацию, ServicePackage должен разместить реплику не менее T раз. Он будет иметь право на деактивацию в 2T + 1. Поэтому проверка в 2T не определяет этот ServicePackage как кандидат на деактивацию. 

    Следующий цикл деактивации, 3T, запланирует эту ServicePackage для деактивации, так как теперь пакет находится в состоянии "без реплики" для времени T.  

* **Пример 2**. Предположим, что ServicePackage активируется во время T-1, а деактиватор запускает сканирование в t. В ServicePackage не размещена реплика. При следующем сканировании 2T ServicePackage будет идентифицирован как кандидат на деактивацию, поэтому он будет запланирован на деактивацию.  

* **Пример 3**. Предположим, что ServicePackage активируется в t – 1, а деактиватор запускает сканирование в t. В ServicePackage еще не размещена реплика. Теперь в T + 1 размещена реплика. То есть размещение получает, что `IncrementUsageCount` означает создание реплики. 

    В 2T этот ServicePackage не будет планироваться для деактивации. Поскольку пакет содержит реплику, деактивация будет следовать логике Репликаклосе, как описано в следующем разделе этой статьи.

* **Пример 4**. Предположим, что ServicePackage имеет 10 ГБ. Так как пакет имеет большой размер, Загрузка на узле занимает некоторое время. При активации приложения активатор отслеживает его жизненный цикл. Если `DeactivationScanInterval` задано небольшое значение, ServicePackage может не иметь времени на активацию на узле из-за времени, затраченного на загрузку. Чтобы преодолеть эту проблему, вы можете [скачать ServicePackage заранее на узле][p1] или увеличить `DeactivationScanInterval` . 

> [!NOTE]
> ServicePackage может быть деактивирован в любом месте между ( `DeactivationScanInterval` до 2 * `DeactivationScanInterval` ) + `DeactivationGraceInterval` / `ExclusiveModeDeactivationGraceInterval` . 
>

### <a name="replicaclose-deactivation"></a>Деактивация Репликаклосе

> [!NOTE]
> Этот раздел ссылается на следующие параметры конфигурации:
> - **Деактиватионграцеинтервал** / **Ексклусивемодедеактиватионграцеинтервал**. время, присваиваемое ServicePackage для размещения другой реплики, если она уже размещена в какой-либо реплике. 
> - **Деактиватионсканинтервал**. минимальное время, заданное ServicePackage для размещения реплики, если она *никогда* не размещает реплику, то есть если она не была использована.
>

Система сохраняет количество реплик, которые содержит ServicePackage. Если ServicePackage владеет репликой, а реплика закрыта или отключена, размещение получает `DecrementUsageCount` . При открытии реплики размещение получает `IncrementUsageCount` . 

Уменьшение указывает, что количество реплик, размещаемых ServicePackage, было уменьшено на одну реплику. Когда счетчик сбрасывается в 0, ServicePackage планирует деактивацию. Время, после которого оно будет деактивировано, — `DeactivationGraceInterval` / `ExclusiveModeDeactivationGraceInterval` . 

Например, предположим, что уменьшение происходит в T, и ServicePackage планируется деактивировать в 2T + X ( `DeactivationGraceInterval` / `ExclusiveModeDeactivationGraceInterval` ). В течение этого времени, если размещение получается из `IncrementUsage` -за создания реплики, деактивация отменяется.

### <a name="ctrl--c"></a>CTRL + C
Если ServicePackage передает `DeactivationGraceInterval` / `ExclusiveModeDeactivationGraceInterval` и по-прежнему не размещает реплику, деактивация не может быть отменена. Содержащиеся получает обработчик CTRL + C. Теперь конвейер деактивации должен завершиться, чтобы обработать процесс. 

В течение этого времени, если новая реплика для одного и того же ServicePackageа пытается разместиться, она завершится ошибкой, так как процесс не может перейти от деактивации к активации.

## <a name="cluster-configurations"></a>Конфигурации кластеров

В этом разделе перечислены конфигурации, которые имеют значения по умолчанию, влияющие на активацию и деактивацию.

### <a name="servicetype"></a>ServiceType
- **Сервицетипедисаблефаилуресрешолд**: значение по умолчанию: 1. Пороговое значение для счетчика сбоев; по достижении этого порога FailoverManager уведомляет об отключении типа службы на узле и попытке размещения другого узла.
- **Сервицетипедисаблеграцеинтервал**: по умолчанию: 30 секунд. Интервал времени, по истечении которого можно отключить тип службы.
- **Параметра servicetyperegistrationtimeout**: по умолчанию: 300 с. Время ожидания регистрации ServiceType в Service Fabric.

### <a name="activation"></a>Активация
- **Активатионретрибаккоффинтервал**: по умолчанию: 10 секунд. Интервал переотхода для каждой ошибки активации.
- **Активатионмаксфаилурекаунт**: значение по умолчанию: 20. Максимальное число, для которого система повторит попытку активации после сбоя, прежде чем приступать к выполнению. 
- **Активатионретрибаккоффекспонентиатионбасе**: значение по умолчанию: 1,5.
- **Активатионмаксретринтервал**: по умолчанию: 3 600 с. Максимальный интервал попыток активации после сбоев.
- **Кодепаккажеконтинуаусекситфаилурересетинтервал**: по умолчанию: 300 с. Интервал времени ожидания для сброса счетчика сбоев непрерывного выхода для CodePackage.

### <a name="download"></a>Скачивание
- **Деплойментретрибаккоффинтервал**: значение по умолчанию: 10. Интервал переотхода для сбоя развертывания.
- **Деплойментмаксретринтервал**: по умолчанию: 3 600 с. Максимальный интервал отхода для развертывания после сбоев.
- **Деплойментмаксфаилурекаунт**: значение по умолчанию: 20. Развертывание приложения будет повторено в течение `DeploymentMaxFailureCount` времени до сбоя развертывания этого приложения на узле.

### <a name="deactivation"></a>Деактивация
- **Деактиватионсканинтервал**: по умолчанию: 600 с. Минимальное время, заданное ServicePackage для размещения реплики, если она никогда не размещает реплику (то есть если она не используется).
- **Деактиватионграцеинтервал**: по умолчанию: 60 с. В модели с *общими* процессами время, заданное ServicePackage для повторного размещения другой реплики после того, как она уже размещена в любой реплике.
- **Ексклусивемодедеактиватионграцеинтервал**: по умолчанию: 1 секунда. В модели с *монопольным* процессом время, заданное ServicePackage для повторного размещения другой реплики после того, как она уже размещена в любой реплике.

## <a name="next-steps"></a>Дальнейшие действия

- [Создайте пакет приложения][a3] и подготовьте его к развертыванию.
- [Развертывание и удаление приложений][a4] в PowerShell.

<!--Link references--In actual articles, you only need a single period before the slash-->
[a1]: service-fabric-application-model.md
[a2]: service-fabric-hosting-model.md
[a3]: service-fabric-package-apps.md
[a4]: service-fabric-deploy-remove-applications.md

[p1]: /powershell/module/servicefabric/copy-servicefabricservicepackagetonode
