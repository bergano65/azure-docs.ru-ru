---
title: Рекомендации по проектированию приложений Service Fabric Azure
description: Рекомендации и вопросы проектирования для разработки приложений и служб с помощью Azure Service Fabric.
author: markfussell
ms.topic: conceptual
ms.date: 06/18/2019
ms.author: mfussell
ms.openlocfilehash: 742cd9b1e7480fcc510b61d8987e42b499a1ff20
ms.sourcegitcommit: dabd9eb9925308d3c2404c3957e5c921408089da
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2020
ms.locfileid: "86261196"
---
# <a name="azure-service-fabric-application-design-best-practices"></a>Рекомендации по проектированию приложений Service Fabric Azure

В этой статье приводятся рекомендации по созданию приложений и служб в Azure Service Fabric.
 
## <a name="get-familiar-with-service-fabric"></a>Знакомство с Service Fabric
* Ознакомьтесь с тем, [что вы хотите узнать о Service Fabric?](service-fabric-content-roadmap.md)
* Ознакомьтесь с [Service Fabric сценариями приложений](service-fabric-application-scenarios.md).
* Сведения о выборе модели программирования см. в статье [Service Fabric модель программирования](service-fabric-choose-framework.md).



## <a name="application-design-guidance"></a>Руководство по проектированию приложений
Ознакомьтесь с [общей архитектурой](/azure/architecture/reference-architectures/microservices/service-fabric) Service Fabric приложений и [соображениями проектирования](/azure/architecture/reference-architectures/microservices/service-fabric#design-considerations).

### <a name="choose-an-api-gateway"></a>Выбор шлюза API
Используйте службу шлюза API, которая взаимодействует со службами серверной части, которые затем можно масштабировать. Ниже перечислены наиболее часто используемые службы шлюза API.

- [Управление API Azure](./service-fabric-api-management-overview.md), [интегрированное с Service Fabric](./service-fabric-tutorial-deploy-api-management.md).
- [Центр Интернета вещей Azure](../iot-hub/index.yml) или [концентраторы событий Azure](../event-hubs/index.yml), использующие [Сервицефабрикпроцессор](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/eventhub/Microsoft.Azure.EventHubs.ServiceFabricProcessor) для чтения из разделов концентратора событий.
- [Трæфик обратный прокси-сервер](https://techcommunity.microsoft.com/t5/azure-service-fabric/bg-p/Service-Fabric)с помощью [поставщика Service Fabric Azure](https://docs.traefik.io/v1.6/configuration/backends/servicefabric/).
- [Шлюз приложений Azure](../application-gateway/index.yml).

   > [!NOTE] 
   > Шлюз приложений Azure не интегрируется напрямую с Service Fabric. Управление API Azure обычно является предпочтительным вариантом.
- Собственный пользовательский шлюз веб-приложений [ASP.NET Core](./service-fabric-reliable-services-communication-aspnetcore.md) .

### <a name="stateless-services"></a>Службы без отслеживания состояния
Рекомендуется всегда начинать с создания служб без отслеживания состояния, используя [Reliable Services](./service-fabric-reliable-services-introduction.md) и сохраняя состояние в базе данных azure, Azure Cosmos DB или службе хранилища Azure. Внешнее состояние — это более привычный подход для большинства разработчиков. Такой подход также позволяет использовать возможности запросов в магазине.  

### <a name="when-to-use-stateful-services"></a>Когда следует использовать службы с отслеживанием состояния
Рекомендуется использовать службы с отслеживанием состояния, если имеется сценарий с низкой задержкой и необходимо, чтобы данные были близки к вычислению. В число примеров сценариев входят устройства Интернета вещей Digital двойника, состояние игры, состояние сеанса, кэширование данных из базы данных и длительные рабочие процессы для отслеживания вызовов других служб.

Определите срок хранения данных:

- **Кэшированные данные**. При возникновении проблем с задержкой во внешних хранилищах используйте кэширование. Используйте службу с отслеживанием состояния в качестве собственного кэша данных или воспользуйтесь [Service Fabric сокреатеом распределенного кэша с открытым кодом](https://github.com/SoCreate/service-fabric-distributed-cache). В этом случае вам не нужно беспокоиться о потере всех данных в кэше.
- **Данные, привязанные к времени**. В этом случае необходимо, чтобы данные закрылись для вычислений в течение определенного времени задержки, но можно позволить себе потерять данные в случае *аварии*. Например, во многих решениях IoT данные должны быть близко к вычислению, например при вычислении средней температуры за последние несколько дней, но если эти данные потеряны, то зафиксированные точки данных не важны. Кроме того, в этом сценарии обычно не требуется создавать резервные копии отдельных точек данных. Вы только выполняете резервное копирование вычисленных средних значений, которые периодически записываются во внешнее хранилище.  
- **Долгосрочные данные**. Надежные коллекции могут хранить данные постоянно. Но в этом случае необходимо [подготовиться к аварийному восстановлению](./service-fabric-disaster-recovery.md), включая [настройку периодических политик архивации](./service-fabric-backuprestoreservice-configure-periodic-backup.md) для кластеров. По сути, вы настраиваете то, что произойдет, если кластер уничтожается в случае аварии, где потребуется создать новый кластер, а также как развернуть новые экземпляры приложения и выполнить восстановление из последней резервной копии.

Экономьте расходы и повышайте доступность:
- Вы можете сократить затраты, используя службы с отслеживанием состояния, так как вы не будете получать расходы на доступ к данным и транзакции из удаленного хранилища, а также не хотите использовать другую службу, например кэш Azure для Redis.
- Использование служб с отслеживанием состояния, в основном для хранения, а не для вычислений, является дорогостоящим и не рекомендуется. Выдумайте о службах с отслеживанием состояния в виде вычислений с недорогым локальным хранилищем.
- Путем удаления зависимостей от других служб можно повысить доступность службы. Управление состоянием с высоким уровнем доступности в кластере изолирует вас от других простоев служб или проблем задержки.

## <a name="how-to-work-with-reliable-services"></a>Работа с Reliable Services
Service Fabric Reliable Services позволяет легко создавать службы без отслеживания состояния и с отслеживанием состояния. Дополнительные сведения см. в статье [Введение в Reliable Services](./service-fabric-reliable-services-introduction.md).
- Всегда соблюдайте [токен отмены](./service-fabric-reliable-services-lifecycle.md#stateful-service-primary-swaps) в `RunAsync()` методе для служб без отслеживания состояния и с отслеживанием состояния, а также `ChangeRole()` метод для служб с отслеживанием состояния. В противном случае Service Fabric не знает, можно ли закрыть службу. Например, если вы не принимаете маркер отмены, может произойти значительно больше времени обновления приложения.
-    Открывайте и закрывайте [прослушиватели связи](./service-fabric-reliable-services-communication.md) своевременно и соблюдайте токены отмены.
-    Никогда не смешивать код синхронизации с асинхронным кодом. Например, не используйте `.GetAwaiter().GetResult()` в асинхронных вызовах. Используйте в *стеке вызовов Async.*

## <a name="how-to-work-with-reliable-actors"></a>Работа с Reliable Actors
Service Fabric Reliable Actors позволяет легко создавать виртуальные субъекты с отслеживанием состояния. Дополнительные сведения см. в статье [Введение в Reliable Actors](./service-fabric-reliable-actors-introduction.md).

- Серьезно рассмотрите возможность использования обмена сообщениями между субъектами для масштабирования приложения. Средства, предоставляющие эту службу, включают в себя [сокреате с открытым исходным кодом Service Fabric Pub/](https://service-fabric-pub-sub.socreate.it/) подпрограммы и [служебная шина Azure](/azure/service-bus/).
- Сделайте так, чтобы состояние субъекта было как [можно более детализированным](./service-fabric-reliable-actors-state-management.md#best-practices).
- Управление [жизненным циклом субъекта](./service-fabric-reliable-actors-state-management.md#best-practices). Удалите субъекты, если они не будут использоваться повторно. Удаление ненужных субъектов особенно важно, если вы используете [Временный поставщик состояний](./service-fabric-reliable-actors-state-management.md#state-persistence-and-replication), так как все состояния хранятся в памяти.
- Из-за [параллелизма, основанной на поочередности](./service-fabric-reliable-actors-introduction.md#concurrency), субъекты лучше использовать как независимые объекты. Не создавайте графы синхронных вызовов методов с несколькими субъектами (каждый из которых, скорее всего, станет отдельным сетевым вызовом) или создайте запросы с циклическими субъектами. Это значительно повлияет на производительность и масштабируемость.
- Не смешивать код синхронизации с асинхронным кодом. Используйте асинхронный режим для предотвращения проблем с производительностью.
- Не делайте долго выполняющихся вызовов в субъектах. Длительные вызовы будут блокировать другие вызовы одного и того же субъекта из-за параллелизма, основанной на последующей блокировке.
- Если вы обмениваетесь данными с другими службами с помощью [Service Fabric удаленного взаимодействия](./service-fabric-reliable-services-communication-remoting.md) и создаете `ServiceProxyFactory` , Создайте фабрику на уровне [службы субъекта](./service-fabric-reliable-actors-using.md) , а *не* на уровне субъекта.


## <a name="application-diagnostics"></a>Диагностика приложения
Будьте в полной мере добавим [ведение журнала приложений](./service-fabric-diagnostics-event-generation-app.md) в вызовах служб. Она поможет в диагностике сценариев, в которых службы вызывают друг друга. Например, если вызов метода B вызывает C, то вызов может завершиться ошибкой в любом месте. Если ведение журнала не имеет достаточного количества, трудно диагностировать сбои. Если службы имеют слишком много записей из-за вызова томов, убедитесь, что по крайней мере ошибки в журнале и предупреждения.

## <a name="iot-and-messaging-applications"></a>Приложения IoT и Messaging
При чтении сообщений из [центра Интернета вещей Azure](../iot-hub/index.yml) или [концентраторов событий Azure](../event-hubs/index.yml)используйте [сервицефабрикпроцессор](https://github.com/Azure/azure-event-hubs/tree/master/samples/DotNet/Microsoft.Azure.EventHubs/ServiceFabricProcessor). Сервицефабрикпроцессор интегрируется с Service Fabric Reliable Services для поддержания состояния чтения из разделов концентратора событий и отправки новых сообщений службам с помощью `IEventProcessor::ProcessEventsAsync()` метода.


## <a name="design-guidance-on-azure"></a>Руководство по проектированию в Azure
* Руководство по проектированию [микрослужб в Azure](/azure/architecture/microservices/)см. в [центре архитектуры Azure](/azure/architecture/microservices/) .

* Руководство по проектированию [с использованием Service Fabric в игровых службах](/gaming/azure/reference-architectures/multiplayer-synchronous-sf)см. в статье [Начало работы с Azure для игр](/gaming/azure/) .
