---
title: Набор пакетной обработки для речевых контейнеров
titleSuffix: Azure Cognitive Services
description: Использование пакета пакетной обработки для масштабирования запросов речевого контейнера.
services: cognitive-services
author: aahill
manager: nitinme
ms.service: cognitive-services
ms.subservice: speech-service
ms.topic: conceptual
ms.date: 07/07/2020
ms.author: aahi
ms.openlocfilehash: 3cd6febfc774b214a8c1ae8553e6c127c4f452fa
ms.sourcegitcommit: 32c521a2ef396d121e71ba682e098092ac673b30
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/25/2020
ms.locfileid: "91319084"
---
# <a name="batch-processing-kit-for-speech-containers"></a>Набор пакетной обработки для речевых контейнеров

Использование пакета пакетной обработки для дополнения и масштабирования рабочих нагрузок в контейнерах речи. Эта служебная программа с открытым кодом, доступная в качестве контейнера, позволяет упростить запись пакетов для большого количества звуковых файлов в любом количестве локальных и облачных конечных точек контейнера речи. 

:::image type="content" source="media/containers/general-diagram.png" alt-text="Схема, на которой показан пример рабочего процесса контейнера пакета пакетной службы.":::

Контейнер пакета пакетной службы доступен бесплатно в [GitHub](https://github.com/microsoft/batch-processing-kit) и   [DOCKER Hub](https://hub.docker.com/r/batchkit/speech-batch-kit/tags). [Плата взимается](speech-container-howto.md#billing) только за используемые контейнеры речи.

| Компонент  | Описание  |
|---------|---------|
| Распространение пакетного звукового файла     | Автоматическая отправка большого количества файлов в локальные или облачные конечные точки контейнера речи. Файлы могут находиться на любом томе, совместимом с POSIX, в том числе в сетевых файловых системах.       |
| Интеграция с пакетом SDK для распознавания речи | Передайте общие флаги в пакет SDK для распознавания речи, включая: n-лучшие данные, диаризатион, язык, маскировка на ненормативную лексику.  |
|Режимы выполнения     | Запустите клиент пакетной службы один раз, непрерывно в фоновом режиме или создайте конечные точки HTTP для звуковых файлов.         |
| Отказоустойчивость | Автоматическая повторная попытка и продолжение записи без потери хода выполнения, а также различие между ошибками и невозможностью повторной попытки. |
| Обнаружение доступности конечной точки | Если конечная точка становится недоступной, клиент пакетной службы продолжит фотографировать, используя другие конечные точки контейнера. После того как снова станет доступным, клиент автоматически начнет использовать конечную точку.   |
| Горячая замена конечной точки | Добавление, удаление и изменение конечных точек контейнера речи во время выполнения без прерывания выполнения пакета. Обновления выполняются немедленно. |
| Ведение журнала в режиме реального времени | Ведение журнала предпринятых запросов, отметок времени и причин сбоя в режиме реального времени с файлами журнала пакета SDK для речевых файлов для каждого аудиофайла. |

## <a name="get-the-container-image-with-docker-pull"></a>Получение образа контейнера с помощью `docker pull`

Используйте команду [DOCKER Pull](https://docs.docker.com/engine/reference/commandline/pull/) , чтобы скачать последний контейнер пакета пакетов.

```bash
docker pull docker.io/batchkit/speech-batch-kit:latest
```

## <a name="endpoint-configuration"></a>Конфигурация конечной точки

Клиент пакетной службы принимает файл конфигурации YAML, в котором указаны локальные конечные точки контейнера. Следующий пример можно записать в `/mnt/my_nfs/config.yaml` , который используется в примерах ниже. 

```yaml
MyContainer1: 
  concurrency: 5 
  host: 192.168.0.100 
  port: 5000 
  rtf: 3 
MyContainer2: 
  concurrency: 5 
  host: BatchVM0.corp.redmond.microsoft.com 
  port: 5000 
  rtf: 2 
MyContainer3: 
  concurrency: 10 
  host: localhost 
  port: 6001 
  rtf: 4 
```

В этом примере YAML в трех узлах указаны три речевых контейнера. Первый узел задается IPv4-адресом, второй — на той же виртуальной машине, что и клиент пакетной службы, а третий контейнер указывается именем узла DNS другой виртуальной машины. `concurrency`Значение указывает максимальное число одновременных записей в файле, которые могут выполняться в одном контейнере. `rtf`Значение (фактор реального времени) является необязательным и может использоваться для настройки производительности.
 
Клиент пакетной службы может динамически определять, становится ли конечная точка недоступной (например, из-за перезапуска контейнера или проблемы с сетью) и когда она снова становится доступной. Запросы на расшифровку не будут отправляться в недоступные контейнеры, и клиент продолжит использовать другие доступные контейнеры. Вы можете добавлять, удалять или изменять конечные точки в любое время, не прерывая выполнение пакета.


## <a name="run-the-batch-processing-container"></a>Запуск контейнера пакетной обработки
  
> [!NOTE] 
> * В этом примере используется тот же каталог ( `/my_nfs` ) для файла конфигурации, а также каталоги входов, выходов и журналов. Для этих папок можно использовать размещенные или подключенные к NFS каталоги.
> * При запуске клиента с `–h` будет отображаться список доступных параметров командной строки и их значения по умолчанию. 


#### <a name="linux"></a>[Linux](#tab/linux)
`run`Чтобы запустить контейнер, используйте команду DOCKER. Это приведет к запуску интерактивной оболочки внутри контейнера.

```Docker
docker run --rm -ti -v  /mnt/my_nfs:/my_nfs --entrypoint /bin/bash /mnt/my_nfs:/my_nfs docker.io/batchkit/speech-batch-kit:latest
```

Чтобы запустить клиент пакетной службы, выполните следующие действия.  

```Docker
run-batch-client -config /my_nfs/config.yaml -input_folder /my_nfs/audio_files -output_folder /my_nfs/transcriptions -log_folder  /my_nfs/logs -log_level DEBUG -nbest 1 -m ONESHOT -diarization  None -language en-US -strict_config   
```

Чтобы запустить клиент и контейнер пакетной службы, выполните одну команду:

```Docker
docker run --rm -ti -v  /mnt/my_nfs:/my_nfs docker.io/batchkit/speech-batch-kit:latest  -config /my_nfs/config.yaml -input_folder /my_nfs/audio_files -output_folder /my_nfs/transcriptions -log_folder  /my_nfs/logs -log_level DEBUG -nbest 1 -m ONESHOT -diarization  None -language en-US -strict_config   
```

#### <a name="windows"></a>[Windows](#tab/windows)

Чтобы запустить клиент и контейнер пакетной службы, выполните одну команду:

```Docker
docker run --rm -ti -v   c:\my_nfs:/my_nfs docker.io/batchkit/speech-batch-kit:latest  -config  /my_nfs/config.yaml -input_folder /my_nfs/audio_files -output_folder /my_nfs/transcriptions -log_folder  /my_nfs/logs -nbest 1 -m ONESHOT -diarization  None -language en-US -strict_config

```

---


Клиент начнет работать. Если звуковой файл уже был расшифрованной в предыдущем запуске, клиент будет автоматически пропускать этот файл. При возникновении временных ошибок файлы отправляются с автоматическим повторным выполнением, и вы можете различать ошибки, которые необходимо повторить для клиента. При ошибке транскрипции клиент продолжит запись и может повторить попытку без потери хода выполнения.  

## <a name="run-modes"></a>Режимы выполнения 

Набор пакетной обработки предоставляет три режима с помощью `--run-mode` параметра.

#### <a name="oneshot"></a>[онешот](#tab/oneshot)

`ONESHOT` режим расшифровывает один пакет звуковых файлов (из входного каталога и необязательного списка файлов) в выходную папку.

:::image type="content" source="media/containers/batch-oneshot-mode.png" alt-text="Схема, показывающая файлы обработки контейнера пакета пакетной службы в режиме онешот.":::

1. Определите конечные точки контейнера речи, которые клиент пакетной службы будет использовать в `config.yaml` файле. 
2. Размещение звуковых файлов для транскрипции во входном каталоге.  
3. Вызовите контейнер в каталоге, который начнет обрабатывать файлы. Если звуковой файл уже был расшифрованной в предыдущем запуске с тем же выходным каталогом (именем файла и контрольной суммой), клиент пропустит этот файл. 
4. Файлы отправляются в конечные точки контейнера из шага 1.
5. Журналы и выходные данные контейнера речи возвращаются в указанный выходной каталог. 

#### <a name="daemon"></a>[Управляющей программы](#tab/daemon)

> [!TIP]
> Если одновременно к входному каталогу одновременно добавляется несколько файлов, можно повысить производительность, добавив их в обычное время.

`DAEMON` режим расшифровывает существующие файлы в заданной папке и постоянно расшифровывает новые аудиофайлы по мере их добавления.          

:::image type="content" source="media/containers/batch-daemon-mode.png" alt-text="Схема, показывающая файлы обработки контейнера пакетного пакета в режиме управляющей программы.":::

1. Определите конечные точки контейнера речи, которые клиент пакетной службы будет использовать в `config.yaml` файле. 
2. Вызов контейнера во входном каталоге. Клиент пакетной службы начнет наблюдение за входящими файлами в каталоге. 
3. Настройте непрерывную доставку звуковых файлов в входной каталог. Если звуковой файл уже был расшифрованной в предыдущем запуске с тем же выходным каталогом (именем файла и контрольной суммой), клиент пропустит этот файл. 
4. После обнаружения сигнала записи файла или POSIX контейнер запускается для ответа.
5. Файлы отправляются в конечные точки контейнера из шага 1.
6. Журналы и выходные данные контейнера речи возвращаются в указанный выходной каталог. 

#### <a name="rest"></a>[REST](#tab/rest)

`REST` Mode — это режим сервера API, предоставляющий базовый набор конечных точек HTTP для отправки пакетов звуковых файлов, проверки состояния и длительного опроса. Также обеспечивает программное использование с помощью расширения модуля Python или импорт в качестве подмодуля.

:::image type="content" source="media/containers/batch-rest-api-mode.png" alt-text="Схема, показывающая файлы обработки контейнера пакетного пакета в режиме управляющей программы.":::

1. Определите конечные точки контейнера речи, которые клиент пакетной службы будет использовать в `config.yaml` файле. 
2. Отправьте запрос HTTP-запроса на одну из конечных точек сервера API. 
        
    |Конечная точка  |Описание  |
    |---------|---------|
    |`/submit`     | Конечная точка для создания новых пакетных запросов.        |
    |`/status`     | Конечная точка для проверки состояния запроса пакетной службы. Подключение будет оставаться открытым до завершения выполнения пакета.       |
    |`/watch`     | Конечная точка для использования длительного опроса HTTP до завершения выполнения пакета.        |

3. Звуковые файлы передаются из входного каталога. Если звуковой файл уже был расшифрованной в предыдущем запуске с тем же выходным каталогом (именем файла и контрольной суммой), клиент пропустит этот файл. 
4. Если в конечную точку отправляется запрос, файлы отправляются `/submit` в конечные точки контейнера из шага 1.
5. Журналы и выходные данные контейнера речи возвращаются в указанный выходной каталог. 

---

## <a name="logging"></a>Logging

> [!NOTE]
> Клиент пакетной службы может периодически перезаписывать файл *Run. log* , если он становится слишком большим.

Клиент создает файл *Run. log* в каталоге, указанном `-log_folder` аргументом в `run` команде DOCKER. Журналы записываются на уровне отладки по умолчанию. Одни и те же журналы отправляются в `stdout/stderr` и фильтруются в зависимости от `-log_level` аргумента. Этот журнал необходим только для отладки, или если необходимо отправить трассировку для поддержки. В папке Logging также содержатся журналы речевого пакета SDK для каждого звукового файла.

Выходной каталог, заданный параметром, `-output_folder` будет содержать *run_summary.jsв*   файле, который периодически перезаписывается каждые 30 секунд или каждый раз, когда завершается новая транскрипция. Этот файл можно использовать для проверки хода выполнения пакета. Он также будет содержать окончательную статистику выполнения и окончательное состояние каждого файла по завершении выполнения пакета. Выполнение пакета завершается, когда процесс завершается с помощью чистого выхода. 

## <a name="next-steps"></a>Дальнейшие действия

* [Как устанавливать и запускать контейнеры](speech-container-howto.md)
