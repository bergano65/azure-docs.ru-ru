---
title: Расширение приложения во время выполнения — LUIS
description: ''
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 04/14/2020
ms.openlocfilehash: 69e2608fb01ece81f555aae2f3d4a2e4a05cfc90
ms.sourcegitcommit: 829d951d5c90442a38012daaf77e86046018e5b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2020
ms.locfileid: "91322807"
---
# <a name="extend-app-at-prediction-runtime"></a>Расширение приложения в среде выполнения прогнозирования

Схема (модели и компоненты) приложения обучена и опубликована в конечной точке прогнозирования. Эта опубликованная модель используется в среде выполнения прогнозирования. Для расширения прогноза можно передать в среду выполнения прогнозирование новые сведения, а также utterance пользователя.

Ниже перечислены две изменения схемы среды выполнения прогнозирования.
* [Внешние сущности](#external-entities)
* [Динамические списки](#dynamic-lists)

<a name="external-entities-passed-in-at-prediction-time"></a>

## <a name="external-entities"></a>Внешние сущности

Внешние сущности предоставляют приложению LUIS возможность определять и отмечать сущности во время выполнения, которые можно использовать в качестве функций для существующих сущностей. Это позволяет использовать собственные пользовательские средства извлечения сущностей перед отправкой запросов в конечную точку прогнозирования. Так как это делается на конечной точке прогнозирования запросов, вам не нужно переучить и публиковать модель.

Клиентское приложение предоставляет собственное средство извлечения сущностей путем управления сопоставлением сущностей и определением расположения в utterance соответствующей сущности и последующей отправкой этой информации с запросом.

Внешние сущности — это механизм для расширения любого типа сущности, который по-прежнему используется в качестве сигналов для других моделей.

Это полезно для сущности, имеющей данные, доступные только в среде выполнения прогнозирующих запросов. Примеры данных такого типа постоянно изменяют данные или зависят от отдельных пользователей. Вы можете расширить сущность LUIS Contact с помощью внешней информации из списка контактов пользователя.

Внешние сущности являются частью API создания версии v3. Дополнительные сведения о [переходе](luis-migration-api-v3.md) на эту версию.

### <a name="entity-already-exists-in-app"></a>Сущность уже существует в приложении

Значение `entityName` для внешней сущности, переданное в теле запроса конечной точки, должно уже существовать в обученном и опубликованном приложении во время выполнения запроса. Тип сущности не имеет значения, поддерживаются все типы.

### <a name="first-turn-in-conversation"></a>Первое включение диалога

Рассмотрим первый utterance в диалоговом окне чата, когда пользователь вводит следующую неполную информацию:

`Send Hazem a new message`

Запрос от Bot-робота к LUIS может передавать сведения в тексте сообщения о том `Hazem` , что он напрямую соответствует одному из контактов пользователя.

```json
    "externalEntities": [
        {
            "entityName":"contacts",
            "startIndex": 5,
            "entityLength": 5,
            "resolution": {
                "employeeID": "05013",
                "preferredContactType": "TeamsChat"
            }
        }
    ]
```

Прогнозирующий запрос включает эту внешнюю сущность со всеми другими прогнозируемыми сущностями, поскольку она определена в запросе.

### <a name="second-turn-in-conversation"></a>Второе включение диалога

Следующий пользователь, utterance в роботе Chat, использует более неясный термин:

`Send him a calendar reminder for the party.`

В такой части диалога utterance использует в `him` качестве ссылки на `Hazem` . Робот разговора в теле сообщения может сопоставляться со `him` значением сущности, извлеченным из первого utterance, `Hazem` .

```json
    "externalEntities": [
        {
            "entityName":"contacts",
            "startIndex": 5,
            "entityLength": 3,
            "resolution": {
                "employeeID": "05013",
                "preferredContactType": "TeamsChat"
            }
        }
    ]
```

Прогнозирующий запрос включает эту внешнюю сущность со всеми другими прогнозируемыми сущностями, поскольку она определена в запросе.

### <a name="override-existing-model-predictions"></a>Переопределить прогнозы существующих моделей

`preferExternalEntities`Свойство Options указывает, что если пользователь отправляет внешнюю сущность, которая пересекается с прогнозируемой сущностью с тем же именем, Luis выбирает переданную сущность или сущность, существующую в модели.

В качестве примера рассмотрим запрос `today I'm free`. LUIS обнаруживает `today` как datetimeV2 со следующим ответом:

```JSON
"datetimeV2": [
    {
        "type": "date",
        "values": [
            {
                "timex": "2019-06-21",
                "value": "2019-06-21"
            }
        ]
    }
]
```

Если пользователь отправляет внешнюю сущность:

```JSON
{
    "entityName": "datetimeV2",
    "startIndex": 0,
    "entityLength": 5,
    "resolution": {
        "date": "2019-06-21"
    }
}
```

Если параметр `preferExternalEntities` имеет значение `false` , Luis возвращает ответ, как если бы внешняя сущность не была отправлена.

```JSON
"datetimeV2": [
    {
        "type": "date",
        "values": [
            {
                "timex": "2019-06-21",
                "value": "2019-06-21"
            }
        ]
    }
]
```

Если `preferExternalEntities` для задано значение `true` , Luis возвращает ответ, в том числе:

```JSON
"datetimeV2": [
    {
        "date": "2019-06-21"
    }
]
```



#### <a name="resolution"></a>Решение

_Необязательное_ `resolution` свойство возвращает в ответе прогноза, что позволяет передать метаданные, связанные с внешней сущностью, а затем получить ее обратно в ответе.

Основной целью является расширение предварительно созданных сущностей, но оно не ограничивается этим типом сущности.

`resolution`Свойство может быть числом, строкой, объектом или массивом:

* Офиса
* {"Text": "value"}
* 12345
* ["a", "b", "c"]

<a name="dynamic-lists-passed-in-at-prediction-time"></a>

## <a name="dynamic-lists"></a>Динамические списки

Динамические списки позволяют расширить существующую подготовленную и опубликованную сущность списка, уже находящиеся в приложении LUIS.

Используйте эту функцию, если необходимо периодически менять значения сущностей списка. Эта функция позволяет расширить уже подготовленный и опубликованный объект списка.

* Во время запроса конечной точки прогноза запроса.
* Для одного запроса.

Сущность списка может быть пустой в приложении LUIS, но она должна существовать. Сущность списка в приложении LUIS не изменилась, но возможности прогнозирования в конечной точке расширены для включения в них до 2 списков с 1 000 элементами.

### <a name="dynamic-list-json-request-body"></a>Текст запроса JSON динамического списка

Отправить в следующем тексте JSON, чтобы добавить новый вложенный список с синонимами в список и спрогнозировать сущность списка для текста `LUIS` с `POST` запросом прогноза запроса:

```JSON
{
    "query": "Send Hazem a message to add an item to the meeting agenda about LUIS.",
    "options":{
        "timezoneOffset": "-8:00"
    },
    "dynamicLists": [
        {
            "listEntity*":"ProductList",
            "requestLists":[
                {
                    "name": "Azure Cognitive Services",
                    "canonicalForm": "Azure-Cognitive-Services",
                    "synonyms":[
                        "language understanding",
                        "luis",
                        "qna maker"
                    ]
                }
            ]
        }
    ]
}
```

Прогнозирующий запрос включает в себя эту сущность List со всеми другими прогнозируемыми сущностями, поскольку она определена в запросе.

## <a name="next-steps"></a>Дальнейшие шаги

* [Оценка прогнозирования](luis-concept-prediction-score.md)
* [Изменения в API версии v3](luis-migration-api-v3.md)
