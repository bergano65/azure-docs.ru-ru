---
title: Структура именования анализатора — API лингвистического анализа
titlesuffix: Azure Cognitive Services
description: Узнайте, как структура именования API лингвистического анализа для анализаторов обеспечивает гибкость и точность.
services: cognitive-services
author: RichardSunMS
manager: cgronlun
ms.service: cognitive-services
ms.component: linguistic-analysis
ms.topic: conceptual
ms.date: 03/23/2016
ms.author: lesun
ROBOTS: NOINDEX
ms.openlocfilehash: f8c7aba2b853f3916c2d01d94d49090a4b3e36a0
ms.sourcegitcommit: 1981c65544e642958917a5ffa2b09d6b7345475d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/03/2018
ms.locfileid: "48237238"
---
# <a name="analyzer-names"></a>Имена анализаторов

> [!IMPORTANT]
> Поддержка предварительной версии Лингвистического анализа прекращена 9 августа 2018 г. Мы рекомендуем использовать [модули текстовой аналитики Машинного обучения Azure](https://docs.microsoft.com/azure/machine-learning/studio-module-reference/text-analytics) для анализа и обработки текста.

Мы используем довольно сложную структуру именования для анализаторов, чтобы обеспечить как гибкость анализаторов, так и точность распознавания того, что означает имя.
Имена анализаторов состоят из четырех частей: идентификатора, вида, спецификации и реализации.
Ниже определены роли каждого компонента.

## <a name="id"></a>ИД
Во-первых, анализатор имеет уникальный идентификатор – GUID.
Эти идентификаторы GUID должны изменяться относительно редко, но это единственный способ однозначно описать конкретный анализатор.

## <a name="kind"></a>Вид
Затем каждый анализатор принадлежит к определенному **виду**.
Это в очень широком смысле определяет тип возвращаемого анализа и должно однозначно определить структуру данных, используемую для представления этого анализа.
В настоящее время существует три различных вида:
 - [Маркеры](Sentences-and-Tokens.md)
 - [POS-теги](Pos-Tagging.md)
 - [Дерево анализа](constituency-parsing.md)

## <a name="specification"></a>Спецификация
Однако в данном виде разные эксперты могут не согласиться с тем, как следует анализировать конкретный феномен.
В отличие от языков программирования, нет четкого и точного определения того, как это должно быть сделано.

Например, представьте, что необходимо найти маркеры в английском предложении "He didn’t go".
В частности, рассмотрим строку "didn’t".
Одно из возможных толкований заключается в том, что это следует разделить на два маркера: "did" и "not".
Тогда альтернативное предложение "He did not go" имело бы тот же набор маркеров.
Другая возможность заключается в том,чтобы сказать, что это следует разделить на маркеры "did" и "n't".
Последний маркер обычно не считается словом, но этот подход сохраняет больше информации о поверхностной строке, которая иногда может быть полезна.
Или, возможно, это сокращение следует рассматривать как одно слово.

Независимо от того, какой выбор сделан, этот выбор следует делать последовательно.
Это как раз роль **спецификации**: решить, какое должно быть правильное представление.

Выходные данные анализатора можно сравнить только с данными, которые соответствуют той же спецификации.

## <a name="implementation"></a>Реализация

Часто есть несколько моделей, которые пытаются добиться тех же результатов, но с различными характеристиками производительности.
Одна модель может оказаться быстрее, но менее точной; другая может поступиться чем-то другим.

Часть **реализация** имени анализатора используется для идентификации этого типа информации, чтобы пользователи могли выбрать наиболее подходящий анализатор для своих нужд.
