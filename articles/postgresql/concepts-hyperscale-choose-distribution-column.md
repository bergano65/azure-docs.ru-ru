---
title: Выбор столбцов распределения в базе данных Azure для PostgreSQL — масштабирование (Цитус)
description: Узнайте, как выбрать столбцы распределения в общих сценариях масштабирования в базе данных Azure для PostgreSQL.
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: a61c52773c4c6036a76d7b233988c713c1da861f
ms.sourcegitcommit: c22327552d62f88aeaa321189f9b9a631525027c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/04/2019
ms.locfileid: "73482853"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>Выбор столбцов распределения в базе данных Azure для PostgreSQL — масштабирование (Цитус)

Выбор столбца распределения каждой таблицы является одним из наиболее важных решений моделирования, которые вы хотите внести. Служба "база данных Azure для PostgreSQL — масштабирование" (Цитус) хранит строки в сегментах на основе значения столбца распределения строк.

Правильные группы выбора связывают данные на одних и тех же физических узлах, что делает запросы быстрыми и добавляет поддержку всех функций SQL. Неверный вариант заставляет систему работать медленно и не поддерживать все функции SQL на всех узлах.

В этой статье приводятся советы по использованию столбцов распределения для двух наиболее распространенных сценариев масштабирования (Цитус).

### <a name="multi-tenant-apps"></a>Мультитенантные приложения

Архитектура с несколькими клиентами использует иерархическую модель моделирования баз данных для распределения запросов между узлами в группе серверов. Верхняя часть иерархии данных называется *идентификатором клиента* и должна храниться в столбце в каждой таблице.

Масштабирование (Цитус) проверяет запросы, чтобы узнать, какой идентификатор клиента они используют, и находит соответствующий сегмент таблицы. Он направляет запрос на один рабочий узел, содержащий сегмент. Выполнение запроса со всеми соответствующими данными, размещенными на том же узле, называется совместное размещение.

На следующей схеме показано совместное размещение в модели данных с несколькими клиентами. Она содержит две таблицы, учетные записи и кампании, распределенные по `account_id`. Затененные поля представляют сегменты. Зеленые сегменты хранятся на одном рабочем узле, а синие сегменты хранятся на другом рабочем узле. Обратите внимание, что запрос на соединение между учетными записями и кампаниями содержит все необходимые данные на одном узле, если обе таблицы ограничены одной учетной записью\_идентификатором.

![Совместное размещение нескольких клиентов](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

Чтобы применить эту схему в собственной схеме, укажите, что представляет собой клиент в приложении. К общим экземплярам относятся компания, учетная запись, организация или клиент. Имя столбца будет выглядеть примерно так, как `company_id` или `customer_id`. Изучите каждый запрос и запросите себя, будет ли он работать, если у него есть дополнительные предложения WHERE для ограничения всех таблиц, вовлеченных в строки с одинаковым ИДЕНТИФИКАТОРом клиента?
Запросы в модели с несколькими клиентами ограничены клиентом. Например, для запросов к продажам или инвентаризации используется область в определенном хранилище.

#### <a name="best-practices"></a>Рекомендации

-   **Секционирование распределенных таблиц по общему столбцу\_идентификатора клиента.** Например, в приложении SaaS, где клиенты являются компаниями, идентификатор\_клиента, скорее всего, будет\_идентификатором компании.
-   **Преобразование небольших таблиц между клиентами в ссылочные таблицы.** Если несколько клиентов совместно используют небольшую таблицу данных, распространите их в виде ссылочной таблицы.
-   **Ограничить фильтр всех запросов приложений по идентификатору\_клиента.** Каждый запрос должен запрашивать сведения для одного клиента за раз.

Ознакомьтесь с [руководством по нескольким клиентам](./tutorial-design-database-hyperscale-multi-tenant.md) для примера того, как создать приложение такого типа.

### <a name="real-time-apps"></a>Приложения в режиме реального времени

Архитектура с несколькими клиентами представляет иерархическую структуру и использует совместное размещение данных для маршрутизации запросов на каждого клиента. В отличие от этого, архитектуры в режиме реального времени зависят от конкретных свойств распределения своих данных, чтобы добиться высокой параллельной обработки.

Идентификатор сущности используется в качестве термина для столбцов распределения в модели реального времени. Типичными сущностями являются пользователи, узлы или устройства.

Запросы в режиме реального времени обычно запрашивают числовые статистические выражения, сгруппированные по датам или категориям. Масштабирование (Цитус) отправляет эти запросы в каждый сегмент для получения частичных результатов и собирает окончательный ответ на узле координатора. Запросы выполняются быстрее, когда количество узлов может быть максимально возможным, и если ни один узел не должен выполнять непропорциональное количество операций.

#### <a name="best-practices"></a>Рекомендации

-   **Выберите столбец с большим количеством элементов в качестве столбца распределения.** Для сравнения поле состояния в таблице заказа со значениями New, оплачено и отгружено плохо выбирает столбец распределения. В нем предполагается только несколько значений, которые ограничивают количество сегментов, которые могут содержать данные, и количество узлов, которые могут их обработать. Между столбцами с большим количеством элементов также удобно выбрать столбцы, которые часто используются в предложениях GROUP-BY или в качестве ключей объединения.
-   **Выберите столбец с четным распределением.** Если таблица распределяется по столбцу, смещенному по определенным общим значениям, данные в таблице будут накапливаться в определенных сегментах. Узлы, которые содержат эти сегменты, в итоге выполняют больше работы, чем другие узлы.
-   **Распределите таблицы фактов и измерений по общим столбцам.**
    У вашей таблицы фактов может быть только один ключ распределения. Таблицы, которые присоединяются к другому ключу, не будут совместно размещаться с таблицей фактов. Выберите одно измерение для совместного размещения в зависимости от частоты его соединения и размера соединяемых строк.
-   **Замените некоторые таблицы измерений на ссылочные таблицы.** Если таблица измерения не может быть совместно размещена с таблицей фактов, можно повысить производительность запросов, выполнив распространение копий таблицы измерения на все узлы в форме ссылочной таблицы.

Пример создания приложения такого типа см. в руководстве по работе с [панелями мониторинга в реальном времени](./tutorial-design-database-hyperscale-realtime.md) .

### <a name="time-series-data"></a>Данные временных рядов

В рабочей нагрузке временных рядов приложения запрашивают последние сведения во время архивации старых данных.

Наиболее распространенной ошибкой при моделировании сведений о ряде времени в подмасштабировании (Цитус) является использование отметки времени в качестве столбца распределения. Хэш-распределение, основанное на времени, при этом распределяется случайным образом на разные сегменты, а не на сегменты времени в сегментах. Запросы, в которых используются время, как правило, представляют собой ссылки на диапазон времени, например самые последние данные. Этот тип хэш-распределения приводит к сетевым издержкам.

#### <a name="best-practices"></a>Рекомендации

-   **Не выбирайте отметку времени в качестве столбца распределения.** Выберите другой столбец распределения. В приложении с несколькими клиентами используйте идентификатор клиента или в приложении в режиме реального времени используйте идентификатор сущности.
-   **Вместо этого используйте секционирование таблиц PostgreSQL в течение времени.** Секционирование таблиц используется для разбиения большой таблицы данных, упорядоченных по времени, на несколько наследуемых таблиц с каждой таблицей, содержащей разные диапазоны времени. При распределении postgres секционированной таблицы в масштабе (Цитус) создаются сегменты для наследуемых таблиц.

Прочтите [учебник по временным циклам](https://aka.ms/hyperscale-tutorial-timeseries) , чтобы получить пример того, как создать приложение такого типа.

## <a name="next-steps"></a>Дальнейшие действия
- Узнайте, как совместное [Размещение](concepts-hyperscale-colocation.md) между распределенными данными помогает быстро выполнять запросы.
