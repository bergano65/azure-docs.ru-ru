---
title: Функции SQL — масштабирование (Цитус) — база данных Azure для PostgreSQL
description: Функции в API SQL для масштабирования (Цитус)
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: reference
ms.date: 08/10/2020
ms.openlocfilehash: 16c3a45e0d88a0546772b3fdc855c90f2e450d14
ms.sourcegitcommit: 829d951d5c90442a38012daaf77e86046018e5b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2020
ms.locfileid: "91250337"
---
# <a name="functions-in-the-hyperscale-citus-sql-api"></a>Функции в API SQL для масштабирования (Цитус)

В этом разделе содержатся справочные сведения по определяемым пользователем функциям, предоставляемым функцией масштабирования (Цитус). Эти функции помогают предоставить дополнительные распределенные функции для масштабирования (Цитус), отличные от стандартных команд SQL.

> [!NOTE]
>
> Группы серверов масштаба (Цитус), работающие под управлением старых версий подсистемы Цитус, могут не предлагать все перечисленные ниже функции.

## <a name="table-and-shard-ddl"></a>DDL таблиц и сегментов

### <a name="create_distributed_table"></a>создать \_ распределенную \_ таблицу

Функция создания \_ распределенной \_ таблицы () используется для определения распределенной таблицы и создания ее сегментов, если это таблица, распределенная по хэшу. Эта функция принимает имя таблицы, столбец распределения и дополнительный метод распределения и вставляет соответствующие метаданные, чтобы пометить таблицу как распределенную. Функция по умолчанию имеет значение "Hash" для распределения, если не указан метод распределения. Если таблица является распределенной по хэш-коду, она также создает рабочие сегменты на основе значений конфигурации "количество сегментов" и "коэффициент репликации сегментов". Если таблица содержит какие бы то ни было строки, они автоматически распределяются между рабочими узлами.

Эта функция заменяет использование мастера \_ создания \_ распределенной \_ таблицы () с последующим \_ созданием основных \_ сегментов рабочих ролей \_ ().

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** имя таблицы, которую необходимо распространить.

** \_ столбец распределения:** столбец, по которому будет распространяться таблица.

** \_ тип распределения:** (необязательно) метод, в соответствии с которым таблица должна быть распределена. Допустимые значения: Append или Hash, со значением по умолчанию "Hash".

** \_ совместное размещение с:** (необязательно) включает текущую таблицу в группу совместного размещения другой таблицы. По умолчанию таблицы размещаются вместе, если они распределяются по столбцам одного типа, имеют одинаковое количество сегментов и имеют одинаковый коэффициент репликации. Возможными значениями для `colocate_with` являются `default` , `none` для запуска новой группы совместного размещения или с именем другой таблицы, которая будет сопоставлена с этой таблицей.  (См. раздел Совместное [Размещение таблицы](concepts-hyperscale-colocation.md).)

Помните, что значение по умолчанию для `colocate_with` не является неявным совместном расположением. Совместное [Размещение](concepts-hyperscale-colocation.md) может быть отличным, когда таблицы связаны или будут присоединены.  Однако если две таблицы не связаны, но при этом они используют один и тот же тип данных для столбцов распределения, их случайное размещение может снизить производительность во время [перераспределения сегментов](howto-hyperscale-scaling.md#rebalance-shards).  Сегменты таблицы будут перемещаться без необходимости в \" каскадной.\"

Если новая распределенная таблица не связана с другими таблицами, лучше указать `colocate_with => 'none'` .

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

В этом примере база данных информируется о том, что \_ Таблица событий GitHub должна распространяться по хэшу в \_ столбце Идентификатор репозитория.

```postgresql
SELECT create_distributed_table('github_events', 'repo_id');

-- alternatively, to be more explicit:
SELECT create_distributed_table('github_events', 'repo_id',
                                colocate_with => 'github_repo');
```

### <a name="create_reference_table"></a>создать \_ ссылочную \_ таблицу

Функция создания \_ ссылочной \_ таблицы () используется для определения небольшой ссылки или таблицы измерения. Эта функция принимает имя таблицы и создает распределенную таблицу только с одним сегментом, который реплицируется на каждый рабочий узел.

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** имя небольшого или ссылочной таблицы, которую необходимо распространить.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

В этом примере база данных информируется о том, что таблица «страна» должна быть определена как ссылочная таблица.

```postgresql
SELECT create_reference_table('nation');
```

### <a name="upgrade_to_reference_table"></a>Обновление \_ до \_ ссылочной \_ таблицы

Функция обновить \_ до \_ ссылки \_ Table () принимает существующую распределенную таблицу с числом сегментов, равным единице, и обновляет ее до распознаваемых ссылочных таблиц. После вызова этой функции таблица будет иметь то же значение, которая была создана с помощью [create_reference_table](#create_reference_table).

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** имя распределенной таблицы (с количеством сегментов = 1), которое будет распространяться как ссылочная таблица.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

В этом примере база данных информируется о том, что таблица «страна» должна быть определена как ссылочная таблица.

```postgresql
SELECT upgrade_to_reference_table('nation');
```

### <a name="mark_tables_colocated"></a>Пометка \_ \_ соразмещенных таблиц

Функция совместного \_ размещения таблиц Mark \_ () принимает распределенную таблицу (источник) и список других (целевых объектов) и помещает целевые объекты в ту же группу совместной работы, что и источник. Если источник еще не находится в группе, эта функция создает ее и присваивает ей источник и целевые объекты.

Совместное размещение таблиц должно выполняться во время распределения таблицы с помощью `colocate_with` параметра [create_distributed_table](#create_distributed_table), но `mark_tables_colocated` при необходимости его можно использовать позже.

#### <a name="arguments"></a>Аргументы

** \_ имя исходной таблицы \_ :** имя распределенной таблицы, для которой целевые объекты будут назначены для сопоставления.

** \_ имена целевых таблиц \_ :** массив имен распределенных целевых таблиц не должен быть пустым. Эти распределенные таблицы должны соответствовать исходной таблице в:

> -   distribution - метод
> -   тип столбца распределения
> -   тип репликации
> -   число сегментов

Если ни одно из приведенных выше условий не применяется, то изменение масштаба (Цитус) вызовет ошибку. Например, попытка совместного размещения таблиц `apples` , `oranges` типы столбцов распределения которых отличаются от результатов:

```
ERROR:  XX000: cannot colocate tables apples and oranges
DETAIL:  Distribution column types don't match for apples and oranges.
```

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

В этом примере размещается `products` и `line_items` в той же группе совместного размещения, что и `stores` . В этом примере предполагается, что эти таблицы распределяются по столбцу с совпадающим типом, скорее всего, \" идентификатор магазина.\"

```postgresql
SELECT mark_tables_colocated('stores', ARRAY['products', 'line_items']);
```

### <a name="create_distributed_function"></a>Создание \_ распределенной \_ функции

Распространяет функцию с узла координатора на рабочие роли и помечает ее для распределенного выполнения. При вызове распределенной функции в координаторе функция Scale (Цитус) использует значение \" аргумента распределения, \" чтобы выбрать рабочий узел для выполнения функции. Исполнение функции на рабочих процессах повышает параллелизм и может привести код ближе к данным в сегментах для более низкой задержки.

Путь поиска postgres не распространяется от координатора к работникам во время выполнения распределенной функции, поэтому распределенный код функции должен полностью определять имена объектов базы данных. Кроме того, уведомления, порожденные функциями, не будут отображаться для пользователя.

#### <a name="arguments"></a>Аргументы

** \_ имя функции:** имя функции, которую необходимо распространить. Имя должно содержать типы параметров функции в круглых скобках, поскольку несколько функций могут иметь одно и то же имя в PostgreSQL. Например, `'foo(int)'` отличается от `'foo(int, text)'` .

**имя аргумента распространителя \_ \_ :** (необязательно) имя параметра, по которому будет распространяться. Для удобства (или если аргументы функции не имеют имен) замещающий заполнитель разрешен, например `'$1'` . Если этот параметр не указан, то `function_name` для рабочих ролей просто создается функция с именем. Если в будущем добавляются рабочие узлы, функция будет автоматически создана.

** \_ совместное размещение с помощью:** (необязательно) Если распределенная функция считывает или записывает данные в распределенную таблицу (или, в общем случае, в группу совместного размещения), имя этой таблицы следует указывать с помощью `colocate_with` параметра. Затем каждый вызов функции будет выполняться на рабочем узле, содержащем соответствующие сегменты.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

```postgresql
-- an example function which updates a hypothetical
-- event_responses table which itself is distributed by event_id
CREATE OR REPLACE FUNCTION
  register_for_event(p_event_id int, p_user_id int)
RETURNS void LANGUAGE plpgsql AS $fn$
BEGIN
  INSERT INTO event_responses VALUES ($1, $2, 'yes')
  ON CONFLICT (event_id, user_id)
  DO UPDATE SET response = EXCLUDED.response;
END;
$fn$;

-- distribute the function to workers, using the p_event_id argument
-- to determine which shard each invocation affects, and explicitly
-- colocating with event_responses which the function updates
SELECT create_distributed_function(
  'register_for_event(int, int)', 'p_event_id',
  colocate_with := 'event_responses'
);
```

## <a name="metadata--configuration-information"></a>Метаданные или сведения о конфигурации

### <a name="master_get_table_metadata"></a>\_метаданные главной \_ таблицы \_ получения

\_ \_ \_ Для возврата метаданных, связанных с распространением для распределенной таблицы, можно использовать функцию главной получения метаданных (). Эти метаданные включают идентификатор связи, тип хранилища, метод распределения, столбец распределения, число репликаций, максимальный размер сегмента и политику размещения сегментов для таблицы. На самом деле эта функция запрашивает таблицы метаданных Цитус для получения необходимой информации и объединяет ее в кортеж перед возвратом пользователю.

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** имя распределенной таблицы, для которой необходимо получить метаданные.

#### <a name="return-value"></a>Возвращаемое значение

Кортеж, содержащий следующие сведения:

**логическое \_ relId:** OID распределенной таблицы. Он ссылается на столбец релфиленоде в \_ таблице системных каталогов класса PG.

** \_ тип хранилища части \_ :** тип хранилища, используемый для таблицы. Может быть 't ' (стандартная таблица), ' f ' (внешняя таблица) или ' c ' (таблица с столбцами).

** \_ метод Part:** метод распределения, используемый для таблицы. Может быть "a" (Append) или "h" (хэш).

** \_ ключ части:** столбец распределения для таблицы.

** \_ число реплик части \_ :** текущее число репликаций сегментов.

** \_ максимальный \_ Размер части:** текущий максимальный размер сегмента в байтах.

** \_ Политика размещения частей \_ :** политика размещения сегментов, используемая для размещения сегментов таблицы. Может быть 1 (локальный-узел-первый) или 2 (циклический перебор).

#### <a name="example"></a>Пример

В приведенном ниже примере производится выборка и отображение метаданных таблицы для \_ таблицы событий GitHub.

```postgresql
SELECT * from master_get_table_metadata('github_events');
 logical_relid | part_storage_type | part_method | part_key | part_replica_count | part_max_size | part_placement_policy 
---------------+-------------------+-------------+----------+--------------------+---------------+-----------------------
         24180 | t                 | h           | repo_id  |                  2 |    1073741824 |                     2
(1 row)
```

### <a name="get_shard_id_for_distribution_column"></a>получение \_ \_ идентификатора сегмента \_ для \_ \_ столбца распределения

При изменении масштаба (Цитус) каждая строка распределенной таблицы назначается сегменту на основе значения столбца распределения строки и метода распределения таблицы. В большинстве случаев точное сопоставление является самым низким уровнем детализации, который администратор базы данных может игнорировать. Однако может быть полезно определить сегмент строки либо для задач обслуживания базы данных вручную, либо только для удовлетворения любопытство. `get_shard_id_for_distribution_column`Функция предоставляет эти сведения для таблиц, распределенных по хэш-и диапазону, а также ссылочных таблиц. Он не подходит для распространения с добавлением.

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** распределенная таблица.

** \_ значение распределения:** значение столбца распределения.

#### <a name="return-value"></a>Возвращаемое значение

Параметр Scale идентификатора сегмента (Цитус) связывается со значением столбца распределения для данной таблицы.

#### <a name="example"></a>Пример

```postgresql
SELECT get_shard_id_for_distribution_column('my_table', 4);

 get_shard_id_for_distribution_column
--------------------------------------
                               540007
(1 row)
```

### <a name="column_to_column_name"></a>столбец \_ в \_ \_ имя столбца

Преобразует `partkey` столбец `pg_dist_partition` в имя текстового столбца. Перевод полезен для определения столбца распределения распределенной таблицы.

Более подробное обсуждение см. в разделе [Выбор столбца распределения](concepts-hyperscale-choose-distribution-column.md).

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** распределенная таблица.

**столбец \_ var \_ Text:** значение `partkey` в `pg_dist_partition` таблице.

#### <a name="return-value"></a>Возвращаемое значение

Имя `table_name` столбца распределения.

#### <a name="example"></a>Пример

```postgresql
-- get distribution column name for products table

SELECT column_to_column_name(logicalrelid, partkey) AS dist_col_name
  FROM pg_dist_partition
 WHERE logicalrelid='products'::regclass;
```

Выходные данные:

```
┌───────────────┐
│ dist_col_name │
├───────────────┤
│ company_id    │
└───────────────┘
```

### <a name="citus_relation_size"></a>\_размер отношения \_ Цитус

Получение места на диске, используемого всеми сегментами указанной распределенной таблицы.
Место на диске содержит размер \" основной вилки, \" но не включает карту видимости и карту свободного пространства для сегментов.

#### <a name="arguments"></a>Аргументы

**логикалрелид:** имя распределенной таблицы.

#### <a name="return-value"></a>Возвращаемое значение

Размер в байтах как bigint.

#### <a name="example"></a>Пример

```postgresql
SELECT pg_size_pretty(citus_relation_size('github_events'));
```

```
pg_size_pretty
--------------
23 MB
```

### <a name="citus_table_size"></a>\_Размер таблицы \_ Цитус

Получите дисковое пространство, используемое всеми сегментами указанной распределенной таблицы, за исключением индексов (включая ВСПЛЫВАЮЩие окна, карту свободного пространства и карту видимости).

#### <a name="arguments"></a>Аргументы

**логикалрелид:** имя распределенной таблицы.

#### <a name="return-value"></a>Возвращаемое значение

Размер в байтах как bigint.

#### <a name="example"></a>Пример

```postgresql
SELECT pg_size_pretty(citus_table_size('github_events'));
```

```
pg_size_pretty
--------------
37 MB
```

### <a name="citus_total_relation_size"></a>Цитус \_ Общий \_ \_ размер отношения

Возвращает общее дисковое пространство, используемое всеми сегментами указанной распределенной таблицы, включая все индексы и данные всплывающих уведомлений.

#### <a name="arguments"></a>Аргументы

**логикалрелид:** имя распределенной таблицы.

#### <a name="return-value"></a>Возвращаемое значение

Размер в байтах как bigint.

#### <a name="example"></a>Пример

```postgresql
SELECT pg_size_pretty(citus_total_relation_size('github_events'));
```

```
pg_size_pretty
--------------
73 MB
```

### <a name="citus_stat_statements_reset"></a>\_ \_ Сброс инструкций Цитус \_ stat

Удаляет все строки из [citus_stat_statements](reference-hyperscale-metadata.md#query-statistics-table).
Эта функция работает независимо от `pg_stat_statements_reset()` . Чтобы сбросить всю статистику, вызовите обе функции.

#### <a name="arguments"></a>Аргументы

Недоступно

#### <a name="return-value"></a>Возвращаемое значение

None

## <a name="server-group-management-and-repair"></a>Управление группами серверов и восстановление

### <a name="master_copy_shard_placement"></a>\_ \_ Размещение сегментов основного \_ копирования

Если размещение сегмента не удается обновить во время выполнения команды изменения или операции DDL, то оно помечается как неактивное. \_ \_ \_ Чтобы восстановить неактивное размещение сегментов с помощью данных из исправного размещения, можно вызвать функцию размещения сегмента главного копирования.

Для восстановления сегмента функция сначала удаляет неработоспособное размещение сегментов и повторно создает его с помощью схемы в координаторе. После создания размещения сегментов функция копирует данные из работоспособного размещения и обновляет метаданные, чтобы отметить новое расположение сегментов как работоспособное. Эта функция обеспечивает защиту сегмента от любых одновременных изменений во время восстановления.

#### <a name="arguments"></a>Аргументы

** \_ Идентификатор сегмента:** идентификатор сегмента, подлежит восстановлению.

** \_ \_ имя исходного узла:** DNS-имя узла, на котором имеется работоспособное размещение сегментов ( \" исходный \" узел).

** \_ порт исходного узла \_ :** порт на исходном рабочем узле, на котором сервер базы данных прослушивается.

** \_ \_ имя целевого узла:** DNS-имя узла, на котором имеется недопустимое размещение сегментов ( \" целевой \" узел).

** \_ порт целевого узла \_ :** порт на целевом рабочем узле, на котором сервер базы данных прослушивается.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

В приведенном ниже примере исправляется неактивное размещение сегментов сегмента 12345, который имеется на сервере базы данных, работающем на "неверном \_ узле", на порте 5432. Чтобы восстановить его, он будет использовать данные из работоспособного расположения сегмента, присутствующего на сервере, работающем на "хорошем \_ узле", на порту.
5432.

```postgresql
SELECT master_copy_shard_placement(12345, 'good_host', 5432, 'bad_host', 5432);
```

### <a name="master_move_shard_placement"></a>\_ \_ размещение сегмента главного \_ перемещения

Эта функция перемещает заданный сегмент (и его совместное расположение) с одного узла на другой. Он обычно используется косвенно при перебалансировке сегментов, а не непосредственно администратором базы данных.

Существует два способа перемещения данных: блокировка или неблокировка. Блокирующий подход означает, что во время перемещения все изменения сегмента приостанавливаются.
Второй способ, который позволяет избежать блокировки записи сегментов, основан на логической репликации postgres 10.

После успешного выполнения операции перемещения сегменты на исходном узле удаляются. Если перемещение завершается ошибкой в любой момент, эта функция выдает ошибку и оставляет исходный и целевой узлы без изменений.

#### <a name="arguments"></a>Аргументы

** \_ Идентификатор сегмента:** идентификатор сегмента, который необходимо переместить.

** \_ \_ имя исходного узла:** DNS-имя узла, на котором имеется работоспособное размещение сегментов ( \" исходный \" узел).

** \_ порт исходного узла \_ :** порт на исходном рабочем узле, на котором сервер базы данных прослушивается.

** \_ \_ имя целевого узла:** DNS-имя узла, на котором имеется недопустимое размещение сегментов ( \" целевой \" узел).

** \_ порт целевого узла \_ :** порт на целевом рабочем узле, на котором сервер базы данных прослушивается.

**режим перенаправления сегмента \_ \_ :** (необязательно) укажите метод репликации, необходимость использования логической репликации PostgreSQL или команды копирования между работниками. Допустимые значения:

> -   `auto`: Требуется удостоверение реплики, если логическая репликация возможна, в противном случае используйте поведение прежних версий (например, для восстановления сегмента, PostgreSQL 9,6). Это значение по умолчанию.
> -   `force_logical`: Используйте логическую репликацию, даже если таблица не имеет идентификатора реплики. Во время репликации все параллельные инструкции обновления и удаления в таблице завершатся ошибкой.
> -   `block_writes`: Используйте копию (блокирующие операции записи) для таблиц, в которых отсутствует удостоверение первичного ключа или реплики.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

```postgresql
SELECT master_move_shard_placement(12345, 'from_host', 5432, 'to_host', 5432);
```

### <a name="rebalance_table_shards"></a>перераспределение \_ \_ сегментов таблиц

Функция перераспределения \_ табличных \_ сегментов () перемещает сегменты данной таблицы, чтобы равномерно распределять их между рабочими процессами. Функция сначала вычисляет список перемещений, которые необходимо выполнить, чтобы обеспечить сбалансированность группы серверов в пределах заданного порогового значения. Затем он перемещает размещение сегментов по одному с исходного узла на целевой узел и обновляет соответствующие метаданные сегмента, чтобы отразить перемещение.

При определении равномерного распределения сегментов каждому сегменту назначаются затраты \" . \" По умолчанию каждый сегмент имеет одинаковые затраты (значение 1), поэтому распределение для распределения затрат между рабочими процессами аналогично выровнять количество сегментов для каждого из них. Стратегия постоянной стоимости вызывается \" \_ \_ числом сегментов \" и является стратегией ребалансировки по умолчанию.

Стратегия по умолчанию подходит в следующих случаях.

*  Сегменты имеют примерно одинаковый размер
*  Сегменты получают примерно одинаковый объем трафика.
*  Все рабочие узлы имеют одинаковый размер и тип
*  Сегменты не закреплены для определенных рабочих ролей

Если какое-либо из этих допущений не удерживается, перераспределение по умолчанию может привести к неправильному плану. В этом случае вы можете настроить стратегию с помощью `rebalance_strategy` параметра.

Рекомендуется вызвать [get_rebalance_table_shards_plan](#get_rebalance_table_shards_plan) перед выполнением перераспределения \_ \_ сегментов таблицы, чтобы просмотреть и проверить действия, которые необходимо выполнить.

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** (необязательно) имя таблицы, сегменты которой необходимо перераспределить. Если значение равно NULL, перераспределите все существующие группы совместного размещения.

**пороговое значение** (необязательно) число с плавающей запятой в диапазоне от 0,0 до 1,0, указывающее на максимальную разницу использования узла из среднего использования. Например, если указать 0,1, то перебалансировщик сегментов будет пытаться сбалансировать все узлы, чтобы они содержали одинаковое количество сегментов ± 10%.
В частности, подсистема балансировки сегментов будет пытаться свести использование всех рабочих узлов к среднему использованию (1 порог) \* \_ \. . (1
+ порог) \* средний \_ диапазон использования.

Максимальное число ** \_ \_ перемещений сегментов:** (необязательно) максимальное количество сегментов для перемещения.

**список исключенных \_ сегментов \_ :** (необязательных) идентификаторы сегментов, которые не должны перемещаться во время операции перераспределения.

**режим перенаправления сегмента \_ \_ :** (необязательно) укажите метод репликации, необходимость использования логической репликации PostgreSQL или команды копирования между работниками. Допустимые значения:

> -   `auto`: Требуется удостоверение реплики, если логическая репликация возможна, в противном случае используйте поведение прежних версий (например, для восстановления сегмента, PostgreSQL 9,6). Это значение по умолчанию.
> -   `force_logical`: Используйте логическую репликацию, даже если таблица не имеет идентификатора реплики. Во время репликации все параллельные инструкции обновления и удаления в таблице завершатся ошибкой.
> -   `block_writes`: Используйте копию (блокирующие операции записи) для таблиц, в которых отсутствует удостоверение первичного ключа или реплики.

** \_ только сток.** если значение равно true, перемещение сегментов за пределы рабочих узлов, `shouldhaveshards` для которых задано значение false, в [pg_dist_node](reference-hyperscale-metadata.md#worker-node-table); перемещение других сегментов не выполняется.

** \_ стратегия перераспределения:** (необязательно) имя стратегии в [pg_dist_rebalance_strategy](reference-hyperscale-metadata.md#rebalancer-strategy-table).
Если этот аргумент опущен, функция выбирает стратегию по умолчанию, как указано в таблице.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

В приведенном ниже примере будет предпринята попытка перераспределения сегментов \_ таблицы событий GitHub в пределах порогового значения по умолчанию.

```postgresql
SELECT rebalance_table_shards('github_events');
```

Этот пример использования попытается перераспределить \_ таблицу событий GitHub без перемещения сегментов с идентификатором 1 и 2.

```postgresql
SELECT rebalance_table_shards('github_events', excluded_shard_list:='{1,2}');
```

### <a name="get_rebalance_table_shards_plan"></a>получить \_ \_ план перераспределения \_ сегментов таблиц \_

Вывод запланированных перемещений сегментов [rebalance_table_shards](#rebalance_table_shards) без их выполнения.
В то время как маловероятно, в \_ плане перераспределения \_ \_ сегментов таблиц \_ может выводиться немного иной план, чем при \_ вызове перераспределения сегментов таблицы \_ с теми же аргументами. Они не выполняются одновременно, поэтому факты о группе серверов ( \- например, место на диске) \- могут отличаться между вызовами.

#### <a name="arguments"></a>Аргументы

Те же аргументы, что и для перераспределения \_ \_ сегментов таблицы: отношение, пороговое значение, максимальное число \_ \_ перемещений сегментов, исключенный \_ \_ список сегментов и \_ только сток. См. документацию по этой функции для аргументов "значение".

#### <a name="return-value"></a>Возвращаемое значение

Кортежи, содержащие следующие столбцы:

-   ** \_ имя таблицы**: таблица, сегменты которой будут перемещены
-   **шардид**: интересующий сегмент.
-   ** \_ Размер сегмента**: размер в байтах
-   **SourceName**: имя узла исходного узла.
-   **саурцепорт**: порт исходного узла.
-   **TargetName**: имя узла назначения
-   **таржетпорт**: порт узла назначения

### <a name="get_rebalance_progress"></a>получение \_ \_ хода выполнения перераспределения

После начала перераспределения сегмента `get_rebalance_progress()` функция отображает ход выполнения каждого сегмента. Он отслеживает перемещения, запланированные и выполняемые `rebalance_table_shards()` .

#### <a name="arguments"></a>Аргументы

Недоступно

#### <a name="return-value"></a>Возвращаемое значение

Кортежи, содержащие следующие столбцы:

-   **SessionID**: postgres PID монитора перераспределения
-   ** \_ имя таблицы**: таблица, сегменты которой перемещаются
-   **шардид**: интересующий сегмент.
-   ** \_ Размер сегмента**: размер в байтах
-   **SourceName**: имя узла исходного узла.
-   **саурцепорт**: порт исходного узла.
-   **TargetName**: имя узла назначения
-   **таржетпорт**: порт узла назначения
-   **ход выполнения**: 0 = ожидание перемещения; 1 = Перемещение; 2 = выполнено

#### <a name="example"></a>Пример

```sql
SELECT * FROM get_rebalance_progress();
```

```
┌───────────┬────────────┬─────────┬────────────┬───────────────┬────────────┬───────────────┬────────────┬──────────┐
│ sessionid │ table_name │ shardid │ shard_size │  sourcename   │ sourceport │  targetname   │ targetport │ progress │
├───────────┼────────────┼─────────┼────────────┼───────────────┼────────────┼───────────────┼────────────┼──────────┤
│      7083 │ foo        │  102008 │    1204224 │ n1.foobar.com │       5432 │ n4.foobar.com │       5432 │        0 │
│      7083 │ foo        │  102009 │    1802240 │ n1.foobar.com │       5432 │ n4.foobar.com │       5432 │        0 │
│      7083 │ foo        │  102018 │     614400 │ n2.foobar.com │       5432 │ n4.foobar.com │       5432 │        1 │
│      7083 │ foo        │  102019 │       8192 │ n3.foobar.com │       5432 │ n4.foobar.com │       5432 │        2 │
└───────────┴────────────┴─────────┴────────────┴───────────────┴────────────┴───────────────┴────────────┴──────────┘
```

### <a name="citus_add_rebalance_strategy"></a>Цитус \_ Добавление \_ стратегии перераспределения \_

Добавьте строку в [pg_dist_rebalance_strategy](reference-hyperscale-metadata.md?#rebalancer-strategy-table) .

#### <a name="arguments"></a>Аргументы

Дополнительные сведения об этих аргументах см. в соответствующих значениях столбцов в `pg_dist_rebalance_strategy` .

**Name:** идентификатор новой стратегии.

** \_ функция стоимости сегмента \_ :** определяет функцию, используемую для определения \" стоимости \" каждого сегмента.

** \_ функция емкости узла \_ :** определяет функцию для измерения емкости узла

** \_ разрешено использование сегмента \_ в \_ \_ функции node:** определяет функцию, которая определяет, какие сегменты можно разместить на каких узлах.

** \_ пороговое значение по умолчанию:** пороговое значение с плавающей запятой, которое настраивает, насколько равномерно распределяется стоимость совокупной стоимости сегментов между узлами

**минимальное \_ пороговое значение:** (необязательно) столбец защиты с минимальным значением, допустимым для порогового аргумента перераспределения \_ \_ сегментов таблицы (). Его значение по умолчанию — 0.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

### <a name="citus_set_default_rebalance_strategy"></a>Цитус \_ . \_ Настройка \_ стратегии перераспределения по умолчанию \_

Обновите таблицу [pg_dist_rebalance_strategy](reference-hyperscale-metadata.md#rebalancer-strategy-table) , изменив стратегию, указав ее аргумент на значение по умолчанию, которое будет выбрано при перераспределении сегментов.

#### <a name="arguments"></a>Аргументы

**Имя:** имя стратегии в \_ \_ стратегии перераспределения в PG расп. \_

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

```postgresql
SELECT citus_set_default_rebalance_strategy('by_disk_size');
```

### <a name="citus_remote_connection_stats"></a>\_Статистика удаленного \_ подключения \_ Цитус

Функция Цитус \_ Remote \_ Connection \_ stats () показывает количество активных подключений к каждому удаленному узлу.

#### <a name="arguments"></a>Аргументы

Недоступно

#### <a name="example"></a>Пример

```postgresql
SELECT * from citus_remote_connection_stats();
```

```
    hostname    | port | database_name | connection_count_to_node
----------------+------+---------------+--------------------------
 citus_worker_1 | 5432 | postgres      |                        3
(1 row)
```

### <a name="master_drain_node"></a>\_узел стока главного \_ узла

\_ \_ Функция node стока () перемещает сегменты с указанного узла и на другие узлы, `shouldhaveshards` для которых в [pg_dist_node](reference-hyperscale-metadata.md#worker-node-table)задано значение true. Вызовите функцию перед удалением узла из группы серверов и отключив физический сервер узла.

#### <a name="arguments"></a>Аргументы

**nodename:** Имя узла для стока.

**нодепорт:** Номер порта узла для очистки.

**режим перенаправления сегмента \_ \_ :** (необязательно) укажите метод репликации, необходимость использования логической репликации PostgreSQL или команды копирования между работниками. Допустимые значения:

> -   `auto`: Требуется удостоверение реплики, если логическая репликация возможна, в противном случае используйте поведение прежних версий (например, для восстановления сегмента, PostgreSQL 9,6). Это значение по умолчанию.
> -   `force_logical`: Используйте логическую репликацию, даже если таблица не имеет идентификатора реплики. Во время репликации все параллельные инструкции обновления и удаления в таблице завершатся ошибкой.
> -   `block_writes`: Используйте копию (блокирующие операции записи) для таблиц, в которых отсутствует удостоверение первичного ключа или реплики.

** \_ стратегия перераспределения:** (необязательно) имя стратегии в [pg_dist_rebalance_strategy](reference-hyperscale-metadata.md#rebalancer-strategy-table).
Если этот аргумент опущен, функция выбирает стратегию по умолчанию, как указано в таблице.

#### <a name="return-value"></a>Возвращаемое значение

Недоступно

#### <a name="example"></a>Пример

Ниже приведены типичные шаги для удаления одного узла (например, 10.0.0.1 на стандартном порту PostgreSQL):

1.  Сток узла.

    ```postgresql
    SELECT * from master_drain_node('10.0.0.1', 5432);
    ```

2.  Дождитесь завершения команды

3.  Удаление узла

При стоке нескольких узлов рекомендуется использовать вместо него [rebalance_table_shards](#rebalance_table_shards) . Это позволяет масштабировать (Цитус) масштабирование и перемещение сегментов минимальное число раз.

1.  Выполните для каждого узла, который требуется удалить:

    ```postgresql
    SELECT * FROM master_set_node_property(node_hostname, node_port, 'shouldhaveshards', false);
    ```

2.  Поразрядить их все одновременно с [rebalance_table_shards](#rebalance_table_shards)

    ```postgresql
    SELECT * FROM rebalance_table_shards(drain_only := true);
    ```

3.  Дождитесь завершения перераспределения

4.  Удаление узлов

### <a name="replicate_table_shards"></a>Репликация \_ \_ сегментов таблицы

Функция репликации \_ \_ сегментов () реплицирует реплицированные сегменты данной таблицы. Функция сначала вычисляет список реплицируемых сегментов и расположений, из которых они могут быть получены для репликации. Затем функция копирует эти сегменты и обновляет соответствующие метаданные сегмента, чтобы отразить копию.

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** имя таблицы, сегменты которой необходимо реплицировать.

** \_ фактор репликации сегмента \_ :** (необязательно) необходимый коэффициент репликации для достижения каждого сегмента.

**Максимальное \_ число \_ копий сегментов:** (необязательно) максимальное количество сегментов для копирования для достижения нужного фактора репликации.

**список исключенных \_ сегментов \_ :** (необязательных) идентификаторы сегментов, которые не должны копироваться во время операции репликации.

#### <a name="return-value"></a>Возвращаемое значение

Н/Д

#### <a name="examples"></a>Примеры

В приведенном ниже примере будет предпринята попытка репликации сегментов \_ таблицы событий GitHub в \_ Коэффициент репликации сегмента \_ .

```postgresql
SELECT replicate_table_shards('github_events');
```

В этом примере будет предпринята попытка перенести сегменты \_ таблицы событий GitHub в нужный коэффициент репликации с максимальным числом копий сегментов (10). Подсистема балансировки будет копировать не более 10 сегментов при попытке достигнуть нужного коэффициента репликации.

```postgresql
SELECT replicate_table_shards('github_events', max_shard_copies:=10);
```

### <a name="isolate_tenant_to_new_shard"></a>изолировать \_ клиент \_ до \_ нового \_ сегмента

Эта функция создает новый сегмент для хранения строк с конкретным одиночным значением в столбце распределения. Это особенно удобно для случая использования нескольких клиентов (Цитус), где большой клиент может быть размещен отдельно в своем сегменте и, в конечном итоге, в собственном физическом узле.

#### <a name="arguments"></a>Аргументы

** \_ имя таблицы:** имя таблицы для получения нового сегмента.

** \_ идентификатор клиента:** значение столбца распределения, которое будет назначено новому сегменту.

** \_ параметр CASCADE:** (необязательно), \" Если задано значение CASCADE, \" также изолирует сегмент от всех таблиц в [группе](concepts-hyperscale-colocation.md)совместного размещения текущей таблицы.

#### <a name="return-value"></a>Возвращаемое значение

** \_ Идентификатор сегмента.** функция возвращает уникальный идентификатор, назначенный только что созданному сегменту.

#### <a name="examples"></a>Примеры

Создайте новый сегмент для хранения LineItems для клиента 135:

```postgresql
SELECT isolate_tenant_to_new_shard('lineitem', 135);
```

```
┌─────────────────────────────┐
│ isolate_tenant_to_new_shard │
├─────────────────────────────┤
│                      102240 │
└─────────────────────────────┘
```

## <a name="next-steps"></a>Дальнейшие шаги

* Многие из функций, описанных в этой статье, изменяют системные [таблицы метаданных](reference-hyperscale-metadata.md) .
* [Параметры сервера](reference-hyperscale-parameters.md) Настройка поведения некоторых функций
