---
title: Сведения о структуре определения политики
description: Описывает, как определения политик используются для установки соглашений о ресурсах Azure в организации.
ms.date: 10/05/2020
ms.topic: conceptual
ms.openlocfilehash: 8e7cea1d03b0a236b9a485c2e640d7bf3f4e8e7e
ms.sourcegitcommit: 33368ca1684106cb0e215e3280b828b54f7e73e8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/16/2020
ms.locfileid: "92132488"
---
# <a name="azure-policy-definition-structure"></a>Структура определения службы "Политика Azure"

Политика Azure устанавливает соглашения о ресурсах. Определения политик описывают соответствие ресурсов [условия](#conditions) и последствия выполнения условий. Условие сравнивает свойство ресурса [поле](#fields) с требуемым значением. Доступ к полям свойств ресурсов осуществляется с помощью [псевдонимов](#aliases). Поле свойства ресурса является либо полем с одним значением, либо [массивом](#understanding-the--alias) из нескольких значений. Оценка условий различается для массивов.
Дополнительные сведения об [условиях](#conditions).

Это соглашения помогут вам контролировать расходы и управлять ресурсами. Например, можно указать, что разрешены только определенные типы виртуальных машин. Также можно потребовать, чтобы ресурсы имели определенный тег. Назначения политики наследуются дочерними ресурсами. Если назначение политики применяется к группе ресурсов, оно применяется ко всем ресурсам в этой группе ресурсов.

Схема определения политики _класс policyrule_ находится здесь: [https://schema.management.azure.com/schemas/2019-09-01/policyDefinition.json](https://schema.management.azure.com/schemas/2019-09-01/policyDefinition.json)

Для создания определения политики используется JSON. Определение политики содержит следующие элементы:

- display name
- description
- mode
- метаданные
- параметры
- policy rule
  - logical evaluation
  - effect

В следующем примере JSON показана политика, которая налагает ограничения на расположения для развертывания ресурсов.

```json
{
    "properties": {
        "displayName": "Allowed locations",
        "description": "This policy enables you to restrict the locations your organization can specify when deploying resources.",
        "mode": "Indexed",
        "metadata": {
            "version": "1.0.0",
            "category": "Locations"
        },
        "parameters": {
            "allowedLocations": {
                "type": "array",
                "metadata": {
                    "description": "The list of locations that can be specified when deploying resources",
                    "strongType": "location",
                    "displayName": "Allowed locations"
                },
                "defaultValue": [ "westus2" ]
            }
        },
        "policyRule": {
            "if": {
                "not": {
                    "field": "location",
                    "in": "[parameters('allowedLocations')]"
                }
            },
            "then": {
                "effect": "deny"
            }
        }
    }
}
```

Встроенные и шаблоны политики Azure приведены в [примерах политики Azure](../samples/index.md).

## <a name="display-name-and-description"></a>Отображаемое имя и описание

Параметры **displayName** и **description** позволяют идентифицировать определение политики и описать контекст для ее использования. Максимальная длина **displayName** составляет _128_ символов, а **description** — _512_ символов.

> [!NOTE]
> Во время создания или обновления определения политики **идентификатор**, **тип** и **имя** определяются свойствами, которые являются внешними по отношению к JSON и не обязательны в JSON-файле. Выборка определения политики с помощью пакета SDK возвращает **идентификатор**, **тип** и **имя** свойства как часть JSON, но все они являются сведениями только для чтения, относящимися к определению политики.

## <a name="type"></a>Тип

Хотя свойство **Type** не может быть задано, пакет SDK возвращает три значения, которые отображаются на портале:

- `Builtin`: Эти определения политик предоставляются и обслуживаются корпорацией Майкрософт.
- `Custom`: Все определения политик, созданные клиентами, имеют это значение.
- `Static`: Указывает определение политики [соответствия нормативным требованиям](./regulatory-compliance.md) с **владением**Майкрософт. Результаты проверки соответствия для этих определений политик являются результатами сторонних аудитов в инфраструктуре Майкрософт. В портал Azure это значение иногда отображается как **управляемое корпорацией Майкрософт**. Дополнительные сведения см. [в разделе Общая ответственность в облаке](../../../security/fundamentals/shared-responsibility.md).

## <a name="mode"></a>Режим

**Режим** настраивается в зависимости от того, нацелена ли политика на свойство Azure Resource Manager или на свойство поставщика ресурсов.

### <a name="resource-manager-modes"></a>Режимы Resource Manager

Этот **режим** определяет, какие типы ресурсов оцениваются для определения политики. Ниже приведены поддерживаемые режимы.

- `all`: оцениваются группы ресурсов, подписки и все типы ресурсов.
- `indexed`: оцениваются только типы ресурсов, которые поддерживают теги и расположение.

Например, ресурс `Microsoft.Network/routeTables` поддерживает теги и расположение и оценивается в обоих режимах. Однако ресурс `Microsoft.Network/routeTables/routes` нельзя помечать тегами и он не оценивается в режиме `Indexed`.

В большинстве случаев рекомендуется задать для параметра **mode** значение `all`. Во всех определениях политик, создаваемых на портале, используется режим `all`. Если используется PowerShell или Azure CLI, необходимо указать параметр **mode** вручную. Если определение политики не включает значение **mode**, в Azure PowerShell используется значение по умолчанию `all`, а в Azure CLI — `null`. Режим `null` является тем же, что и при использовании `indexed` для поддержки обратной совместимости.

`indexed` следует использовать при создании политик, которые будут принудительно применять теги или расположения. Это не обязательно, но помешает отображению ресурсов, которые не поддерживают теги и расположения, в качестве несоответствующих в результатах проверки соответствия. Исключением являются **группы ресурсов** и **подписки**. В определениях политик, которые принудительно применяют расположение или теги к группе ресурсов или подписке, следует задать для параметра **mode** значение `all` и явно указать целевой тип `Microsoft.Resources/subscriptions/resourceGroups` или `Microsoft.Resources/subscriptions`. Пример см. в разделе [Шаблон. Теги — пример#1](../samples/pattern-tags.md). Список ресурсов, поддерживающих теги, см. в разделе [Поддержка тегов для ресурсов Azure](../../../azure-resource-manager/management/tag-support.md).

### <a name="resource-provider-modes"></a>Режимы поставщиков ресурсов

Поддерживается следующий режим поставщика ресурсов:

- `Microsoft.Kubernetes.Data` для управления кластерами Kubernetes в Azure или вне Azure. В определениях, использующих этот режим поставщика ресурсов, используются эффекты _Audit_, _Deny_и _disabled_. Использование влияния [енфорцеопаконстраинт](./effects.md#enforceopaconstraint) является _устаревшим_.

В настоящее время в качестве **предварительной версии**поддерживаются следующие режимы поставщика ресурсов:

- `Microsoft.ContainerService.Data` для управления правилами контроллера допуска в [Службе Azure Kubernetes](../../../aks/intro-kubernetes.md). Определения, использующие этот режим поставщика ресурсов, **должны** использовать [енфорцерегополициный](./effects.md#enforceregopolicy) результат. Этот режим является _устаревшим_.
- `Microsoft.KeyVault.Data` для управления хранилищами и сертификатами в [Azure Key Vault](../../../key-vault/general/overview.md). Дополнительные сведения об этих определениях политик см. в статье [интеграция Azure Key Vault с политикой Azure](../../../key-vault/general/azure-policy.md).

> [!NOTE]
> Режимы поставщиков ресурсов поддерживают только встроенные определения политик и не поддерживают [исключения](./exemption-structure.md).

## <a name="metadata"></a>Метаданные

Необязательное `metadata` свойство сохраняет сведения об определении политики. Клиенты могут определять любые свойства и значения, полезные для Организации в `metadata` . Однако существуют некоторые _Общие_ свойства, используемые политикой Azure и встроенными модулями.

### <a name="common-metadata-properties"></a>Общие свойства метаданных

- `version` (строка): отслеживает сведения о версии содержимого определения политики.
- `category` (строка): определяет, в какой категории в портал Azure отображается определение политики.
- `preview` (Boolean): флаг true или false для параметра, если определение политики является _предварительным_.
- `deprecated` (Boolean): флаг true или false для, если определение политики помечено как _нерекомендуемое_.

> [!NOTE]
> Служба Политика Azure использует свойства `version`, `preview` и `deprecated` для передачи уровня изменений встроенному определению политики или инициативе и состоянию. Формат `version` — `{Major}.{Minor}.{Patch}`. Конкретные состояния, такие как _устаревший_ или _предварительная версия_, добавляются к свойству `version` или в другом свойстве как **логическое значение**. Дополнительные сведения о способах встроенных версий политик Azure см. в разделе [Встроенная поддержка версий](https://github.com/Azure/azure-policy/blob/master/built-in-policies/README.md).

## <a name="parameters"></a>Параметры

Параметры помогают упростить управление политиками за счет сокращения числа определений политик. Параметры можно рассматривать как поля в форме: `name`, `address`, `city`, `state`. Эти параметры никогда не меняются, однако их значения изменяются в зависимости от того, как пользователь заполняет форму.
Точно так же параметры работают при создании политик. Добавив параметры в определение политики, вы сможете повторно использовать ее в различных сценариях, указывая разные значения.

> [!NOTE]
> Параметры могут быть добавлены к имеющемуся и назначенному определению. Новый параметр должен включать в себя свойство **defaultValue**. Это предотвращает косвенное использование существующих назначений политики или инициативы.

### <a name="parameter-properties"></a>Свойства параметра

Параметр имеет следующие свойства, которые используются в определении политики:

- `name`: Имя параметра. Используется функцией развертывания `parameters` в правиле политики. Дополнительные сведения см. в разделе [об использовании значения параметра](#using-a-parameter-value).
- `type`: Определяет, является ли параметр **строкой**, **массивом**, **объектом**, **логическим значением**, **целым числом**, **числом с плавающей запятой** или **значением даты/времени**.
- `metadata`: Определяет вложенное свойство, которое в основном используется для отображения понятной пользователям информации на портале Azure:
  - `description`: Объясняет назначение параметра. Можно использовать для примеров допустимых значений.
  - `displayName`: Понятное имя параметра, которое отображается на портале.
  - `strongType`: (Необязательно.) Используется при назначении определения политики через портал. Предоставляет список с учетом контекста. См. дополнительные сведения о [вложенном свойстве strongType](#strongtype).
  - `assignPermissions`: (Необязательно.) Установите на _true_, чтобы портал Azure создавал назначения ролей во время назначения политики. Это свойство полезно, если вы хотите назначить разрешения за пределами области назначения. Для каждого определения роли в политике (или определения роли во всех политиках в этой инициативе) существует одно назначение роли. Значение параметра должно быть допустимым ресурсом или областью.
- `defaultValue`: (Необязательно.) Устанавливает значение параметра в назначении, если значение не указано.
  Это свойство необходимо при обновлении существующего назначенного определения политики.
- `allowedValues`: (Необязательно.) Предоставляет массив значений, которые параметр принимает во время назначения.

Например, можно создать определение политики, чтобы ограничить расположения, в которых могут развертываться ресурсы. Для такого определения политики можно использовать параметр **allowedLocations**. Этот параметр будет использоваться каждым назначением определения политики для ограничения допустимых значений. Использование вложенного свойства **strongType** делает назначение через портал более удобным:

```json
"parameters": {
    "allowedLocations": {
        "type": "array",
        "metadata": {
            "description": "The list of allowed locations for resources.",
            "displayName": "Allowed locations",
            "strongType": "location"
        },
        "defaultValue": [ "westus2" ],
        "allowedValues": [
            "eastus2",
            "westus2",
            "westus"
        ]
    }
}
```

### <a name="using-a-parameter-value"></a>Использование значения параметра

В правилах политики полученные параметры используются со следующим синтаксисом функции `parameters`.

```json
{
    "field": "location",
    "in": "[parameters('allowedLocations')]"
}
```

В этом примере используется параметр **allowedLocations**, который рассматривался в разделе о [свойствах параметра](#parameter-properties).

### <a name="strongtype"></a>strongType

В свойстве `metadata` можно использовать вложенное свойство **strongType**, чтобы предоставить список для выбора параметров на портале Azure. **strongType** может быть поддерживаемым _типом ресурса_ или допустимым значением. Чтобы определить, допустим ли _тип ресурса_ для **strongType**, используйте [Get-AzResourceProvider](/powershell/module/az.resources/get-azresourceprovider). Для _типа ресурса_ **стронгтипе** имеет формат `<Resource Provider>/<Resource Type>` . Например, `Microsoft.Network/virtualNetworks/subnets`.

Некоторые поддерживаемые _типы ресурсов_ **Get-AzResourceProvider** не возвращает. Эти типы:

- `Microsoft.RecoveryServices/vaults/backupPolicies`

Допустимыми значениями, помимо _типов ресурсов_ для **strongType**, являются следующие.

- `location`
- `resourceTypes`
- `storageSkus`
- `vmSKUs`
- `existingResourceGroups`

## <a name="definition-location"></a>Расположение определения

При создании инициативы или политики необходимо указывать расположение определения. Расположение определения должно быть задано как группа управления или подписка. Расположение указывает область, которой можно назначить инициативу или политику. Ресурсы должны быть непосредственными членами или дочерними элементами в иерархии расположения определения для назначения.

Если расположение определения является

- Только для **подписки** на ресурсы в этой подписке можно назначить определение политики.
- Определение политики может быть назначено только для ресурсов **группы** управления в дочерних группах управления и дочерних подписках. Если вы планируете применить определение политики к нескольким подпискам, расположение должно быть группой управления, содержащей каждую подписку.

Дополнительные сведения см. [в разделе сведения о области в политике Azure](./scope.md#definition-location).

## <a name="policy-rule"></a>Правило политики

Правило политики состоит из блоков **If** и **Then**. В блоке **If** указываются одно или несколько условий. Они определяют, когда применяется эта политика. В этих условиях можно использовать логические операторы, чтобы точно определить сценарии для использования политики.

В блоке **Then** описываются результаты, которые вступают в силу при соблюдении условий из блока **If**.

```json
{
    "if": {
        <condition> | <logical operator>
    },
    "then": {
        "effect": "deny | audit | modify | append | auditIfNotExists | deployIfNotExists | disabled"
    }
}
```

### <a name="logical-operators"></a>Логические операторы

Ниже перечислены поддерживаемые логические операторы.

- `"not": {condition  or operator}`
- `"allOf": [{condition or operator},{condition or operator}]`
- `"anyOf": [{condition or operator},{condition or operator}]`

Оператор **not** инвертирует результат условия. Оператор **allOf** действует как логическая операция **And**, то есть требует соблюдения всех входящих в него условий. Оператор **anyOf** действует как логическая операция **Or**, то есть проверяет соблюдение хотя бы одного из входящих в него условий.

Допускается вложение логических операторов. В следующем примере представлена операция **not**, вложенная в операцию **allOf**.

```json
"if": {
    "allOf": [{
            "not": {
                "field": "tags",
                "containsKey": "application"
            }
        },
        {
            "field": "type",
            "equals": "Microsoft.Storage/storageAccounts"
        }
    ]
},
```

### <a name="conditions"></a>Условия

Условие определяет, соответствует ли метод доступа **field** или **value** определенным критериям. Поддерживаются такие условия:

- `"equals": "stringValue"`
- `"notEquals": "stringValue"`
- `"like": "stringValue"`
- `"notLike": "stringValue"`
- `"match": "stringValue"`
- `"matchInsensitively": "stringValue"`
- `"notMatch": "stringValue"`
- `"notMatchInsensitively": "stringValue"`
- `"contains": "stringValue"`
- `"notContains": "stringValue"`
- `"in": ["stringValue1","stringValue2"]`
- `"notIn": ["stringValue1","stringValue2"]`
- `"containsKey": "keyName"`
- `"notContainsKey": "keyName"`
- `"less": "dateValue"` | `"less": "stringValue"` | `"less": intValue`
- `"lessOrEquals": "dateValue"` | `"lessOrEquals": "stringValue"` | `"lessOrEquals": intValue`
- `"greater": "dateValue"` | `"greater": "stringValue"` | `"greater": intValue`
- `"greaterOrEquals": "dateValue"` | `"greaterOrEquals": "stringValue"` |
  `"greaterOrEquals": intValue`
- `"exists": "bool"`

Для **less**, **lessOrEquals**, **greater** и **greaterOrEquals**, если тип свойства не совпадает с типом условия, выдается ошибка. Сравнение строк выполняется с помощью `InvariantCultureIgnoreCase`.

При использовании условий **like** и **notLike** можно указать в значении подстановочный знак `*`.
Значение не должно содержать более одного подстановочного знака `*`.

При использовании условий **match** и **notMatch** укажите `#` для сопоставления цифры, `?` для буквы, `.` для сопоставления любого знака и любой другой знак для сопоставления соответствующего фактического знака. Хотя **Match** и **notMatch** учитывают регистр, все остальные условия, в которых вычисляется _StringValue_ , не учитывают регистр. Другие варианты без учета регистра доступны для условий **matchInsensitively** и **notMatchInsensitively**.

В **\[\*\] псевдониме** значения поля массива каждый элемент массива вычисляется отдельно с помощью логического **и** между элементами. Более подробную информацию см. в разделе [Оценка \[\*\] псевдонима](../how-to/author-policies-for-arrays.md#evaluating-the--alias).

### <a name="fields"></a>Поля

Условия создаются на основе полей. Поле сопоставляет свойства в полезных данных запроса ресурса и описывает состояния ресурса.

Поддерживаются следующие поля.

- `name`
- `fullName`
  - Возвращает полное имя ресурса. Полное имя ресурса — это имя ресурса, к которому добавлены любые имена родительских ресурсов (например, myServer/myDatabase).
- `kind`
- `type`
- `location`
  - Используйте **global** для ресурсов, которые зависят от расположения.
- `id`
  - Возвращает идентификатор ресурса, для которого выполняется оценка.
  - Пример: `/subscriptions/06be863d-0996-4d56-be22-384767287aa2/resourceGroups/myRG/providers/Microsoft.KeyVault/vaults/myVault`
- `identity.type`
  - Возвращает тип [управляемого удостоверения](../../../active-directory/managed-identities-azure-resources/overview.md), включенный в ресурс.
- `tags`
- `tags['<tagName>']`
  - Этот синтаксис в скобках поддерживает имена тегов, которые содержат такие знаки препинания, как дефис, точку или пробел.
  - Где **\<tagName\>** — имя тега, для которого проверяется условие.
  - Пример: `tags['Acct.CostCenter']`. **Acct.CostCenter** — это имя тега.
- `tags['''<tagName>''']`
  - Этот синтаксис в скобках поддерживает имена тегов, которые содержат апострофы благодаря использованию двойного апострофа.
  - Где **" \<tagName\> "** — это имя тега, для которого проверяется условие.
  - Пример: `tags['''My.Apostrophe.Tag''']`, где **'My.Apostrophe.Tag'** является именем тега.
- Список псевдонимов свойств указан в разделе [Псевдонимы](#aliases).

> [!NOTE]
> `tags.<tagName>`, `tags[tagName]` и `tags[tag.with.dots]` все еще являются приемлемыми способами объявления поля тегов. Однако предпочтительными являются выражения, указанные выше.

#### <a name="use-tags-with-parameters"></a>Использование тегов с параметрами

Значение параметра передается полю тега. Передача параметра полю тега повышает гибкость определения политики во время ее назначения.

В указанном ниже примере `concat` используется для создания поля подстановки тега для тега со значением параметра **tagName**. Если такой тег не существует, то с помощью действия **modify** добавляется тег, использующий значение тега с таким же именем, заданным для проверенной родительской группы ресурсов с помощью функции поиска `resourcegroup()`.

```json
{
    "if": {
        "field": "[concat('tags[', parameters('tagName'), ']')]",
        "exists": "false"
    },
    "then": {
        "effect": "modify",
        "details": {
            "operations": [{
                "operation": "add",
                "field": "[concat('tags[', parameters('tagName'), ']')]",
                "value": "[resourcegroup().tags[parameters('tagName')]]"
            }],
            "roleDefinitionIds": [
                "/providers/microsoft.authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c"
            ]
        }
    }
}
```

### <a name="value"></a>Значение

Условия также можно настраивать с помощью **value**. **value** проверяет условия на соответствие [параметрам](#parameters), [поддерживаемым функциям шаблонов](#policy-functions) или литералам. **value** используется в паре с любым поддерживаемым [условием](#conditions).

> [!WARNING]
> Если результатом _функции шаблона_ является ошибка, оценка политики завершится сбоем. Завершившаяся сбоем оценка — это неявный **запрет**. Дополнительные сведения см. в разделе [Аvoiding template failures](#avoiding-template-failures) (Предотвращение сбоев шаблонов). Используйте [enforcementMode](./assignment-structure.md#enforcement-mode) **DoNotEnforce**, чтобы исключить влияние неудачной оценки на новые или обновленные ресурсы при тестировании и проверке нового определения политики.

#### <a name="value-examples"></a>Примеры значений

В этом примере правила политики используют **value** для сравнения результата функции `resourceGroup()` и возвращенного свойства **name** с условием **like** для `*netrg`. Это правило запрещает любой ресурс, с **типом**, отличающимся от `Microsoft.Network/*`, в любой группе ресурсов, имя которой заканчивается на `*netrg`.

```json
{
    "if": {
        "allOf": [{
                "value": "[resourceGroup().name]",
                "like": "*netrg"
            },
            {
                "field": "type",
                "notLike": "Microsoft.Network/*"
            }
        ]
    },
    "then": {
        "effect": "deny"
    }
}
```

В этом примере правила политики используют **value** (значение) для проверки того, **равен** ли `true` результат нескольких вложенных функций. Это правило запрещает любой ресурс, в котором нет хотя бы трех тегов.

```json
{
    "mode": "indexed",
    "policyRule": {
        "if": {
            "value": "[less(length(field('tags')), 3)]",
            "equals": "true"
        },
        "then": {
            "effect": "deny"
        }
    }
}
```

#### <a name="avoiding-template-failures"></a>Предотвращение сбоев шаблонов

Использование _функций шаблона_ в **value** позволяет выполнять многие сложные вложенные функции. Если результатом _функции шаблона_ является ошибка, оценка политики завершится сбоем. Завершившаяся сбоем оценка — это неявный **запрет**. Пример **value**, которое приводит к сбою в некоторых сценариях.

```json
{
    "policyRule": {
        "if": {
            "value": "[substring(field('name'), 0, 3)]",
            "equals": "abc"
        },
        "then": {
            "effect": "audit"
        }
    }
}
```

В примере правила политики выше используется [substring()](../../../azure-resource-manager/templates/template-functions-string.md#substring) для сравнения первых трех символов **имени** с **abc**. Если **имя** короче трех символов, то функция `substring()` приводит к ошибке. Эта ошибка приводит к тому, что политика становится действием **deny**.

Вместо этого используйте функцию [if()](../../../azure-resource-manager/templates/template-functions-logical.md#if), чтобы проверить, совпадают ли первые три символа **имени** с **abc**, не давая **имени** короче трех символов вызывать ошибку.

```json
{
    "policyRule": {
        "if": {
            "value": "[if(greaterOrEquals(length(field('name')), 3), substring(field('name'), 0, 3), 'not starting with abc')]",
            "equals": "abc"
        },
        "then": {
            "effect": "audit"
        }
    }
}
```

С измененным правилом политики `if()` проверяет длину **имени** перед попыткой получить `substring()` для значения с менее чем тремя символами. Если **имя** слишком коротко, то возвращается значение «не начинается с abc», которое затем сравнивается с **abc**. Ресурс с коротким именем, которое не начинается с **abc**, по-прежнему не выполняет правило политики, но больше не вызывает ошибку во время оценки.

### <a name="count"></a>Count

Условия, которые подсчитывают, сколько элементов массива в полезных данных ресурса соответствуют выражению условия, могут быть сформированы с помощью выражения **count** (подсчет). Распространенными сценариями является проверка того, удовлетворяет ли условию «по крайней мере один из», «только один из», «все» или «ни одного» из элементов массива. **Count** оценивает каждый [\[\*\] псевдоним элемента массива](#understanding-the--alias) для выражения условия и суммирует результаты _true_, которые затем сравниваются с оператором выражения. Выражения **Count** можно добавлять до трех раз в одно определение **класс policyrule** .

Структура выражения **сount**

```json
{
    "count": {
        "field": "<[*] alias>",
        "where": {
            /* condition expression */
        }
    },
    "<condition>": "<compare the count of true condition expression array members to this value>"
}
```

С **count** используются следующие свойства.

- **count.field** (обязательное): содержит путь к массиву и должно быть псевдонимом массива. Если массив отсутствует, выражение оценивается как _false_ без учета выражения условия.
- **count.where** (необязательное): выражение условия для индивидуального вычисления каждого [\[\*\] псевдонима](#understanding-the--alias) элемента массива **count.field**. Если это свойство не указано, все элементы массива с путем "Field" оцениваются в _значение true_. В этом свойстве можно использовать любое [condition](../concepts/definition-structure.md#conditions) (условие).
  Внутри этого свойства можно использовать [логические операторы](#logical-operators) для создания сложных требований к оценке.
- **\<condition\>** (обязательно): значение сравнивается с числом элементов, которые соответствуют условному выражению **Count. Where** . Следует использовать числовое [condition](../concepts/definition-structure.md#conditions).

#### <a name="count-examples"></a>Примеры подсчета

Пример 1: Проверить, является ли массив пустым.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]"
    },
    "equals": 0
}
```

Пример 2. Проверять только один элемент массива на соответствие выражению условия.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].description",
            "equals": "My unique description"
        }
    },
    "equals": 1
}
```

Пример 3. Проверить хотя бы один элемент массива на соответствие выражению условия.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].description",
            "equals": "My common description"
        }
    },
    "greaterOrEquals": 1
}
```

Пример 4. Убедиться, что все члены массива объектов соответствуют выражению условия.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].description",
            "equals": "description"
        }
    },
    "equals": "[length(field('Microsoft.Network/networkSecurityGroups/securityRules[*]'))]"
}
```

Пример 5. Проверка того, что хотя бы один элемент массива соответствует нескольким свойствам в выражении условия

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "allOf": [
                {
                    "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].direction",
                    "equals": "Inbound"
                },
                {
                    "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].access",
                    "equals": "Allow"
                },
                {
                    "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].destinationPortRange",
                    "equals": "3389"
                }
            ]
        }
    },
    "greater": 0
}
```

### <a name="effect"></a>Действие

Политика Azure поддерживает следующие типы действий:

- **Append** добавляет в запрос некоторый набор полей;
- **Audit** записывает предупреждение в журнал действий, но не отвергает запрос;
- **AuditIfNotExists**: создает событие предупреждения в журнале действий, если связанный ресурс не существует;
- **Deny** записывает событие в журнал действий и отвергает запрос;
- **DeployIfNotExists**: развертывает связанный ресурс, если он еще не существует;
- **Disabled** не оценивает ресурсы на соответствие правилу политики.
- **Modify**: добавляет, обновляет или удаляет определенные теги из ресурса;
- **Енфорцеопаконстраинт** (не рекомендуется): Настройка контроллера рассоединений агента открытой политики с привратником v3 для самостоятельно управляемых кластеров Kubernetes в Azure
- **Енфорцерегополици** (не рекомендуется): Настройка контроллера допусков агента открытой политики с привратником версии 2 в службе Kubernetes Azure.

Подробные сведения о каждом эффекте, порядке оценки и свойствах, а также примеры см. в статье [Действия политик Azure](effects.md).

### <a name="policy-functions"></a>Функции политики

В рамках правила политики можно использовать все [функции шаблона Resource Manager](../../../azure-resource-manager/templates/template-functions.md), кроме функций, определяемых пользователем и следующих.

- copyIndex()
- deployment()
- list*
- newGuid()
- pickZones()
- providers()
- reference()
- resourceId()
- variables()

> [!NOTE]
> Эти функции по-прежнему доступны в части `details.deployment.properties.template` развертывания шаблона, в определении политики **deployIfNotExists**.

Следующая функция доступна для использования в правиле политики, но отличается от использования в шаблоне Azure Resource Manager (шаблон ARM):

- `utcNow()` -В отличие от шаблона ARM, это свойство может использоваться вне _DefaultValue_.
  - Возвращает строку, в которой заданы текущие дата и время в формате UTC 8601 DateTime `yyyy-MM-ddTHH:mm:ss.fffffffZ` .

Следующие функции доступны только в правилах политик.

- `addDays(dateTime, numberOfDaysToAdd)`
  - **DateTime**: [Required] строка строки в формате ISO 8601 DateTime ' гггг-mm-ddTHH: mm: SS. ФФФФФФФЗ "
  - **numberOfDaysToAdd**: [обязательная] целое число — число дней для добавления.
- `field(fieldName)`
  - **fieldName**: [обязательная] строка — имя [поля](#fields), которое следует извлечь.
  - Возвращает значение этого поля из ресурса, оцениваемого условием if.
  - `field` предназначена главным образом для использования с **AuditIfNotExists** и **DeployIfNotExists**, чтобы ссылаться на поля в ресурсе, который оценивается. Это можно увидеть на [примере DeployIfNotExists](effects.md#deployifnotexists-example).
- `requestContext().apiVersion`
  - Возвращает версию API запроса, который активировал оценку политики (пример: `2019-09-01`).
    Это значение представляет собой версию API, которая использовалась в запросе на выстановку или исправление для оценок при создании или обновлении ресурсов. Последняя версия API всегда используется во время оценки соответствия для существующих ресурсов.
- `policy()`
  - Возвращает следующие сведения о политике, для которой выполняется оценка. Доступ к свойствам можно получить из возвращенного объекта (пример: `[policy().assignmentId]` ).
  
  ```json
  {
    "assignmentId": "/subscriptions/ad404ddd-36a5-4ea8-b3e3-681e77487a63/providers/Microsoft.Authorization/policyAssignments/myAssignment",
    "definitionId": "/providers/Microsoft.Authorization/policyDefinitions/34c877ad-507e-4c82-993e-3452a6e0ad3c",
    "setDefinitionId": "/providers/Microsoft.Authorization/policySetDefinitions/42a694ed-f65e-42b2-aa9e-8052e9740a92",
    "definitionReferenceId": "StorageAccountNetworkACLs"
  }
  ```


- `ipRangeContains(range, targetRange)`
    - **Range**: [обязательное значение] строка строки, указывающая диапазон IP-адресов.
    - **таржетранже**: [обязательный] строка строки, указывающая диапазон IP-адресов.

    Возвращает значение, указывающее, содержит ли указанный диапазон IP-адресов целевой диапазон IP-адресов. Пустые диапазоны или смешивание между семействами IP-адресов не разрешено и приводит к сбою оценки.

    Поддерживаемые форматы:
    - Один IP-адрес (примеры: `10.0.0.0` , `2001:0DB8::3:FFFE` )
    - Диапазон CIDR (примеры: `10.0.0.0/24` , `2001:0DB8::/110` )
    - Диапазон, определенный начальным и конечным IP-адресами (примеры: `192.168.0.1-192.168.0.9` , `2001:0DB8::-2001:0DB8::3:FFFF` )


#### <a name="policy-function-example"></a>Пример функции политики

В этом примере правила политики функция ресурса `resourceGroup` используется для получения свойства **name** в сочетании с массивом `concat` и функцией объекта для создания условия `like`, требующего, чтобы имя ресурса начиналось с имени группы ресурсов.

```json
{
    "if": {
        "not": {
            "field": "name",
            "like": "[concat(resourceGroup().name,'*')]"
        }
    },
    "then": {
        "effect": "deny"
    }
}
```

## <a name="aliases"></a>Aliases

Псевдонимы свойств позволяют обращаться к определенным свойствам для типа ресурса. Псевдонимы позволяют ограничить значения или условия, разрешенные для свойства ресурса. Каждый псевдоним сопоставляется с путями в разных версиях API для заданного типа ресурса. Во время оценки политики модуль политики получает путь свойства для этой версии API.

Список псевдонимов постоянно пополняется. Чтобы узнать, какие псевдонимы в настоящее время поддерживаются службой "Политика Azure", используйте один из следующих методов:

- Расширение Политики Azure для Visual Studio Code (рекомендуется)

  Используйте [расширение Политики Azure для Visual Studio Code](../how-to/extension-for-vscode.md), чтобы просматривать и находить псевдонимы для свойств ресурсов.

  :::image type="content" source="../media/extension-for-vscode/extension-hover-shows-property-alias.png" alt-text="Снимок экрана расширения политики Azure для Visual Studio Code наведения указателя мыши на свойство для отображения имен псевдонимов." border="false":::

- Azure Resource Graph

  Используйте оператор `project` для вывода **псевдонима** ресурса.

  ```kusto
  Resources
  | where type=~'microsoft.storage/storageaccounts'
  | limit 1
  | project aliases
  ```
  
  ```azurecli-interactive
  az graph query -q "Resources | where type=~'microsoft.storage/storageaccounts' | limit 1 | project aliases"
  ```
  
  ```azurepowershell-interactive
  Search-AzGraph -Query "Resources | where type=~'microsoft.storage/storageaccounts' | limit 1 | project aliases"
  ```

- Azure PowerShell

  ```azurepowershell-interactive
  # Login first with Connect-AzAccount if not using Cloud Shell

  # Use Get-AzPolicyAlias to list available providers
  Get-AzPolicyAlias -ListAvailable

  # Use Get-AzPolicyAlias to list aliases for a Namespace (such as Azure Compute -- Microsoft.Compute)
  (Get-AzPolicyAlias -NamespaceMatch 'compute').Aliases
  ```

  > [!NOTE]
  > Чтобы найти псевдонимы, которые можно использовать с действием [изменения](./effects.md#modify) , используйте следующую команду в Azure PowerShell **4.6.0** или более поздней версии:
  >
  > ```azurepowershell-interactive
  > Get-AzPolicyAlias | Select-Object -ExpandProperty 'Aliases' | Where-Object { $_.DefaultMetadata.Attributes -eq 'Modifiable' }
  > ```

- Azure CLI

  ```azurecli-interactive
  # Login first with az login if not using Cloud Shell

  # List namespaces
  az provider list --query [*].namespace

  # Get Azure Policy aliases for a specific Namespace (such as Azure Compute -- Microsoft.Compute)
  az provider show --namespace Microsoft.Compute --expand "resourceTypes/aliases" --query "resourceTypes[].aliases[].name"
  ```

- REST API или ARMClient

  ```http
  GET https://management.azure.com/providers/?api-version=2019-10-01&$expand=resourceTypes/aliases
  ```

### <a name="understanding-the--alias"></a>Общие сведения о псевдониме [*]

Некоторые доступные псевдонимы имеют версию с отображаемым «обычным» именем, а другие — с присоединенным **\[\*\]** . Пример:

- `Microsoft.Storage/storageAccounts/networkAcls.ipRules`
- `Microsoft.Storage/storageAccounts/networkAcls.ipRules[*]`

«Обычный» псевдоним представляет поле как одно значение. Это поле предназначено для сценариев сравнения точного соответствия, если весь набор значений должен в точности соответствовать определению, не больше и не меньше.

Псевдоним **\[\*\]** позволяет сравнить значения каждого элемента в массиве с конкретными свойствами каждого элемента. Такой подход позволяет сравнивать свойства элементов для сценариев «если ни один из», «если любой из» или «если все из». Для более сложных сценариев используйте выражение условия [count](#count). При использовании **ipRules\[\*\]** пример будет проверять, является ли каждое из _действий_ _Deny_, но не будет беспокоиться о том, сколько правил существует или каково _значение_ IP.
Этот пример правила проверяет соответствие **ipRules\[\*\].value** **10.0.4.1** и применяет **effectType** только в том случае, если не найдено ни одного совпадения.

```json
"policyRule": {
    "if": {
        "allOf": [
            {
                "field": "Microsoft.Storage/storageAccounts/networkAcls.ipRules",
                "exists": "true"
            },
            {
                "field": "Microsoft.Storage/storageAccounts/networkAcls.ipRules[*].value",
                "notEquals": "10.0.4.1"
            }
        ]
    },
    "then": {
        "effect": "[parameters('effectType')]"
    }
}
```

Более подробную информацию см. в разделе [оценка псевдонима [\*]](../how-to/author-policies-for-arrays.md#evaluating-the--alias).

## <a name="next-steps"></a>Дальнейшие действия

- См. [структуру определения инициативы](./initiative-definition-structure.md)
- См. другие [примеры шаблонов для службы Политика Azure](../samples/index.md).
- Изучите [сведения о действии политик](effects.md).
- Узнайте о [программном создании политик](../how-to/programmatically-create.md).
- Узнайте, как [получать сведения о соответствии](../how-to/get-compliance-data.md).
- Узнайте, как [исправлять несоответствующие ресурсы](../how-to/remediate-resources.md).
- Дополнительные сведения о группе управления см. в статье [Упорядочивание ресурсов с помощью групп управления Azure](../../management-groups/overview.md).
