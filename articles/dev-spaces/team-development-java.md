---
title: Коллективная разработка с помощью Java Core и Visual Studio Code
services: azure-dev-spaces
author: stepro
ms.author: stephpr
ms.date: 08/01/2018
ms.topic: tutorial
description: Быстрая разработка в Kubernetes с использованием контейнеров и микрослужб в Azure
keywords: 'Docker, Kubernetes, Azure, AKS, Azure Kubernetes Service, containers, Helm, service mesh, service mesh routing, kubectl, k8s '
manager: gwallace
ms.openlocfilehash: 400aec21d028011523fc5b441ed8ba77a1a46074
ms.sourcegitcommit: b77e97709663c0c9f84d95c1f0578fcfcb3b2a6c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74325522"
---
# <a name="team-development-using-java-and-visual-studio-code-with-azure-dev-spaces"></a>Коллективная разработка с помощью Azure Dev Spaces в Java и Visual Studio Code

Из этого руководства вы узнаете, как команда разработчиков может одновременно работать в одном кластере Kubernetes с помощью сред Dev Spaces.

## <a name="learn-about-team-development"></a>Сведения о коллективной разработке
До сих пор вы выполняли код приложения, как если бы вы были единственным разработчиком, работающим над этим приложением. В этом разделе вы узнаете, как Azure Dev Spaces упрощает разработку в команде:
* По мере необходимости для работы в одной среде можно объединить команды разработчиков, которые работают в общем пространстве разработки или в различных пространствах.
* Поддерживает изолированную итерацию кода каждым разработчиком без воздействия на работу команды.
* Позволяет выполнять комплексное тестирование кода перед его фиксацией без необходимости создавать макеты или моделировать зависимости.

### <a name="challenges-with-developing-microservices"></a>Сложности при разработке микрослужб
На данный момент пример вашего приложения не очень сложный. Но в реальном мире проблемы появятся по мере увеличения количества служб и участников команды разработки. Выполнение всей разработки в локальной среде может показаться нереальным.

* На компьютере разработки может не хватить ресурсов для запуска всех необходимых служб одновременно.
* Некоторые службы могут быть общедоступными. Например, службе может потребоваться конечная точка, которая отвечает на веб-перехватчик.
* Если вы хотите запустить подмножество служб, необходимо знать полную иерархию зависимостей между всеми службами. Определить это может быть сложно, особенно по мере увеличения количества служб.
* Некоторые разработчики прибегают к моделированию или макетированию многих зависимостей служб. Этот подход может помочь, но управление этими макетами может вскоре повлиять на стоимость разработки. Кроме того, этот подход приводит к значительным отличиям вашей среды от рабочей, что может приводить к появлению незначительных ошибок.
* По этой причине выполнение любого типа интеграционного тестирования становится затруднительным. Фактически интеграционное тестирование можно выполнить только после фиксации, что означает, что вы обнаружите проблемы позже в цикле разработки.

    ![](media/common/microservices-challenges.png)

### <a name="work-in-a-shared-dev-space"></a>Работа в общей среде разработки
С помощью Azure Dev Spaces можно настроить *общую среду разработки* в Azure. Каждый разработчик может сосредоточиться только на своей части приложения и может итеративно разрабатывать *код до фиксации* в среде разработки, в которой уже содержатся все другие службы и облачные ресурсы, от которых зависят сценарии. Зависимости всегда актуальны, и разработчикам следует работать также, как в рабочей среде.

### <a name="work-in-your-own-space"></a>Работа в собственном пространстве
При разработке кода для службы и перед его фиксацией он будет содержать большое количество ошибок. Вы будете итеративно корректировать, тестировать его и экспериментировать с решениями. Azure Dev Spaces предоставляет концепцию **пространства**, которое позволяет работать изолированно, не мешая работе участников вашей команды.

## <a name="use-dev-spaces-for-team-development"></a>Использование среды Dev Spaces для групп разработчиков
Продемонстрируем эти идеи на конкретном примере с помощью нашего примера приложения *webfrontend* -> *mywebapi*. Представим сценарий, в котором разработчику Василию нужно внести изменения *только* в службу *mywebapi*. *webfrontend* не нужно изменять в рамках этого обновления.

_Без_ использования сред Dev Spaces у Василия было бы несколько способов разработки и тестирования его обновления, ни один из которых не идеален.
* Запуск всех компонентов локально. Для этого требуется более мощный компьютер разработки с установленным Docker и, возможно, MiniKube.
* Запустить все компоненты в изолированном пространстве имен в кластере Kubernetes. Так как *webfrontend* не изменяется, это пустая трата ресурсов кластера.
* Запустить только *mywebapi* и вызвать REST вручную для тестирования. Это не дает возможность проверки полного сквозного потока.
* Добавить код, ориентированный на разработку, в *webfrontend*, что позволит разработчику отправлять запросы в другой экземпляр *mywebapi*. Это усложняет службу *webfrontend*.

### <a name="set-up-your-baseline"></a>Настройка базового плана
Сначала нужно развернуть базовый план служб. Это развертывание будет представлять собой "последнее работоспособное", поэтому можно легко сравнить поведение локального кода с проверяемой версией. Затем создадим дочернее пространство на основе этого базового плана, чтобы протестировать изменения в *mywebapi* в контексте большего приложения.

1. Клонируйте [пример приложения Dev Spaces](https://github.com/Azure/dev-spaces): `git clone https://github.com/Azure/dev-spaces && cd dev-spaces`
1. Проверьте удаленную ветвь *azds_updates*: `git checkout -b azds_updates origin/azds_updates`
1. Выберите среду _dev_: `azds space select --name dev`. При появлении запроса на выбор родительской среды выберите _\<none\>_ .
1. Перейдите в каталог _mywebapi_ и выполните `azds up -d`
1. Перейдите в каталог _webfrontend_ и выполните `azds up -d`
1. Выполните `azds list-uris`, чтобы увидеть общедоступную конечную точку для _webfrontend_

> [!TIP]
> Описанные выше шаги позволяют вручную настроить базовый план, но мы рекомендуем командам использовать CI/CD для автоматического обновления базового плана с помощью зафиксированного кода.
>
> Ознакомьтесь с руководством [по настройке CI/CD в Azure DevOps](how-to/setup-cicd.md), чтобы создать рабочий процесс, как на следующей схеме.
>
> ![Пример диаграммы CI/CD](media/common/ci-cd-complex.png)

На этом этапе базовый план должен быть запущен. Выполните команду `azds list-up --all`, и вы увидите результат, аналогичный приведенному ниже:

```
$ azds list-up --all

Name                          DevSpace  Type     Updated  Status
----------------------------  --------  -------  -------  -------
mywebapi                      dev       Service  3m ago   Running
mywebapi-56c8f45d9-zs4mw      dev       Pod      3m ago   Running
webfrontend                   dev       Service  1m ago   Running
webfrontend-6b6ddbb98f-fgvnc  dev       Pod      1m ago   Running
```

Столбец DevSpace показывает, что обе службы работают в пространстве _dev_. Любой, кто открывает общедоступный URL-адрес и переходит к веб-приложению, будет вызывать вызванный путь кода, который проходит через обе службы. Предположим, теперь вы хотите продолжить разработку _mywebapi_. Как вносить изменения в код и проверять их, не мешая другим разработчикам, использующим среду разработки? Чтобы сделать это, настройте собственное пространство.

### <a name="create-a-dev-space"></a>Создание пространства разработки
Чтобы работать с собственной версией _mywebapi_ в пространстве, отличном от _dev_, можно создать собственное пространство, используя следующую команду:

```cmd
azds space select --name scott
```

При появлении запроса выберите _dev_ в качестве **родительского пространства разработки**. Это означает, что новое пространство _dev/scott_ будет производным от пространства _dev_. Скоро вы узнаете, как это может помочь при тестировании.

В соответствии с нашей вводной гипотезой мы использовали имя _scott_ для нового пространства, чтобы коллеги могли определить, кто работает в нем. Его можно назвать как угодно, независимо от значения названия, например _sprint4_ или _demo_. В любом случае _dev_ служит основой для всех разработчиков, работающих над частью этого приложения.

![](media/common/ci-cd-space-setup.png)

Выполните команду `azds space list`, чтобы просмотреть список всех пространств в среде разработки. Столбец _Выбрано_ указывает, какое пространство в данный момент выбрано (true/false). В вашем случае пространство с именем _dev/scott_ было автоматически выбрано при создании. Вы можете выбрать другое пространство в любое время с помощью команды `azds space select`.

Давайте посмотрим на это в действии.

### <a name="make-a-code-change"></a>Измените код
В окне VS Code перейдите к `mywebapi` и в `src/main/java/com/ms/sample/mywebapi/Application.java` измените код на метод `String index()`, например так:

```java
@RequestMapping(value = "/", produces = "text/plain")
public String index() {
    return "Hello from mywebapi says something new";
}
```

### <a name="run-the-service"></a>Запуск службы

Чтобы запустить службу, нажмите клавишу F5 (или введите `azds up` в окне терминала). Служба автоматически запустится в выбранной среде _dev/scott_. Убедитесь, что служба запущена в своей среде, выполнив команду `azds list-up`.

```cmd
$ azds list-up

Name                      DevSpace  Type     Updated  Status
mywebapi                  scott     Service  3m ago   Running
webfrontend               dev       Service  26m ago  Running
```

Обратите внимание, что экземпляр *mywebapi* теперь выполняется в среде _dev/scott_. Версия, запущенная в среде _dev_, по-прежнему выполняется, но не отображается.

Чтобы получить список URL-адресов текущей среды, выполните команду `azds list-uris`.

```cmd
$ azds list-uris

Uri                                                                        Status
-------------------------------------------------------------------------  ---------
http://localhost:53831 => mywebapi.scott:80                                Tunneled
http://scott.s.dev.webfrontend.6364744826e042319629.ce.azds.io/  Available
```

Обратите внимание, что URL-адрес точки общего доступа службы *webfrontend* имеет префикс *scott.s*. Этот URL-адрес является уникальным для среды _dev/scott_. Этот префикс URL-адреса указывает контроллеру входящего трафика направлять запросы к службам в среде _dev/scott_. При обработке запроса с URL-адреса службой Dev Spaces контроллер входящего трафика сначала пытается направить запрос в службу *webfrontend* в среде _dev/scott_. При сбое запрос будет перенаправлен в службу *webfrontend* в среде _dev_ в качестве резерва. Кроме того, обратите внимание, что существует локальный URL-адрес для доступа к службе через локальный узел (localhost) с использованием функции *перенаправления портов* Kubernetes. Дополнительные сведения о URL-адресах и маршрутизации в Azure Dev Spaces см. в [этой статье](how-dev-spaces-works.md).

![Маршрутизация в среде](media/common/Space-Routing.png)

Эта встроенная возможность Azure Dev Spaces позволяет выполнять тестирование кода в общей среде, не требуя от каждого разработчика повторно создавать множество служб в своем пространстве. Для такой маршрутизации требуется, чтобы код приложения отправлял заголовки распространения, как показано на предыдущем шаге этого руководства.

### <a name="test-code-in-a-space"></a>Проверка кода в среде
Чтобы проверить свою новую версию *mywebapi* в сочетании с *webfrontend*, откройте в браузере URL-адрес общедоступной точки доступа для *webfrontend* и перейдите на страницу About (Сведения). Отобразится новое сообщение.

Теперь удалите часть "scott.s" из URL-адреса и обновите браузер. Снова будет наблюдаться старое поведение (версия *mywebapi*, запущенная в _dev_).

При наличии среды _dev_, которая всегда содержит последние изменения, и при условии, что приложение настроено для использования маршрутизации на основе среды DevSpace, как описано в разделе этого руководства, станет понятнее, как Dev Spaces может быть очень полезной при тестировании новых функций в контексте более крупного приложения. Вместо того чтобы развернуть _все_ службы в частной среде, вы можете создать частную среду, которая является производной от среды _dev_ и будет включать только те службы, с которыми вы фактически работаете. Инфраструктура маршрутизации Dev Spaces будет обрабатывать все остальное за счет использования всех доступных служб частной среды и по умолчанию применять последнюю версию, выполняемую в среде _dev_. Тем не менее _несколько_ разработчиков могут одновременно активно создавать разные службы в собственной среде, не нарушая работу друг друга.

### <a name="well-done"></a>Все готово!
Вы выполнили руководство по началу работы. Вы научились выполнять следующие задачи:

> [!div class="checklist"]
> * Настройка Azure Dev Spaces с помощью управляемого кластера Kubernetes в Azure.
> * итеративная разработка кода в контейнерах;
> * независимая разработка двух отдельных служб и вызов другой службы с помощью обнаружения службы DNS Kubernetes;
> * эффективная разработка и тестирование кода в среде командной работы.
> * определение базовых функций с помощью Dev Spaces для простой проверки отдельных изменений в контексте более крупного приложения для микрослужб.

После ознакомления с Azure Dev Spaces, [предоставьте общий доступ к среде разработки члену своей команды](how-to/share-dev-spaces.md) и начните работать вместе.

## <a name="clean-up"></a>Очистка
Чтобы полностью удалить экземпляр Azure Dev Spaces из кластера, включая все среды разработки и работающие службы, используйте команду `az aks remove-dev-spaces`. Не забывайте, что это действие необратимо. Позднее вы сможете снова добавить в кластер поддержку Azure Dev Spaces, но в этом случае вам придется начать работу с нуля. Прежние службы и среды не будут восстановлены.

С помощью приведенного ниже примера кода можно вывести список контроллеров Azure Dev Spaces в активной подписке, а затем удалить контроллер Azure Dev Spaces, связанный с кластером AKS myaks в группе ресурсов myaks-rg.

```cmd
    azds controller list
    az aks remove-dev-spaces --name myaks --resource-group myaks-rg
```
