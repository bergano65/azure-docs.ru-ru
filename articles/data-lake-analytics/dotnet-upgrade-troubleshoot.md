---
title: Устранение неполадок в работе Azure Data Lake Analytics сбоев заданий U-SQL из-за обновления .NET 4.7.2
description: Устранение ошибок заданий U-SQL из-за обновления до .NET 4.7.2.
services: data-lake-analytics
author: guyhay
ms.author: guyhay
ms.reviewer: jasonwhowell
ms.service: data-lake-analytics
ms.topic: troubleshooting
ms.workload: big-data
ms.date: 10/11/2019
ms.openlocfilehash: 2be2f50558fef41659c9a3313871b17961f6ad6d
ms.sourcegitcommit: 9405aad7e39efbd8fef6d0a3c8988c6bf8de94eb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74873239"
---
# <a name="azure-data-lake-analytics-is-upgrading-to-the-net-framework-v472"></a>Azure Data Lake Analytics выполняется обновление до .NET Framework v 4.7.2

Среда выполнения по умолчанию Azure Data Lake Analytics обновляется с .NET Framework v 4.5.2 до .NET Framework v 4.7.2. Это изменение создает небольшой риск критических изменений, если в коде U-SQL используются пользовательские сборки, и эти пользовательские сборки используют библиотеки .NET.

Это обновление с .NET Framework 4.5.2 до версии 4.7.2 означает, что .NET Framework, развернутые в среде выполнения U-SQL (среда выполнения по умолчанию), теперь всегда будет 4.7.2. Для .NET Framework версий не существует параллельного варианта.

После завершения этого обновления до .NET 4.7.2 управляемый код системы будет работать как версия 4.7.2. пользовательские библиотеки, такие как настраиваемые сборки U-SQL, будут работать в режиме обратной совместимости, подходящем для версии, которая была создана сборкой. предмет.

- Если библиотеки DLL сборки созданы для версии 4.5.2, развернутая платформа будет рассматривать их как библиотеки 4.5.2, предоставляя (с некоторыми исключениями) семантику 4.5.2.
- Теперь вы можете использовать пользовательские сборки U-SQL, которые используют функции версии 4.7.2, если вы нацелены на .NET Framework 4.7.2.

В связи с этим обновлением до .NET 4.7.2 существует возможность внести критические изменения в задания U-SQL, использующие пользовательские сборки .NET. Мы рекомендуем проверить наличие проблем обратной совместимости, используя приведенную ниже процедуру.

## <a name="how-to-check-for-backwards-compatibility-issues"></a>Проверка на наличие проблем обратной совместимости

Проверьте потенциальные проблемы, связанные с обратной совместимостью, выполнив проверки совместимости .NET для кода .NET в пользовательских сборках U-SQL.

> [!Note]
> Средство не обнаруживает фактические критические изменения. Он только определяет вызванные API-интерфейсы .NET, которые могут вызывать проблемы (для определенных входных данных). Если вы получите оповещение о возникшей ошибке, код может быть по-прежнему подойдет, но вы должны просмотреть дополнительные сведения.

1. Запустите средство проверки обратной совместимости для DLL-библиотек .NET с помощью
   1. Использование расширения Visual Studio в [расширении Visual Studio для анализатора переносимости .NET](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)
   1. Загрузка и использование автономного средства из [GitHub дотнетапипорт](https://github.com/microsoft/dotnet-apiport). Инструкции по запуску автономного средства находятся на сайте [GitHub дотнетапипорт критические изменения](https://github.com/microsoft/dotnet-apiport/blob/dev/docs/HowTo/BreakingChanges.md)
   1. Для 4.7.2. совместимость, `read isRetargeting == True` выявляет возможные проблемы.
2. Если средство указывает, может ли код влиять на возможную обратную несовместимость (некоторые распространенные примеры несовместимости перечислены ниже), можно дополнительно проверить
   1. Анализ кода и определение, передает ли ваш код значения затронутым API
   1. Выполните проверку времени выполнения. Развертывание среды выполнения не выполняется параллельно в ADLA. Перед обновлением можно выполнить проверку среды выполнения, используя локальный запуск VisualStudio с локальной .NET Framework 4.7.2 с репрезентативным набором данных.
3. Если вы действительно оказываете влияние на обратную несовместимость, выполните необходимые действия для ее исправления (например, для исправления логики данных или кода).

В большинстве случаев не следует повлиять на обратную несовместимость.

## <a name="timeline"></a>Временная шкала

Вы можете проверить развертывание новой среды выполнения в статье [Устранение неполадок среды выполнения](runtime-troubleshoot.md), а также просмотреть все предыдущие выполненные задания.

### <a name="what-if-i-cant-get-my-code-reviewed-in-time"></a>Что делать, если я не могу просмотреть код вовремя

Вы можете отправить задание относительно старой версии среды выполнения (созданной для 4.5.2), однако из-за отсутствия .NET Framework параллельных возможностей она все равно будет работать только в режиме совместимости 4.5.2. По-прежнему могут возникать некоторые проблемы обратной совместимости из-за такого поведения.

### <a name="what-are-the-most-common-backwards-compatibility-issues-you-may-encounter"></a>Каковы наиболее распространенные проблемы обратной совместимости, которые могут возникнуть

Наиболее распространенная обратная совместимость, которая, вероятно, будет выявлена средством проверки (мы создали этот список, запустив средство проверки на основе собственных внутренних заданий ADLA), на которые повлияли библиотеки (Обратите внимание, что библиотеки можно вызывать только косвенно, поэтому важно, чтобы предпринять необходимые действия #1, чтобы проверить, влияют ли ваши задания), и возможные действия для их устранения. Примечание. почти во всех случаях для собственных заданий предупреждения выдавали ложные срабатывания из-за узких особенностей наиболее критических изменений.

- Чтобы результирующая задача завершилась, реализация свойства IAsyncResult.CompletedSynchronously должна быть правильной
  - При вызове TaskFactory.FromAsync реализация свойства IAsyncResult.CompletedSynchronously должна быть правильной, чтобы результирующая задача завершилась. То есть свойство должно возвращать значение true, если (и только если) реализация завершилась синхронно. Раньше свойство не проверялось.
  - Затронутые библиотеки: mscorlib, System. Threading. Tasks
  - Предлагаемое действие: Убедитесь, что TaskFactory. FromAsync правильно возвращает значение true

- DataObject.GetData теперь получает данные в кодировке UTF-8
  - Для приложений, предназначенных для NET Framework 4, а также для выполняющихся в .NET Framework 4.5.1 или более ранних версиях, DataObject.GetData получает HTML-данные в виде строки ASCII. В результате символы, не входящие в набор ASCII (символы, коды ASCII которых больше 0x7F), представляются двумя случайными символами. #N # #N # для приложений, предназначенных для .NET Framework 4,5 или более поздней версии и выполняемых в .NET Framework 4.5.2, `DataObject.GetData` извлекает данные в формате HTML в кодировке UTF-8, которая представляет символы, превышающие 0x7F.
  - Затронутые библиотеки: гло
  - Предлагаемое действие. Убедитесь, что извлекаемые данные имеют нужный формат.

- XmlWriter вызывает недействительные суррогатные пары
  - Для приложений с целевой платформой .NET Framework 4.5.2 или предыдущих версий запись недействительной суррогатной пары с помощью обработки резервного исключения не всегда вызывает исключение. Для приложений с целевой платформой .NET Framework 4.6 попытка записи недействительной суррогатной пары вызывает исключение `ArgumentException`.
  - Затронутые библиотеки: System. XML, System. XML. блокировки
  - Предлагаемое действие: Убедитесь, что вы не пишете недопустимую суррогатную пару, которая приведет к исключению аргумента

- HtmlTextWriter неправильно отображает элемент `<br/>`
  - Начиная с .NET Framework 4.6, при вызове `HtmlTextWriter.RenderBeginTag()` и `HtmlTextWriter.RenderEndTag()` с элементом `<BR />` правильно вставляется только один `<BR />` (вместо двух).
  - Затронутые библиотеки: System. Web
  - Предлагаемое действие. Убедитесь, что вы вставляете предполагаемый объем `<BR />`, чтобы случайное поведение не проявлялось в рабочем задании.

- Был изменен вызов метода CreateDefaultAuthorizationContext с аргументом NULL
  - В .NET Framework 4.6 изменилась реализация AuthorizationContext, возвращаемая вызовом `CreateDefaultAuthorizationContext(IList<IAuthorizationPolicy>)` с нулевым аргументом authorizationPolicies.
  - Затронутые библиотеки: System. IdentityModel
  - Предлагаемое действие: Убедитесь, что вы обрабатываете новое ожидаемое поведение при наличии политики авторизации, имеющей значение null.
  
- RSACng теперь правильно загружает ключи RSA нестандартного размера
  - В версиях .NET Framework до 4.6.2 клиенты с нестандартным размером ключа для сертификатов RSA не могли получить доступ к этим ключам через методы расширения `GetRSAPublicKey()` и `GetRSAPrivateKey()`. Создается `CryptographicException` с сообщением "запрошенный размер ключа не поддерживается". С .NET Framework 4.6.2 Эта проблема исправлена. Аналогично, `RSA.ImportParameters()` и `RSACng.ImportParameters()` теперь работают с нестандартными размерами ключей, не вызывая `CryptographicException`.
  - Затронутые библиотеки: mscorlib, System. Core
  - Предлагаемое действие: Убедитесь, что ключи RSA работают должным образом.

- Более строгие проверки двоеточий в пути
  - В .NET Framework 4.6.2 выполнен ряд изменений для поддержки ранее не поддерживаемых путей (по длине и формату). Исправлены проверки надлежащего синтаксиса разделителя диска (двоеточие), в результате появился побочный эффект в виде блокировки некоторых путей универсального кода ресурса (URI) в некоторых API-интерфейсах пути, где раньше это допускалось.
  - Затронутые библиотеки: mscorlib, System. Runtime. Extensions
  - Предлагаемое действие:

- Вызовы к конструкторам ClaimsIdentity
  - Начиная с .NET Framework 4.6.2 конструкторы `T:System.Security.Claims.ClaimsIdentity` с параметром `T:System.Security.Principal.IIdentity` иначе задают свойство `P:System.Security.Claims.ClaimsIdentify.Actor`. Если аргумент `T:System.Security.Principal.IIdentity` является объектом `T:System.Security.Claims.ClaimsIdentity`, а свойство `P:System.Security.Claims.ClaimsIdentify.Actor` этого объекта `T:System.Security.Claims.ClaimsIdentity` не равно `null`, свойство `P:System.Security.Claims.ClaimsIdentify.Actor` присоединяется с помощью метода `M:System.Security.Claims.ClaimsIdentity.Clone`. В 4.6.1 Framework и более ранних версиях свойство `P:System.Security.Claims.ClaimsIdentify.Actor` присоединяется как существующая ссылка. Из-за этого изменения, начиная с .NET Framework 4.6.2, свойство `P:System.Security.Claims.ClaimsIdentify.Actor` нового объекта `T:System.Security.Claims.ClaimsIdentity` не равно свойству `P:System.Security.Claims.ClaimsIdentify.Actor` аргумента `T:System.Security.Principal.IIdentity` конструктора. В .NET Framework 4.6.1 и более ранних версиях они равны.
  - Затронутые библиотеки: mscorlib
  - Предлагаемое действие: Убедитесь, что ClaimsIdentity работает должным образом в новой среде выполнения

- Сериализация управляющих символов с помощью DataContractJsonSerializer теперь совместима с ECMAScript версии 6 и 8
  - В .NET Framework 4.6.2 и более ранних версиях DataContractJsonSerializer не выполнял сериализацию некоторых специальных управляющих символов, таких как \b, \f и \t, так, как это было совместимо с стандартами ECMAScript версии 6 и V8. Начиная с .NET Framework 4.7 сериализация таких управляющих символов совместима с ECMAScript версий 6 и 8.
  - Затронутые библиотеки: System. Runtime. Serialization. JSON
  - Предлагаемое действие: обеспечить то же поведение с DataContractJsonSerializer
