---
title: Обработано проблем регулирования или "429" — ошибок слишком много запросов
description: Как обойти проблемы регулирования или ошибки "HTTP 429 слишком много запросов", в Azure Logic Apps
services: logic-apps
ms.suite: integration
ms.reviewer: deli, logicappspm
ms.topic: conceptual
ms.date: 04/13/2020
ms.openlocfilehash: fbfd52065bc0522668488492de2181f252f86a4e
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "81272684"
---
# <a name="handle-throttling-problems-429---too-many-requests-errors-in-azure-logic-apps"></a>Обработку проблем регулирования (429-"слишком много запросов") в Azure Logic Apps

В [Azure Logic Apps](../logic-apps/logic-apps-overview.md)приложение логики возвращает [ошибку "HTTP 429 слишком много запросов"](https://developer.mozilla.org/docs/Web/HTTP/Status/429) при регулировании, что происходит, когда количество запросов превышает скорость, с которой назначение может справиться в течение определенного промежутка времени. Регулирование может создавать такие проблемы, как отложенная обработка данных, снижение быстродействия и ошибки, например превышение указанной политики повтора.

![Регулирование в соединителе SQL Server](./media/handle-throttling-problems-429-errors/example-429-too-many-requests-error.png)

Ниже приведены некоторые распространенные типы регулирования, которые могут возникнуть в приложении логики.

* [Приложение логики](#logic-app-throttling)
* [Соединитель](#connector-throttling)
* [Целевая служба или система](#destination-throttling)

<a name="logic-app-throttling"></a>

## <a name="logic-app-throttling"></a>Регулирование приложений логики

У службы Azure Logic Apps есть свои [ограничения пропускной способности](../logic-apps/logic-apps-limits-and-config.md#throughput-limits). Таким образом, если приложение логики превышает эти ограничения, ресурс приложения логики регулируется, а не просто с конкретным экземпляром или запуском.

Чтобы найти события регулирования на этом уровне, проверьте панель **метрик** приложения логики в портал Azure.

1. В [портал Azure](https://portal.azure.com)откройте приложение логики в конструкторе приложений логики.

1. В меню приложения логики в разделе **мониторинг**выберите **метрики**.

1. В разделе **заголовок диаграммы**выберите **Добавить метрику** , чтобы добавить еще одну метрику в существующую.

1. В первой строке метрики в списке **Метрика** выберите **регулируемые события действия**. Во второй строке метрики в списке **Метрика** выберите **триггеры регулируемых событий**.

Для управления регулированием на этом уровне доступны следующие варианты:

* Ограничьте число экземпляров приложения логики, которые могут выполняться одновременно.

  По умолчанию, если условие триггера приложения логики будет выполняться несколько раз одновременно, несколько экземпляров триггеров для приложения логики выполняются *параллельно*или одновременно. Это означает, что каждый экземпляр триггера срабатывает до завершения выполнения предыдущего экземпляра рабочего процесса.

  Хотя количество экземпляров триггеров, которые могут одновременно выполняться одновременно, не [ограничено](../logic-apps/logic-apps-limits-and-config.md#concurrency-looping-and-debatching-limits), можно ограничить это число, [включив параметр параллелизма триггера](../logic-apps/logic-apps-workflow-actions-triggers.md#change-trigger-concurrency)и при необходимости выберите ограничение, отличное от значения по умолчанию.

* Включение режима высокой пропускной способности.

  Приложение логики имеет [ограничение по умолчанию для количества действий, которое может выполняться в течение 5-минутного интервала](../logic-apps/logic-apps-limits-and-config.md#throughput-limits). Чтобы увеличить это ограничение до максимального числа действий, включите [режим высокой пропускной способности](../logic-apps/logic-apps-workflow-actions-triggers.md#run-high-throughput-mode) в приложении логики.

* Отключите режим депакетирования массива ("разделить на") в триггерах.

  Если триггер возвращает массив для обработки оставшихся действий рабочего процесса, то [параметр **Split on** ](../logic-apps/logic-apps-workflow-actions-triggers.md#split-on-debatch) этого триггера разделяет элементы массива и запускает экземпляр рабочего процесса для каждого элемента массива, фактически запуская несколько одновременных запусков до [ **разбиения на** пределы](../logic-apps/logic-apps-limits-and-config.md#concurrency-looping-and-debatching-limits). Чтобы управлять регулированием, отключите **разделение по** поведению и попросите приложение логики обработать весь массив с помощью одного вызова, а не обрабатывать один элемент на каждый вызов.

* Рефакторинг действий для небольших приложений логики.

  Как упоминалось ранее, приложение логики ограничено [количеством действий по умолчанию, которые могут выполняться в течение 5-минутного периода](../logic-apps/logic-apps-limits-and-config.md#throughput-limits). Хотя это ограничение можно увеличить, включив [режим высокой пропускной способности](../logic-apps/logic-apps-workflow-actions-triggers.md#run-high-throughput-mode), можно также подумать о том, нужно ли разбить действия приложения логики на более мелкие приложения логики, чтобы количество действий, выполняемых в каждом приложении логики, оставалось ограниченным. Таким образом вы сокращаете нагрузку на один ресурс приложения логики и распределяете нагрузку между несколькими приложениями логики. Это решение лучше подходит для действий, которые обрабатывали большие наборы данных или запускаются так, чтобы многие параллельно выполняли действия, итерации цикла или действия в каждой итерации цикла, превышающие предел выполнения действий.

  Например, это приложение логики выполняет всю работу по получению таблиц из базы данных SQL Server и получает строки из каждой таблицы. Цикл **for each** выполняет итерацию по каждой таблице, чтобы действие **получить строки** возвращало строки для каждой таблицы. В зависимости от объема данных в этих таблицах эти действия могут превысить ограничение на количество выполнений действий.

  ![Рефакторинг приложения логики "до"](./media/handle-throttling-problems-429-errors/refactor-logic-app-before-version.png)

  После рефакторинга приложение логики теперь является родительским и дочерним приложением логики. Родительский объект получает таблицы из SQL Server, а затем вызывает дочернее приложение логики для каждой таблицы, чтобы получить строки:

  ![Создание приложения логики для одного действия](./media/handle-throttling-problems-429-errors/refactor-logic-app-single-connection-1.png)

  Вот дочернее приложение логики, которое вызывается родительским приложением логики для получения строк для каждой таблицы:

  ![Создание другого приложения логики для второго действия](./media/handle-throttling-problems-429-errors/refactor-logic-app-single-connection-2.png)

<a name="connector-throttling"></a>

## <a name="connector-throttling"></a>Регулирование соединителя

Каждый соединитель имеет собственные ограничения регулирования, которые можно найти на странице технического справочника по соединителю. Например, [соединитель служебной шины Azure](https://docs.microsoft.com/connectors/servicebus/) имеет ограничение регулирования, которое разрешает до 6 000 вызовов в минуту, в то время как соединитель SQL Server имеет [ограничения регулирования в зависимости от типа операции](https://docs.microsoft.com/connectors/sql/).

Некоторые триггеры и действия, такие как HTTP, имеют [политику повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies) , которую можно настроить в зависимости от [ограничений политики повтора](../logic-apps/logic-apps-limits-and-config.md#retry-policy-limits) для реализации обработки исключений. Эта политика указывает, должна ли и как часто триггер или действие повторяет запрос в случае сбоя или истечения времени ожидания исходного запроса и приводит к ответу 408, 429 или 5xx. Таким образом, когда регулирование начинается и возвращает ошибку 429, Logic Apps соответствует политике повтора, где поддерживается.

Чтобы узнать, поддерживает ли триггер или действие политики повтора, проверьте параметры триггера или действия. Чтобы просмотреть возможные попытки триггера или действия, перейдите к журналу запусков приложения логики, выберите Запуск, который необходимо просмотреть, и разверните этот триггер или действие, чтобы просмотреть сведения о входных и выходных данных, а также обо всех повторных попытках, например:

![Просмотр журнала выполнения действия, повторных попыток, входных и выходных данных](./media/handle-throttling-problems-429-errors/example-429-too-many-requests-retries.png)

Несмотря на то, что журнал повторных попыток предоставляет сведения об ошибках, возможно, возникли трудности с различием регулирования и регулирования [места назначения](#destination-throttling)соединителей. В этом случае может потребоваться проверить сведения о ответе или выполнить некоторые вычисления интервала регулирования, чтобы обозначить источник.

Для приложений логики в глобальной многоклиентской службе Azure Logic Apps выполняется регулирование на уровне *соединения* . Например, для приложений логики, выполняемых в [среде службы интеграции (ISE)](../logic-apps/connect-virtual-network-vnet-isolated-environment-overview.md), регулирование по-прежнему происходит для подключений, не связанных с ISE, так как они выполняются в глобальной многоклиентской Logic Apps службе. Однако подключения ISE, созданные с помощью соединителей ISE, не регулируется, так как они выполняются в интегрированной среде сценариев.

Для управления регулированием на этом уровне доступны следующие варианты:

* Настройте несколько подключений для одного действия, чтобы приложение логики секционировано данные для обработки.

  Для этого варианта рассмотрите возможность распределения рабочей нагрузки путем деления запросов действия на несколько подключений к одному назначению с использованием одних и тех же учетных данных.

  Например, предположим, что приложение логики получает таблицы из SQL Server базы данных, а затем получает строки из каждой таблицы. В зависимости от числа строк, которые необходимо обработать, можно использовать несколько соединений и несколько циклов **для каждого** цикла, чтобы разделить общее число строк на более мелкие наборы для обработки. В этом сценарии используется два цикла **for each** для разделения общего количества строк в половину. Первый цикл **for each** использует выражение, которое получает первую половину. В другом цикле **для каждого** цикла используется другое выражение, которое получает вторую половину, например:<p>

    * Выражение 1. `take()` функция возвращает начало коллекции. Дополнительные сведения см. в [ **`take()`** ](workflow-definition-language-functions-reference.md#take)описании функции.

      `@take(collection-or-array-name, div(length(collection-or-array-name), 2))`

    * Выражение 2. `skip()` функция удаляет начало коллекции и возвращает все остальные элементы. Дополнительные сведения см. в [ **`skip()`** ](workflow-definition-language-functions-reference.md#skip)описании функции.

      `@skip(collection-or-array-name, div(length(collection-or-array-name), 2))`

    Ниже приведен визуальный пример, демонстрирующий использование следующих выражений:

    ![Создание и использование нескольких подключений для одного действия](./media/handle-throttling-problems-429-errors/create-multiple-connections-per-action.png)

* Настройте другое подключение для каждого действия.

  Для этого параметра рассмотрите возможность распределения рабочей нагрузки путем распределения запросов каждого действия по собственному соединению, даже если действия подключаются к одной службе или системе и используют одни и те же учетные данные.

  Например, предположим, что приложение логики получает таблицы из базы данных SQL Server и получает каждую строку в каждой таблице. Можно использовать отдельные соединения, чтобы при получении таблиц использовалось одно соединение, тогда как при получении каждой строки используется другое соединение.

  ![Создание и использование различных подключений для каждого действия](./media/handle-throttling-problems-429-errors/create-connection-per-action.png)

* Измените параллелизм или параллелизм в [цикле for each](../logic-apps/logic-apps-control-flow-loops.md#foreach-loop).

  По умолчанию итерации цикла for each выполняются одновременно с [ограничением параллелизма](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Если у вас есть соединитель, который регулируется внутри цикла "For Each", можно уменьшить число итераций цикла, выполняемых параллельно. Дополнительные сведения см. в следующих статьях:
  
  * [Циклы for each — изменение параллелизма или выполнение последовательно](../logic-apps/logic-apps-control-flow-loops.md#sequential-foreach-loop)

  * [Схема языка определения рабочих процессов — для каждого цикла](../logic-apps/logic-apps-workflow-actions-triggers.md#foreach-action)

  * [Схема языка определения рабочих процессов — изменение "для каждого" параллелизма цикла](../logic-apps/logic-apps-workflow-actions-triggers.md#change-for-each-concurrency)

  * [Схема языка определения рабочих процессов — последовательно выполните циклы for each](../logic-apps/logic-apps-workflow-actions-triggers.md#sequential-for-each)

<a name="destination-throttling"></a>

## <a name="destination-service-or-system-throttling"></a>Целевая служба или регулирование системы

Хотя соединитель имеет собственные ограничения регулирования, Целевая служба или система, вызванная соединителем, может также иметь ограничения регулирования. Например, некоторые API в Microsoft Exchange Server имеют более широкие ограничения регулирования, чем соединитель Office 365 Outlook.

По умолчанию экземпляры приложения логики и любые циклы или ветви внутри этих экземпляров выполняются *параллельно*. Такое поведение означает, что несколько экземпляров могут одновременно вызывать одну и ту же конечную точку. Каждый экземпляр не знает о существовании другого, поэтому попытки повторить неудачные действия могут создавать состояния [гонки](https://en.wikipedia.org/wiki/Race_condition) , при которых несколько вызовов пытаются запуститься в то же время, но для их выполнения эти вызовы должны поступать в целевую службу или систему до начала регулирования.

Например, предположим, что имеется массив, содержащий 100 элементов. Цикл For Each используется для прохода по массиву и включения управления параллелизмом цикла, чтобы можно было ограничить число параллельных итераций до 20 или [текущим ограничением по умолчанию](../logic-apps/logic-apps-limits-and-config.md#concurrency-looping-and-debatching-limits). Внутри этого цикла действие вставляет элемент из массива в SQL Server базу данных, которая разрешает только 15 вызовов в секунду. В этом сценарии возникает проблема регулирования, так как невыполненная работа попытается выполнить сборку и никогда не будет запускаться.

В этой таблице описана временная шкала для того, что происходит в цикле, когда интервал повтора действия равен 1 секунде:

| На момент времени | Число выполняемых действий | Число неудачных действий | Число ожидающих повторных попыток |
|---------------|----------------------------|-----------------------------|---------------------------|
| T + 0 секунд | 20 вставок | 5 ошибка, из-за ограничения SQL | 5 повторных попыток |
| T + 0,5 секунд | 15 вставок, из-за предыдущих 5 попыток в ожидании | Все 15 сбоев из-за предыдущего ограничения SQL по-прежнему действует еще на 0,5 секунд | 20 повторных попыток <br>(предыдущие 5 + 15 новых) |
| T + 1 секунда | 20 вставок | 5 сбой плюс предыдущие 20 повторных попыток из-за ограничения SQL | 25 повторных попыток (предыдущие 20 + 5 новых)
|||||

Для управления регулированием на этом уровне доступны следующие варианты:

* Создайте приложения логики, чтобы каждый из них обрабатывал одну операцию.

  * Далее в примере SQL Server сценария в этом разделе можно создать приложение логики, которое помещает элементы массива в очередь, например [очередь служебной шины Azure](../connectors/connectors-create-api-servicebus.md). Затем вы создадите другое приложение логики, которое выполняет только операцию вставки для каждого элемента в этой очереди. Таким образом, только один экземпляр приложения логики выполняется в любое конкретное время, что либо завершает операцию вставки и переходит к следующему элементу в очереди, либо экземпляр получает ошибки 429, но не пытается выполнить непроизводственные повторы.

  * Создайте родительское приложение логики, которое вызывает дочернее или вложенное приложение логики для каждого действия. Если родительскому элементу необходимо вызывать различные дочерние приложения на основе результата родителя, можно использовать действие условия или действие переключения, определяющее, какое дочернее приложение следует вызывать. Этот шаблон может помочь сократить количество вызовов или операций.

    Например, предположим, что у вас есть два приложения логики с триггером опроса, который проверяет учетную запись электронной почты каждую минуту для конкретной темы, например "успешно" или "сбой". Эта установка приводит к 120 вызовов в час. Вместо этого, если создается одно родительское приложение логики, которое опрашивает каждую минуту, но вызывает дочернее приложение логики, которое выполняется в зависимости от того, является ли субъект "успешным" или "failure", в этом случае число проверок опроса вырезается на половину или в 60.

* Настройте пакетную обработку.

  Если целевая служба поддерживает пакетные операции, регулирование можно устранить путем обработки элементов в группах или пакетах, а не по отдельности. Чтобы реализовать решение пакетной обработки, необходимо создать приложение логики "получатель пакета" и приложение логики "отправитель пакета". Пакет отправителя собирает сообщения или элементы до тех пор, пока не будут выполнены указанные условия, а затем отправляет эти сообщения или элементы в одну группу. Получатель пакета принимает эту группу и обрабатывает эти сообщения или элементы. Дополнительные сведения см. [в разделе Пакетная обработка сообщений в группах](../logic-apps/logic-apps-batch-process-send-receive-messages.md).

* Используйте версии веб-перехватчика для триггеров и действий, а не для опросных версий.

  Почему? Триггер опроса продолжит проверять целевую службу или систему с определенными интервалами. Очень часто интервал, например каждую секунду, может создавать проблемы регулирования. Однако триггер или действие веб-перехватчика, например [http](../connectors/connectors-native-webhook.md), создает только один вызов целевой службы или системы, который происходит во время подписки и запрашивает, что назначение уведомляет триггер или действие только при наступлении события. Таким образом, триггер или действие не должны постоянно проверять назначение.
  
  Таким образом, если целевая служба или система поддерживает веб-перехватчики или предоставляет соединитель с версией веб-перехватчика, этот вариант лучше, чем использование версии опроса. Чтобы определить триггеры и действия веб-перехватчика, убедитесь, `ApiConnectionWebhook` что они имеют тип или не нуждаются в указании периодичности. Дополнительные сведения см. в статье [триггер APIConnectionWebhook](../logic-apps/logic-apps-workflow-actions-triggers.md#apiconnectionwebhook-trigger) и [действие APIConnectionWebhook](../logic-apps/logic-apps-workflow-actions-triggers.md#apiconnectionwebhook-action).

## <a name="next-steps"></a>Дальнейшие шаги

* Дополнительные сведения об [ограничениях Logic Apps и конфигурации](../logic-apps/logic-apps-limits-and-config.md)
