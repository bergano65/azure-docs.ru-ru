---
title: Запросы данных о производительности на стороне сервера
description: Как выполнять запросы данных о производительности на стороне сервера с помощью вызовов API
author: florianborn71
ms.author: flborn
ms.date: 02/10/2020
ms.topic: article
ms.custom: devx-track-csharp
ms.openlocfilehash: 95993b35174b80dae8c878c22554ee60afeb8a14
ms.sourcegitcommit: 957c916118f87ea3d67a60e1d72a30f48bad0db6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2020
ms.locfileid: "92206226"
---
# <a name="server-side-performance-queries"></a>Запросы данных о производительности на стороне сервера

Правильная производительность отрисовки на сервере крайне важна для стабильной частоты кадров и обеспечения эффективного взаимодействия с пользовательским интерфейсом. Важно тщательно отслеживать характеристики производительности на сервере и при необходимости оптимизировать их. Данные производительности можно запрашивать с помощью выделенных функций API.

Наибольшее влияние на производительность отрисовки оказывают входные данные модели. Сведения о настройке входных данных см. в статье [Настройка преобразования модели](../../how-tos/conversion/configure-model-conversion.md).

Производительность приложений на стороне клиента также может быть узким местом. Для глубокого анализа производительности на стороне клиента рекомендуется использовать [:::no-loc text="performance trace":::](../../how-tos/performance-tracing.md) .

## <a name="clientserver-timeline"></a>Временная шкала клиента и сервера

Прежде чем перейти к подробностям о различных значениях задержки, стоит взглянуть на точки синхронизации между клиентом и сервером на временной шкале:

![Временная шкала конвейера](./media/server-client-timeline.png)

На рисунке показано как:

* *оценка положения* запускается клиентом при постоянной частоте кадров 60 Гц (каждые 16,6 мс);
* затем сервер запускает отрисовку на основе положения;
* сервер отправляет обратно закодированное видеоизображение;
* клиент декодирует изображение, выполняет над ним некоторую работу ЦП и GPU, а затем показывает образ.

## <a name="frame-statistics-queries"></a>Запросы данных о статистике кадров

В статистике кадров предоставлены некоторые важные сведения о последнем кадре, например задержка. Данные, предоставленные в структуре `FrameStatistics`, измеряются на стороне клиента, поэтому API является синхронным вызовом:

```cs
void QueryFrameData(AzureSession session)
{
    FrameStatistics frameStatistics;
    if (session.GraphicsBinding.GetLastFrameStatistics(out frameStatistics) == Result.Success)
    {
        // do something with the result
    }
}
```

```cpp
void QueryFrameData(ApiHandle<AzureSession> session)
{
    FrameStatistics frameStatistics;
    if (*session->GetGraphicsBinding()->GetLastFrameStatistics(&frameStatistics) == Result::Success)
    {
        // do something with the result
    }
}
```

Полученный объект `FrameStatistics` содержит следующие элементы:

| Участник | Объяснение |
|:-|:-|
| latencyPoseToReceive | Задержка оценки положения камеры на устройстве клиента происходит до тех пор, пока кадр сервера для этого положения не будет полностью доступен клиентскому приложению. Это значение содержит цикл обращений по сети, время преобразования сервера для просмотра, сведения о декодировании видео и компенсации дрожания. См. **интервал 1 на приведенной выше иллюстрации.**|
| latencyReceiveToPresent | Задержка доступности полученного удаленного кадра происходит до тех пор, пока клиентское приложение не вызовет PresentFrame в ЦП. |
| latencyPresentToDisplay  | Задержка предоставления кадра в ЦП происходит до тех пор, пока не загорится экран. Это значение содержит время GPU клиента, любую буферизацию кадров, выполняемую операционной системой, и время считывания данных с дисплея, зависящее от устройства. См. **интервал 2 на приведенной выше иллюстрации.**|
| timeSinceLastPresent | Время между последовательными вызовами PresentFrame в ЦП. Значения, превышающие длительность отображения (например, 16,6 мс на клиентском устройстве с частотой 60 Гц), указывают на проблемы, вызванные тем, что клиентское приложение не завершило рабочую нагрузку ЦП вовремя. См. **интервал 3 на приведенной выше иллюстрации.**|
| videoFramesReceived | Число кадров, полученных с сервера за последнюю секунду. |
| videoFrameReusedCount | Число полученных кадров за последнюю секунду, которые использовались на устройстве несколько раз. Ненулевые значения указывают на то, что кадры пришлось повторно использовать и репроецировать из-за дрожаний в сети или длительной отрисовки сервера. |
| videoFramesSkipped | Число полученных кадров за последнюю секунду, которые были декодированы, но не показаны на экране, так как поступил более новый кадр. Ненулевые значения указывают на то, что дрожание в сети привело к задержке нескольких кадров, а затем поступило на клиентское устройство вместе с пакетом. |
| videoFramesDiscarded | Очень похоже на **videoFramesSkipped**, но причина отмены заключается в том, что кадр поступил так поздно, что его уже нельзя коррелировать с каким-либо ожидающим положением. В этом случае возникает серьезное сетевое состязание.|
| videoFrameMinDelta | Минимальное количество времени между двумя последовательными кадрами, поступающими за последнюю секунду. Вместе с videoFrameMaxDelta этот диапазон указывает на дрожание, вызванное либо сетью, либо видеокодеком. |
| videoFrameMaxDelta | Максимальное количество времени между двумя последовательными кадрами, поступающими за последнюю секунду. Вместе с videoFrameMinDelta этот диапазон указывает на дрожание, вызванное либо сетью, либо видеокодеком. |

Сумма всех значений задержки обычно гораздо больше, чем доступное время кадра с частотой 60 Гц. Это нормально, так как к нескольким кадрам предоставлен параллельный доступ, а новые запросы к кадрам запускаются с требуемой частотой, как показано на рисунке. Однако если задержка станет слишком большой, она повлияет на качество [перепроецирования на позднем этапе](../../overview/features/late-stage-reprojection.md) и может нарушить общую работу.

`videoFramesReceived`, `videoFrameReusedCount` и `videoFramesDiscarded` можно использовать для производительности сети и сервера датчика. Если `videoFramesReceived` низкая, а `videoFrameReusedCount` высокая, это может указывать на перегрузку сети или низкую производительность сервера. Высокое значение `videoFramesDiscarded` также указывает на перегрузку сети.

Наконец, `timeSinceLastPresent`, `videoFrameMinDelta` и `videoFrameMaxDelta` дают общее представление о вариантности входящих видеокадров и локальных текущих вызовах. Высокая вариантность означает нестабильную частоту кадров.

Ни одно из приведенных выше значений четко не указывает на чистую задержку сети (красные стрелки на рисунке), так как точное время выполнения отрисовки сервером необходимо вычесть из значения цикла `latencyPoseToReceive`. Информация об общей задержке на стороне сервера недоступна для клиента. Тем не менее в следующем разделе объясняется, как это значение было получено с помощью дополнительных входных данных с сервера и предоставлено с помощью значения `networkLatency`.

## <a name="performance-assessment-queries"></a>Запросы для оценки производительности

*Запросы для оценки производительности* предоставляют более подробные сведения о рабочей нагрузке ЦП и GPU на сервере. Так как данные запрашиваются с сервера, запрос моментального снимка показателей производительности соответствует обычному асинхронному шаблону:

```cs
PerformanceAssessmentAsync _assessmentQuery = null;

void QueryPerformanceAssessment(AzureSession session)
{
    _assessmentQuery = session.Actions.QueryServerPerformanceAssessmentAsync();
    _assessmentQuery.Completed += (PerformanceAssessmentAsync res) =>
    {
        // do something with the result:
        PerformanceAssessment result = res.Result;
        // ...

        _assessmentQuery = null;
    };
}
```

```cpp
void QueryPerformanceAssessment(ApiHandle<AzureSession> session)
{
    ApiHandle<PerformanceAssessmentAsync> assessmentQuery = *session->Actions()->QueryServerPerformanceAssessmentAsync();
    assessmentQuery->Completed([] (ApiHandle<PerformanceAssessmentAsync> res)
    {
        // do something with the result:
        PerformanceAssessment result = res->GetResult();

        // ...

    });
}
```

В отличие от объекта `FrameStatistics`, объект `PerformanceAssessment` содержит сведения на стороне сервера:

| Участник | Объяснение |
|:-|:-|
| timeCPU | Среднее время ЦП сервера на кадр в миллисекундах |
| timeGPU | Среднее время GPU сервера на кадр в миллисекундах |
| utilizationCPU | Общее использование ЦП в процентах |
| utilizationGPU | Общее использование GPU в процентах |
| memoryCPU | Общее использование основной памяти сервера в процентах |
| memoryGPU | Общее использование выделенной видеопамяти в процентах на сервере GPU |
| networkLatency | Приблизительная средняя цикличная задержка сети в миллисекундах. На приведенном выше рисунке она соответствует сумме красных стрелок. Значение вычисляется путем вычитания фактического времени отрисовки на сервере из значения `latencyPoseToReceive` в `FrameStatistics`. Хотя это значение является неточным, оно указывает на задержку сети, изолированной от значений задержки, вычисленных на клиенте. |
| polygonsRendered | Число треугольников, преобразуемых для просмотра в одном кадре. Сюда также относятся треугольники, которые исключаются во время подготовки к просмотру. Это означает, что это число не зависит от количества различных позиций камеры, но производительность может значительно зависеть от процента исключенных треугольников.|

Чтобы помочь вам оценить значения, у каждого из них есть классификация качества, например **Great** (Отлично), **Good** (Хорошо), **Mediocre** (Средне) или **Bad** (Плохо).
Эта метрика оценки дает приблизительную оценку работоспособности сервера, но не должна рассматриваться как абсолютная. Например, предположим, что для времени GPU отображается оценка Mediocre "Средне". Оно считается средним, так как приближается к лимиту общего бюджета времени кадра. Однако несмотря на это, в вашем случае оно может быть хорошим значением, так как вы отрисовываете сложную модель.

## <a name="statistics-debug-output"></a>Выходные данные отладки статистики

Класс `ARRServiceStats` — это класс C#, который обтекает как статистику кадров, так и запросы для оценки производительности и предоставляет удобные функциональные возможности для возврата статистики в виде статистических значений или предварительно созданной строки. Следующий код является самым простым способом показать статистику на стороне сервера в клиентском приложении.

```cs
ARRServiceStats _stats = null;

void OnConnect()
{
    _stats = new ARRServiceStats();
}

void OnDisconnect()
{
    _stats = null;
}

void Update()
{
    if (_stats != null)
    {
        // update once a frame to retrieve new information and build average values
        _stats.Update(Service.CurrentActiveSession);

        // retrieve a string with relevant stats information
        InfoLabel.text = _stats.GetStatsString();
    }
}
```

Приведенный выше код заполняет текстовую метку следующим текстом:

![Выходные данные строки ArrServiceStats](./media/arr-service-stats.png)

API `GetStatsString` форматирует строку всех значений, но каждое отдельное значение может также запрашиваться программно из экземпляра `ARRServiceStats`.

Существуют также варианты элементов, которые агрегируют значения с течением времени. Ознакомьтесь с элементами с суффиксом `*Avg`, `*Max` или `*Total`. Элемент `FramesUsedForAverage` указывает, сколько кадров использовалось для этого агрегирования.

## <a name="api-documentation"></a>Документирование API

* [C# Ремотеманажер. Куерисерверперформанцеассессментасинк ()](/dotnet/api/microsoft.azure.remoterendering.remotemanager.queryserverperformanceassessmentasync)
* [C++ Ремотеманажер:: Куерисерверперформанцеассессментасинк ()](/cpp/api/remote-rendering/remotemanager#queryserverperformanceassessmentasync)

## <a name="next-steps"></a>Дальнейшие действия

* [Создание трассировок производительности на стороне клиента](../../how-tos/performance-tracing.md)
* [Настройка преобразования модели](../../how-tos/conversion/configure-model-conversion.md)