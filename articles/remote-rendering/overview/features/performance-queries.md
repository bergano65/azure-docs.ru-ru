---
title: Запросы данных о производительности на стороне сервера
description: Как выполнять запросы данных о производительности на стороне сервера с помощью вызовов API
author: florianborn71
ms.author: flborn
ms.date: 02/10/2020
ms.topic: article
ms.custom: devx-track-csharp
ms.openlocfilehash: 30b8104a9596f0b32f731c507b513b204f5d1acd
ms.sourcegitcommit: f377ba5ebd431e8c3579445ff588da664b00b36b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2021
ms.locfileid: "99594101"
---
# <a name="server-side-performance-queries"></a>Запросы данных о производительности на стороне сервера

Правильная производительность отрисовки на сервере крайне важна для стабильной частоты кадров и обеспечения эффективного взаимодействия с пользовательским интерфейсом. Важно тщательно отслеживать характеристики производительности на сервере и при необходимости оптимизировать их. Данные производительности можно запрашивать с помощью выделенных функций API.

Наибольшее влияние на производительность отрисовки оказывают входные данные модели. Сведения о настройке входных данных см. в статье [Настройка преобразования модели](../../how-tos/conversion/configure-model-conversion.md).

Производительность приложений на стороне клиента также может быть узким местом. Для глубокого анализа производительности на стороне клиента рекомендуется использовать [:::no-loc text="performance trace":::](../../how-tos/performance-tracing.md) .

## <a name="clientserver-timeline"></a>Временная шкала клиента и сервера

Прежде чем перейти к подробностям о различных значениях задержки, стоит взглянуть на точки синхронизации между клиентом и сервером на временной шкале:

![Временная шкала конвейера](./media/server-client-timeline.png)

На рисунке показано как:

* *оценка положения* запускается клиентом при постоянной частоте кадров 60 Гц (каждые 16,6 мс);
* затем сервер запускает отрисовку на основе положения;
* сервер отправляет обратно закодированное видеоизображение;
* клиент декодирует изображение, выполняет над ним некоторую работу ЦП и GPU, а затем показывает образ.

## <a name="frame-statistics-queries"></a>Запросы данных о статистике кадров

В статистике кадров предоставлены некоторые важные сведения о последнем кадре, например задержка. Данные, предоставленные в структуре `FrameStatistics`, измеряются на стороне клиента, поэтому API является синхронным вызовом:

```cs
void QueryFrameData(RenderingSession session)
{
    FrameStatistics frameStatistics;
    if (session.GraphicsBinding.GetLastFrameStatistics(out frameStatistics) == Result.Success)
    {
        // do something with the result
    }
}
```

```cpp
void QueryFrameData(ApiHandle<RenderingSession> session)
{
    FrameStatistics frameStatistics;
    if (session->GetGraphicsBinding()->GetLastFrameStatistics(&frameStatistics) == Result::Success)
    {
        // do something with the result
    }
}
```

Полученный объект `FrameStatistics` содержит следующие элементы:

| Участник | Объяснение |
|:-|:-|
| латенципосеторецеиве | Задержка оценки положения камеры на устройстве клиента происходит до тех пор, пока кадр сервера для этого положения не будет полностью доступен клиентскому приложению. Это значение содержит цикл обращений по сети, время преобразования сервера для просмотра, сведения о декодировании видео и компенсации дрожания. См. **интервал 1 на приведенной выше иллюстрации.**|
| латенцирецеиветопресент | Задержка доступности полученного удаленного кадра происходит до тех пор, пока клиентское приложение не вызовет PresentFrame в ЦП. См. **интервал 2 на приведенной выше иллюстрации.**|
| латенципресенттодисплай  | Задержка предоставления кадра в ЦП происходит до тех пор, пока не загорится экран. Это значение содержит время GPU клиента, любую буферизацию кадров, выполняемую операционной системой, и время считывания данных с дисплея, зависящее от устройства. См. **интервал 3 на приведенной выше иллюстрации.**|
| тимесинцеластпресент | Время между последовательными вызовами PresentFrame в ЦП. Значения, превышающие длительность отображения (например, 16,6 мс на клиентском устройстве с частотой 60 Гц), указывают на проблемы, вызванные тем, что клиентское приложение не завершило рабочую нагрузку ЦП вовремя.|
| видеофрамесрецеивед | Число кадров, полученных с сервера за последнюю секунду. |
| видеофрамереуседкаунт | Число полученных кадров за последнюю секунду, которые использовались на устройстве несколько раз. Ненулевые значения указывают на то, что кадры пришлось повторно использовать и репроецировать из-за дрожаний в сети или длительной отрисовки сервера. |
| видеофрамесскиппед | Число полученных кадров за последнюю секунду, которые были декодированы, но не показаны на экране, так как поступил более новый кадр. Ненулевые значения указывают на то, что дрожание в сети привело к задержке нескольких кадров, а затем поступило на клиентское устройство вместе с пакетом. |
| видеофрамесдискардед | Очень похоже на **видеофрамесскиппед**, но причина, по которой она была удалена, заключается в том, что кадр поступил так, что он даже не может быть связан с любым ожидающим набором. Если такая отмена происходит, возникает серьезное состязание за сеть.|
| видеофрамеминделта | Минимальное количество времени между двумя последовательными кадрами, поступающими за последнюю секунду. Вместе с Видеофрамемаксделта этот диапазон дает указание на нарушение, вызванное либо сетевым, либо видеокодеком. |
| видеофрамемаксделта | Максимальное количество времени между двумя последовательными кадрами, поступающими за последнюю секунду. Вместе с Видеофрамеминделта этот диапазон дает указание на нарушение, вызванное либо сетевым, либо видеокодеком. |

Сумма всех значений задержки обычно гораздо больше, чем доступное время кадра с частотой 60 Гц. Это нормально, так как к нескольким кадрам предоставлен параллельный доступ, а новые запросы к кадрам запускаются с требуемой частотой, как показано на рисунке. Однако если задержка станет слишком большой, она повлияет на качество [перепроецирования на позднем этапе](../../overview/features/late-stage-reprojection.md) и может нарушить общую работу.

`VideoFramesReceived`, `VideoFrameReusedCount` и `VideoFramesDiscarded` можно использовать для производительности сети и сервера датчика. Сочетание низкого `VideoFramesReceived` и большого `VideoFrameReusedCount` значений может указывать на перегрузку сети или низкую производительность сервера. Высокое значение `VideoFramesDiscarded` также указывает на перегрузку сети.

Наконец, `TimeSinceLastPresent`, `VideoFrameMinDelta` и `VideoFrameMaxDelta` дают общее представление о вариантности входящих видеокадров и локальных текущих вызовах. Высокая вариантность означает нестабильную частоту кадров.

Ни одно из приведенных выше значений четко не указывает на чистую задержку сети (красные стрелки на рисунке), так как точное время выполнения отрисовки сервером необходимо вычесть из значения цикла `LatencyPoseToReceive`. Информация об общей задержке на стороне сервера недоступна для клиента. Тем не менее в следующем разделе объясняется, как это значение было получено с помощью дополнительных входных данных с сервера и предоставлено с помощью значения `NetworkLatency`.

## <a name="performance-assessment-queries"></a>Запросы для оценки производительности

*Запросы для оценки производительности* предоставляют более подробные сведения о рабочей нагрузке ЦП и GPU на сервере. Так как данные запрашиваются с сервера, запрос моментального снимка показателей производительности соответствует обычному асинхронному шаблону:

```cs
async void QueryPerformanceAssessment(RenderingSession session)
{
    try
    {
        PerformanceAssessment result = await session.Connection.QueryServerPerformanceAssessmentAsync();
        // do something with result...
    }
    catch (RRException ex)
    {
    }
}
```

```cpp
void QueryPerformanceAssessment(ApiHandle<RenderingSession> session)
{
    session->Connection()->QueryServerPerformanceAssessmentAsync([](Status status, PerformanceAssessment result) {
        if (status == Status::OK)
        {
            // do something with result...
        }
    });
}
```

В отличие от объекта `FrameStatistics`, объект `PerformanceAssessment` содержит сведения на стороне сервера:

| Участник | Объяснение |
|:-|:-|
| тимекпу | Среднее время ЦП сервера на кадр в миллисекундах |
| тимегпу | Среднее время GPU сервера на кадр в миллисекундах |
| утилизатионкпу | Общее использование ЦП в процентах |
| утилизатионгпу | Общее использование GPU в процентах |
| меморикпу | Общее использование основной памяти сервера в процентах |
| меморигпу | Общее использование выделенной видеопамяти в процентах на сервере GPU |
| NetworkLatency | Приблизительная средняя цикличная задержка сети в миллисекундах. На рисунке выше это значение соответствует сумме красной стрелки. Значение вычисляется путем вычитания фактического времени отрисовки на сервере из значения `LatencyPoseToReceive` в `FrameStatistics`. Хотя это значение является неточным, оно указывает на задержку сети, изолированной от значений задержки, вычисленных на клиенте. |
| полигонсрендеред | Число треугольников, преобразуемых для просмотра в одном кадре. Сюда также относятся треугольники, которые исключаются во время подготовки к просмотру. Это означает, что это число не зависит от количества различных позиций камеры, но производительность может значительно зависеть от процента исключенных треугольников.|

Чтобы помочь вам оценить значения, у каждого из них есть классификация качества, например **Great** (Отлично), **Good** (Хорошо), **Mediocre** (Средне) или **Bad** (Плохо).
Эта метрика оценки дает приблизительную оценку работоспособности сервера, но не должна рассматриваться как абсолютная. Например, предположим, что для времени GPU отображается оценка Mediocre "Средне". Оно считается средним, так как приближается к лимиту общего бюджета времени кадра. Однако несмотря на это, в вашем случае оно может быть хорошим значением, так как вы отрисовываете сложную модель.

## <a name="statistics-debug-output"></a>Выходные данные отладки статистики

Класс `ServiceStatistics` — это класс C#, который обтекает как статистику кадров, так и запросы для оценки производительности и предоставляет удобные функциональные возможности для возврата статистики в виде статистических значений или предварительно созданной строки. Следующий код является самым простым способом показать статистику на стороне сервера в клиентском приложении.

```cs
ServiceStatistics _stats = null;

void OnConnect()
{
    _stats = new ServiceStatistics();
}

void OnDisconnect()
{
    _stats = null;
}

void Update()
{
    if (_stats != null)
    {
        // update once a frame to retrieve new information and build average values
        _stats.Update(Service.CurrentActiveSession);

        // retrieve a string with relevant stats information
        InfoLabel.text = _stats.GetStatsString();
    }
}
```

Приведенный выше код заполняет текстовую метку следующим текстом:

![Выходные данные строки ArrServiceStats](./media/arr-service-stats.png)

API `GetStatsString` форматирует строку всех значений, но каждое отдельное значение может также запрашиваться программно из экземпляра `ServiceStatistics`.

Существуют также варианты элементов, которые агрегируют значения с течением времени. Ознакомьтесь с элементами с суффиксом `*Avg`, `*Max` или `*Total`. Элемент `FramesUsedForAverage` указывает, сколько кадров использовалось для этого агрегирования.

## <a name="api-documentation"></a>Документирование API

* [C# Рендерингконнектион. Куерисерверперформанцеассессментасинк ()](/dotnet/api/microsoft.azure.remoterendering.renderingconnection.queryserverperformanceassessmentasync)
* [C++ Рендерингконнектион:: Куерисерверперформанцеассессментасинк ()](/cpp/api/remote-rendering/renderingconnection#queryserverperformanceassessmentasync)

## <a name="next-steps"></a>Дальнейшие действия

* [Создание трассировок производительности на стороне клиента](../../how-tos/performance-tracing.md)
* [Настройка преобразования модели](../../how-tos/conversion/configure-model-conversion.md)