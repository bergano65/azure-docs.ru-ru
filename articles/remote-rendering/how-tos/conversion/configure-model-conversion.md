---
title: Настройка преобразования модели
description: Описание всех параметров преобразования модели.
author: florianborn71
ms.author: flborn
ms.date: 03/06/2020
ms.topic: how-to
ms.openlocfilehash: 1cb5312e164bac09930497c377f1590b6a77ca05
ms.sourcegitcommit: 957c916118f87ea3d67a60e1d72a30f48bad0db6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2020
ms.locfileid: "92205325"
---
# <a name="configure-the-model-conversion"></a>Настройка преобразования модели

В этой главе описываются параметры преобразования модели.

## <a name="settings-file"></a>Файл параметров

Если файл с именем `<modelName>.ConversionSettings.json` найден во входном контейнере рядом с входной моделью `<modelName>.<ext>` , то он будет использоваться для предоставления дополнительной настройки для процесса преобразования модели.
Например, `box.ConversionSettings.json` будет использоваться при преобразовании `box.gltf` .

Содержимое этого файла должно соответствовать приведенной ниже схеме JSON.

```json
{
    "$schema" : "http://json-schema.org/schema#",
    "description" : "ARR ConversionSettings Schema",
    "type" : "object",
    "properties" :
    {
        "scaling" : { "type" : "number", "exclusiveMinimum" : 0, "default" : 1.0 },
        "recenterToOrigin" : { "type" : "boolean", "default" : false },
        "opaqueMaterialDefaultSidedness" : { "type" : "string", "enum" : [ "SingleSided", "DoubleSided" ], "default" : "DoubleSided" },
        "gammaToLinearMaterial" : { "type" : "boolean", "default" : false },
        "gammaToLinearVertex" : { "type" : "boolean", "default" : false },
        "sceneGraphMode": { "type" : "string", "enum" : [ "none", "static", "dynamic" ], "default" : "dynamic" },
        "generateCollisionMesh" : { "type" : "boolean", "default" : true },
        "unlitMaterials" : { "type" : "boolean", "default" : false },
        "fbxAssumeMetallic" : { "type" : "boolean", "default" : true },
        "deduplicateMaterials" : { "type" : "boolean", "default" : true },
        "axis" : {
            "type" : "array",
            "items" : {
                "type" : "string",
                "enum" : ["default", "+x", "-x", "+y", "-y", "+z", "-z"]
            },
            "minItems": 3,
            "maxItems": 3
        },
        "metadataKeys": {
            "type": "array",
            "items": {
                "type": "string"
            }
        }
    },
    "additionalProperties" : false
}
```

Пример файла `box.ConversionSettings.json` :

```json
{
    "scaling" : 0.01,
    "recenterToOrigin" : true,
    "material-override" : "box_materials_override.json"
}
```

### <a name="geometry-parameters"></a>Параметры геометрии

* `scaling` — этот параметр равномерно масштабирует модель. Масштабирование можно использовать для увеличения или уменьшения модели, например, чтобы отобразить модель здания на ровной поверхности.
Масштабирование также важно, если модель определена в единицах, отличных от счетчиков, так как подсистема подготовки отчетов принимает счетчики.
Например, если модель определена в сантиметрах, то применение масштаба 0,01 должно привести к отображению модели в правильном размере.
Некоторые форматы исходных данных (например, FBX) предоставляют указание масштаба единиц. В этом случае процесс преобразования неявно масштабирует модель в метрических единицах измерения. Неявное масштабирование на основе исходного формата переопределит параметр масштабирования.
Окончательный коэффициент масштабирования применяется к вершинам геометрии и локальным преобразованиям узлов графа сцены. Масштабирование при преобразовании корневой сущности остается неизменным.

* `recenterToOrigin` — указывает, что модель должна быть преобразована таким образом, чтобы ее ограничивающий прямоугольник был расположен по центру в источнике.
Если исходная модель перемещается далеко из исходной, проблемы точности с плавающей запятой могут вызвать артефакты визуализации.
В этой ситуации может помочь центрирование модели.

* `opaqueMaterialDefaultSidedness` — подсистема визуализации предполагает, что непрозрачные материалы являются двусторонними.
Если это допущение не верно для конкретной модели, для этого параметра следует задать значение "Синглесидед". Дополнительные сведения см. в разделе [ :::no-loc text="single sided"::: Подготовка к просмотру](../../overview/features/single-sided-rendering.md).

### <a name="material-de-duplication"></a>Дедупликация материалов

* `deduplicateMaterials` — этот параметр включает или отключает автоматическую дедупликацию материалов с общими свойствами и текстурами. Дедупликация выполняется после обработки переопределения материалов. По умолчанию он включен.

* Если даже после отмены дублирования модель содержит более 65 535 материалов, Служба попытается объединить материалы с аналогичными свойствами. В качестве последнего средства, превышающих ограничение, все материалы будут заменены красными материалами об ошибках.

![На рисунке показаны два куба 68 921 цветных треугольника.](media/mat-dedup.png?raw=true)

Два куба 68 921 цветных треугольников. Left: перед дедупликацией с использованием цветовых материалов 68 921. Right: после отмены дублирования с помощью цветовых материалов 64 000. Ограничение составляет 65 535 материалов. (См. раздел [ограничения](../../reference/limits.md).)

### <a name="color-space-parameters"></a>Параметры цветового пространства

Подсистема визуализации ожидает, что значения цвета будут находиться в линейном пространстве.
Если модель определена с помощью гамма-пространства, то для этих параметров следует задать значение True.

* `gammaToLinearMaterial` — преобразование цвета материалов из гамма-пространства в линейное пространство.
* `gammaToLinearVertex` — Преобразование :::no-loc text="vertex"::: цветов из области гаммы в линейное пространство

> [!NOTE]
> Для FBX-файлов эти параметры по умолчанию имеют значение `true`. Для всех остальных типов файлов значение по умолчанию — `false`.

### <a name="scene-parameters"></a>Параметры сцены

* `sceneGraphMode` — определяет, как преобразуется граф сцены в исходном файле.
  * `dynamic` (значение по умолчанию). Все объекты в файле предоставляются как [сущности](../../concepts/entities.md) в API и могут быть преобразованы независимо друг от друга. Иерархия узлов во время выполнения идентична структуре в исходном файле.
  * `static`: Все объекты представлены в API, но они не могут быть преобразованы независимо друг от друга.
  * `none`. Граф сцены сворачивается в один объект.

Каждый режим обеспечивает разную производительность во время выполнения. В режиме `dynamic` нагрузка на ресурсы линейно пропорциональна числу [сущностей](../../concepts/entities.md) в графе, даже если ни одна часть не перемещается. `dynamic`Режим используется только в том случае, если необходимо перемещать части по отдельности, например для анимации представления развертывания.

Режим `static` экспортирует полный граф сцены, но части в этом графе используют постоянное преобразование относительно его корневой части. Однако корневой узел объекта по-прежнему можно перемещать, поворачивать или масштабировать без значительной нагрузки на ресурсы. Более того, [пространственные запросы](../../overview/features/spatial-queries.md) будут возвращать отдельные части, и каждую часть можно будет изменить с помощью [переопределений состояния](../../overview/features/override-hierarchical-state.md). В этом режиме дополнительные затраты времени выполнения на объект незначительны. Этот режим идеально подходит для больших сцен, в которых требуется проверка отдельных объектов, но не изменяется преобразование каждого отдельного объекта.

Режим `none` обеспечивает минимальные затраты времени выполнения, а также немного меньшее время загрузки. Проверка или преобразование отдельных объектов в этом режиме невозможны. К вариантам использования можно отнести фотограмметрические модели, в которых в принципе отсутствует осмысленный граф сцены.

> [!TIP]
> Многие приложения будут загружать несколько моделей. Необходимо оптимизировать параметры преобразования для каждой модели в зависимости от того, как она будет использоваться. Например, если вы хотите отобразить модель автомобиля, чтобы пользователь мог подробно ее осмотреть, необходимо преобразовать ее в режиме `dynamic`. Но если вы также хотите поместить автомобиль в демонстрационную среду, то эту модель можно преобразовать, задав для параметра `sceneGraphMode` значение `static` или даже `none`.

### <a name="physics-parameters"></a>Параметры физики

* `generateCollisionMesh` — если требуется поддержка [пространственных запросов](../../overview/features/spatial-queries.md) к модели, этот параметр должен быть включен. В худшем случае создание сетки столкновений может удвоить время преобразования. Модели с сетками столкновений загружаются дольше, а при использовании графа сцены `dynamic` они также повышают нагрузку на ресурсы во время выполнения. Чтобы обеспечить общую оптимальную производительность, следует отключить этот параметр для всех моделей, для которых не требуются пространственные запросы.

### <a name="unlit-materials"></a>Неосвещенные материалы

* `unlitMaterials` — по умолчанию при преобразовании будут предпочтительно создаваться [материалы PBR](../../overview/features/pbr-materials.md). А этот параметр указывает преобразователю обрабатывать все материалы как [цветовые материалы](../../overview/features/color-materials.md). Если у вас есть данные, которые уже содержат освещение, например модели, созданные с помощью фотограмметрии, этот параметр позволяет быстро применить правильное преобразование для всех материалов без необходимости [переопределять каждый материал](override-materials.md) по отдельности.

### <a name="converting-from-older-fbx-formats-with-a-phong-material-model"></a>Преобразование устаревших форматов FBX с моделью материала по методу Фонга

* `fbxAssumeMetallic` — в устаревших версиях формата FBX материалы определяются с помощью модели материала по методу Фонга. В процессе преобразования необходимо определить, как эти материалы сопоставляются с [моделью PBR](../../overview/features/pbr-materials.md). Обычно все происходит без проблем, но может возникнуть неоднозначность, когда у материала нет текстур, высоких отражающих значений и не серого диффузного цвета. В этом случае процессу преобразования нужно выбрать, отдать предпочтение высоким отражающим значениям, определив сильно отражающий металлический материал, на котором диффузный цвет рассеивается, или отдать предпочтение диффузному цвету, определив нечто вроде блестящего цветного пластика. В случаях неоднозначности по умолчанию процессом преобразования предполагается, что высокие отражающие значения означают металлический материал. Этому параметру можно присвоить значение `false`, чтобы преобразование выполнялось наоборот.

### <a name="coordinate-system-overriding"></a>Переопределение системы координат

* `axis` — позволяет переопределить единичные векторы системы координат. Значения по умолчанию: `["+x", "+y", "+z"]`. Теоретически формат FBX содержит заголовок, в котором определены эти векторы, а преобразование использует эти сведения для преобразования сцены. Формат glTF также определяет фиксированную систему координат. На практике некоторые ресурсы либо содержат неправильную информацию в заголовке, либо были сохранены с использованием другого соглашения о системе координат. Этот параметр позволяет переопределить систему координат, чтобы компенсировать это. Например: `"axis" : ["+x", "+z", "-y"]` поменяет местами оси Z и Y и сохранит направленность системы координат, инвертировав направление оси Y.

### <a name="node-meta-data"></a>Метаданные узла

* `metadataKeys` — Позволяет указать ключи свойств метаданных узла, которые должны оставаться в результатах преобразования. Можно указать точные ключи или ключи-шаблоны. Ключи с подстановочными знаками имеют формат "ABC *" и соответствуют любому ключу, который начинается с "ABC". Поддерживаются следующие типы значений метаданных: `bool` , `int` , `float` и `string` .

    Для файлов ГЛТФ эти данные поступают из [объекта "вспомогательные объекты" на узлах](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodeextras). Для файлов FBX эти данные поступают из `Properties70` данных `Model nodes` . Дополнительные сведения см. в документации к средству 3D Asset.

### <a name="no-loc-textvertex-format"></a>:::no-loc text="Vertex"::: формат

Можно настроить :::no-loc text="vertex"::: Формат сетки, чтобы обеспечить точность экономии памяти. Меньшая занимаемая память позволит загружать модели большего размера или повысить производительность. Однако, в зависимости от данных, неправильный формат может значительно повлиять на качество отрисовки.

> [!CAUTION]
> Изменение :::no-loc text="vertex"::: формата должно быть последним средством, когда модели больше не помещаются в память, а также при оптимизации оптимальной производительности. Изменения могут легко привести к появлению артефактов визуализации, как очевидных, так и малозаметных. Не следует изменять значение по умолчанию, если только вы не уверены, что знаете, что делаете.

Возможны следующие корректировки.

* Можно явно включить или исключить определенные потоки данных.
* Точность потоков данных можно уменьшить, чтобы сократить занимаемую память.

Следующий раздел `vertex` в файле `.json` является необязательным. Для каждой части, которая не указана явно, служба преобразования применяет значение по умолчанию.

```json
{
    ...
    "vertex" : {
        "position"  : "32_32_32_FLOAT",
        "color0"    : "NONE",
        "color1"    : "NONE",
        "normal"    : "NONE",
        "tangent"   : "NONE",
        "binormal"  : "NONE",
        "texcoord0" : "32_32_FLOAT",
        "texcoord1" : "NONE"
    },
    ...
```

Принудительное применение `NONE` для компонента гарантирует, что выходная сетка не будет содержать соответствующий поток.

#### <a name="component-formats-per-no-loc-textvertex-stream"></a>Форматы компонентов на :::no-loc text="vertex"::: поток

Ниже приведены форматы, которые допускаются для соответствующих компонентов.

| :::no-loc text="Vertex"::: | Поддерживаемые форматы (полужирным шрифтом выделен формат по умолчанию) |
|:-----------------|:------------------|
|position| **32_32_32_FLOAT**, 16_16_16_16_FLOAT |
|color0| **8_8_8_8_UNSIGNED_NORMALIZED**, NONE |
|color1| 8_8_8_8_UNSIGNED_NORMALIZED, **NONE**|
|нормальный| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, NONE |
|tangent| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, NONE |
|binormal| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, NONE |
|texcoord0| **32_32_FLOAT**, 16_16_FLOAT, NONE |
|texcoord1| **32_32_FLOAT**, 16_16_FLOAT, NONE |

#### <a name="supported-component-formats"></a>Поддерживаемые форматы компонентов

Ниже приведены значения занимаемой памяти для форматов.

| Формат | Описание | Байт на :::no-loc text="vertex"::: |
|:-------|:------------|:---------------|
|32_32_FLOAT|Двухкомпонентная полная точность с плавающей запятой.|8
|16_16_FLOAT|Двухкомпонентная половинная точность с плавающей запятой.|4
|32_32_32_FLOAT|Трехкомпонентная полная точность с плавающей запятой.|12
|16_16_16_16_FLOAT|Четырехкомпонентная половинная точность с плавающей запятой.|8
|8_8_8_8_UNSIGNED_NORMALIZED|Четырехкомпонентный байт, нормализованный до диапазона `[0; 1]`.|4
|8_8_8_8_SIGNED_NORMALIZED|Четырехкомпонентный байт, нормализованный до диапазона `[-1; 1]`.|4

#### <a name="best-practices-for-component-format-changes"></a>Рекомендации по изменению формата компонентов

* `position`: В редких случаях понижение точности приемлемо. **16_16_16_16_FLOAT** добавляет заметные артефакты квантования даже для небольших моделей.
* `normal`, `tangent`, `binormal`. Обычно эти значения изменяются вместе. Если нет заметных артефактов освещения из-за обычного квантования, то нет причин увеличивать их точность. Однако в некоторых случаях для этих компонентов можно задать значение **NONE**.
  * `normal`, `tangent` и `binormal` необходимы только в том случае, если хотя бы один материал в модели должен быть освещен. В ARR это происходит, когда в любой момент времени в модели используется [материал PBR](../../overview/features/pbr-materials.md).
  * `tangent` и `binormal` необходимы только в том случае, если в одном из освещенных материалов используется текстура с картой нормалей.
* `texcoord0`, `texcoord1`: координаты текстур могут использовать сниженную точность (**16_16_FLOAT**), если их значения остаются в диапазоне `[0; 1]` и для их текстур задан максимальный размер 2048 на 2048 пикселей. Если эти ограничения превышены, качество наложения текстур снизится.

#### <a name="example"></a>Пример

Предположим, что у вас есть фотограмметрическая модель, которая содержит текстуры с освещением. Все, что необходимо для отрисовки модели, — это :::no-loc text="vertex"::: позиции и координаты текстуры.

По умолчанию преобразователь должен предположить, что в какой-то момент времени вы захотите использовать в модели материалы PBR, поэтому он создаст данные `normal`, `tangent` и `binormal`. Следовательно, использование памяти на вершину составит `position` (12 байт) + `texcoord0` (8 байт) + `normal` (4 байта) + `tangent` (4 байта) + `binormal` (4 байта) = 32 байта. Большие модели этого типа могут легко иметь множество миллионов :::no-loc text="vertices"::: результирующих моделей, которые могут занимать несколько гигабайт памяти. Такие большие объемы данных повлияют на производительность, и даже может закончится свободная память.

Зная, что для модели не требуется динамическое освещение, и зная, что все координаты текстуры находятся в `[0; 1]` диапазоне, можно установить значения `normal` , `tangent` , и `binormal` для `NONE` половинной точности (), а в случае, если это `texcoord0` `16_16_FLOAT` всего 16 байт на :::no-loc text="vertex"::: . Урезание данных сетки вполовину позволит загружать модели большего размера и может повысить производительность.

## <a name="memory-optimizations"></a>Оптимизация памяти

Использование памяти загруженного содержимого может стать узким местом в системе отрисовки. Если полезные данные памяти становятся слишком большими, это может нарушить производительность отрисовки или привести к тому, что модель не будет полностью загружена. В этом абзаце обсуждаются некоторые важные стратегии для уменьшения объема памяти.

### <a name="instancing"></a>Instancing

Создание экземпляров — это концепция, в которой сетки повторно используются для частей с отдельными пространственными преобразованиями, в отличие от каждой части, ссылающейся на собственную уникальную геометрию. Создание экземпляров оказывает значительное влияние на объем памяти.
Примеры использования для создания экземпляров — это винты в модели подсистемы или стулья в архитектурной модели.

> [!NOTE]
> Создание экземпляров может значительно повысить потребление памяти (и, таким же, время загрузки), но усовершенствования на стороне производительности визуализации незначительны.

Служба преобразования учитывает создание экземпляров, если части помечаются в исходном файле соответствующим образом. Однако преобразование не выполняет дополнительный глубокий анализ данных сетки для обнаружения многократно используемых частей. Таким образом, средство создания содержимого и его конвейер экспорта являются деЦисиве критериями для правильной установки экземпляров.

Простой способ проверить, сохраняются ли сведения о создании экземпляров во время преобразования, — просмотреть [статистику вывода](get-information.md#example-info-file), в частности `numMeshPartsInstanced` элемент. Если значение для больше `numMeshPartsInstanced` нуля, это означает, что сетки совместно используются несколькими экземплярами.

#### <a name="example-instancing-setup-in-3ds-max"></a>Пример. Установка экземпляров в 3ds Max

[Autodesk 3ds Max](https://www.autodesk.de/products/3ds-max) имеет разные режимы клонирования объектов **`Copy`** , которые называются, **`Instance`** и ведут себя по-разному в отношении создания **`Reference`** экземпляров в экспортированном `.fbx` файле.

![Клонирование в 3ds Max](./media/3dsmax-clone-object.png)

* **`Copy`** : В этом режиме выполняется клонирование сетки, поэтому ни один из экземпляров не используется ( `numMeshPartsInstanced` = 0).
* **`Instance`** : Два объекта используют одну и ту же сетку, поэтому используется создание экземпляров ( `numMeshPartsInstanced` = 1).
* **`Reference`** : К геометриям могут применяться модификаторы DISTINCT, поэтому программа экспорта выбирает консервативный подход и не использует создание экземпляров ( `numMeshPartsInstanced` = 0).


### <a name="depth-based-composition-mode"></a>Режим композиции на основе глубины

Если возникает проблема с памятью, настройте модуль подготовки отчетов в [режиме компоновки на основе глубины](../../concepts/rendering-modes.md#depthbasedcomposition-mode). В этом режиме полезные данные GPU распределяются по нескольким GPU.

### <a name="decrease-vertex-size"></a>Уменьшить размер вершины

Как описано в разделе рекомендации [по изменению формата компонентов](configure-model-conversion.md#best-practices-for-component-format-changes) , Настройка формата вершин может уменьшить объем памяти. Однако этот вариант должен быть последним.

### <a name="texture-sizes"></a>Размеры текстур

В зависимости от типа сценария объем данных текстуры может перевешивают память, используемую для данных сетки. Модели фотограмметри являются кандидатами.
В конфигурации преобразования не предусмотрен способ автоматического масштабирования текстур. При необходимости масштабирование текстуры должно выполняться в качестве этапа предварительной обработки на стороне клиента. При этом на этапе преобразования выбирается подходящий [Формат сжатия текстур](/windows/win32/direct3d11/texture-block-compression-in-direct3d-11):

* `BC1` для непрозрачных цветовых текстур
* `BC7` для цветовых текстур источника с альфа-каналом

Так как формат `BC7` имеет вдвое больше памяти, чем `BC1` , чем, важно убедиться, что текстуры ввода не обеспечивают альфа-канал без необходимости.

## <a name="typical-use-cases"></a>Стандартные сценарии использования

Поиск оптимальных параметров импорта для конкретного варианта использования может быть утомительным. С другой стороны, параметры преобразования могут оказать значительное влияние на производительность среды выполнения.

Существуют определенные классы вариантов использования, которые соответствуют конкретным оптимизациям. Несколько примеров приведено ниже.

### <a name="use-case-architectural-visualization--large-outdoor-maps"></a>Вариант использования. Архитектурная визуализация и крупные внешние карты

* Сцены этого типа обычно являются статическими, то есть не требуют движущихся частей. Соответственно, `sceneGraphMode` может иметь значение `static` или даже `none`, что повышает производительность среды выполнения. В режиме `static` корневой узел сцены по-прежнему можно перемещать, поворачивать и масштабировать, например, чтобы динамически переключаться между масштабом 1:1 (для вида от первого лица) и видом сверху.

* Если необходимо перемещать части, это, как правило, также означает, что требуется поддержка отслеживания лучей или других [пространственных запросов](../../overview/features/spatial-queries.md), чтобы эти части в принципе можно было выбрать. С другой стороны, если вы не собираетесь ничего перемещать, вероятнее всего, не потребуется выполнять пространственные запросы и, следовательно, можно отключить флаг `generateCollisionMesh`. Этот параметр оказывает значительное влияние на время преобразования, время загрузки, а также на затраты на обновление каждого кадра во время выполнения.

* Если приложение не использует [вырезание плоскостей](../../overview/features/cut-planes.md), флаг `opaqueMaterialDefaultSidedness` должен быть отключен. Увеличение производительности обычно составляет 20–30 %. Вырезание плоскостей по-прежнему можно будет использовать, но при просмотре внутренних частей объектов у них не будет обратной стороны, что будет выглядеть парадоксально. Дополнительные сведения см. в разделе [ :::no-loc text="single sided"::: Подготовка к просмотру](../../overview/features/single-sided-rendering.md).

### <a name="use-case-photogrammetry-models"></a>Вариант использования. Фотограмметрические модели

При отрисовке фотограмметрических моделей обычно нет необходимости в графе сцены, поэтому для `sceneGraphMode` можно задать значение `none`. Так как эти модели редко содержат сложный граф сцены, то влияние этого параметра должно быть незначительным.

Так как освещение уже содержится в текстурах, динамическое освещение не требуется. Таким образом:

* Установите для флага `unlitMaterials` значение `true`, чтобы преобразовать все материалы в неосвещенные [цветовые материалы](../../overview/features/color-materials.md).
* Удалите ненужные данные из формата вершин. Ознакомьтесь с [примером](#example) выше.

### <a name="use-case-visualization-of-compact-machines-etc"></a>Вариант использования. Визуализация компактных механизмов и т. д.

В этих случаях модели часто используют очень высокую детализацию в небольшом объеме. Отрисовщик сильно оптимизирован для обработки таких случаев. Однако большинство оптимизаций, упомянутых в предыдущем варианте использования, здесь не применяется.

* Требуется возможность выбирать и перемещать отдельные части, поэтому для `sceneGraphMode` нужно оставить значение `dynamic`.
* Операции отслеживания лучей обычно являются неотъемлемой частью приложения, поэтому необходимо создавать сетки столкновений.
* Вырезание плоскостей выглядит лучше, если включен флаг `opaqueMaterialDefaultSidedness`.

## <a name="deprecated-features"></a>Устаревшие функции

Предоставление параметров с использованием имени файла, не относящегося к модели `conversionSettings.json` , по-прежнему поддерживается, но не рекомендуется.
Вместо этого следует использовать имя файла, зависящее от модели `<modelName>.ConversionSettings.json` .

Использование `material-override` параметра для определения [файла переопределения материалов](override-materials.md) в файле параметров преобразования по-прежнему поддерживается, но не рекомендуется. Вместо этого следует использовать имя файла, зависящее от модели `<modelName>.MaterialOverrides.json` .

## <a name="next-steps"></a>Дальнейшие действия

* [Преобразование модели](model-conversion.md)
* [Цветовые материалы](../../overview/features/color-materials.md)
* [Материалы PBR](../../overview/features/pbr-materials.md)
* [Переопределение материалов во время преобразования модели](override-materials.md)