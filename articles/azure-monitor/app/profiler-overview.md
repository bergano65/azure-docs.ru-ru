---
title: Профилирование рабочих приложений в Azure с помощью Application Insights Profiler
description: Определите критический путь в коде веб-сервера с помощью профилировщика небольшого размера.
ms.service: azure-monitor
ms.subservice: application-insights
ms.topic: conceptual
author: cweining
ms.author: cweining
ms.date: 08/06/2018
ms.reviewer: mbullwin
ms.openlocfilehash: 64e7cc0afa4051836d38c885dff0bc0a0e0b08c6
ms.sourcegitcommit: a5ebf5026d9967c4c4f92432698cb1f8651c03bb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/08/2019
ms.locfileid: "74922090"
---
# <a name="profile-production-applications-in-azure-with-application-insights"></a>Профилирование приложений в рабочей среде Azure с помощью Application Insights Profiler
## <a name="enable-application-insights-profiler-for-your-application"></a>Включение Application Insights Profiler для приложений

Azure Application Insights Profiler предоставляет трассировки производительности приложений, выполняющихся в рабочей среде Azure. Профилировщик автоматически выполняет сбор данных в большом масштабе, не осложняя работу пользователей. Профилировщик помогает найти критический путь кода, выполнение которого занимает больше всего времени при обработке отдельных веб-запросов. 

Профилировщик работает с приложениями .NET, развернутыми в следующих службах Azure. Конкретные инструкции по включению Profiler для службы каждого типа вы найдете по приведенным ниже ссылкам.

* [Служба приложений Azure](profiler.md?toc=/azure/azure-monitor/toc.json)
* [Oблачныe службы Azure](profiler-cloudservice.md?toc=/azure/azure-monitor/toc.json)
* [Azure Service Fabric](profiler-servicefabric.md?toc=/azure/azure-monitor/toc.json)
* [Профилирование веб-приложений, работающих на виртуальной машине Azure или в масштабируемом наборе виртуальных машин, с помощью Application Insights Profiler](profiler-vm.md?toc=/azure/azure-monitor/toc.json)
* [**Предварительный просмотр** ASP.NET Core веб-приложений Azure для Linux](profiler-aspnetcore-linux.md?toc=/azure/azure-monitor/toc.json) 

Если вы уже включили Profiler, но трассировки не отображаются, проверьте [руководство по устранению неполадок](profiler-troubleshooting.md?toc=/azure/azure-monitor/toc.json).

## <a name="view-profiler-data"></a>Просмотр данных Profiler

Чтобы Profiler смог отправлять трассировки, приложение должно активно обрабатывать запросы. Для эксперимента запросы к веб-приложению можно создать [в рамках тестирования производительности Application Insights](https://docs.microsoft.com/vsts/load-test/app-service-web-app-performance-test). Если вы только что включили Profiler, запустите короткий нагрузочный тест. Во время выполнения нагрузочного теста нажмите кнопку **Профилировать** в области [**параметров профилировщика**](profiler-settings.md). При выполнении Profiler случайным образом выбирает время для сбора данных, примерно по две минуты один раз в час. Если приложение обрабатывает устойчивый поток запросов, Profiler отправляет трассировки каждый час.

После того как приложение получит некоторый объем трафика, а Profiler — достаточное время для передачи трассировок, вы получите возможность их просмотреть. Этот процесс может занять от 5 до 10 минут. Чтобы просмотреть трассировки, на панели **Производительность** выберите **Take Actions** (Предпринять действия), а затем нажмите кнопку **Profiler Traces** (Трассировки Profiler).

![Кнопка Profiler traces (Трассировки Profiler) в области Preview Performance (Производительность предварительной версии) Application Insights][performance-blade]

Выберите пример, чтобы отобразить классификацию на уровне кода по времени, затраченному на выполнение запроса.

![Обозреватель трассировки Application Insights][trace-explorer]

Обозреватель трассировки отображает следующие сведения:

* **Показать критический путь** — открывает основной листовой узел или хотя бы что-то с ним связанное. В большинстве случаев этот узел находится рядом с узким местом производительности.
* **Метка** — имя функции или события. В дереве отображается сочетание кода и возникающих событий (например, события SQL и HTTP). Основное событие предоставляет общую длительность запроса.
* **Истекло** — интервал времени между началом и завершением операции.
* **Когда** — время запуска функции или события по отношению к другим функциям.

## <a name="how-to-read-performance-data"></a>Чтение данных о производительности

Профилировщик службы Майкрософт использует метод выборки в сочетании с инструментированием для анализа производительности приложения. Во время подробной сборки профилировщик службы каждую миллисекунду проводит выборку указателя инструкций для всех ЦП компьютера. Каждый пример записывает полный стек вызовов выполняющегося потока. Он предоставляет подробные сведения об этом потоке на высоком и низком уровне абстракции. Профилировщик службы также собирает сведения о других событиях, включая события переключения контекста, библиотеки параллельных задач (TPL) и пула потоков, для отслеживания корреляции действий и причинно-следственных связей.

Стек вызовов, отображаемый в представлении временной шкалы, является результатом выборки и инструментирования. Так как каждый пример записывает полный стек вызовов потока, он содержит код из Microsoft .NET Framework, а также из других указанных вами платформ.

### <a id="jitnewobj"></a>Выделение объектов (clr!JIT\_New или clr!JIT\_Newarr1)

**clr!JIT\_New** и **clr!JIT\_Newarr1** — это вспомогательные функции в .NET Framework, выделяющие память из управляемой кучи. **clr!JIT\_New** вызывается при выделении объекта. **clr!JIT\_Newarr1** вызывается при выделении массива объектов. Обычно эти две функции выполняются быстро за относительно небольшое время. Если функции **clr!JIT\_New** или **clr!JIT\_Newarr1** занимают довольно много времени во временной шкале, код, возможно, выделяет много объектов и потребляет значительный объем памяти.

### <a id="theprestub"></a>Код загрузки (clr!ThePreStub)

**clr!ThePreStub** — это вспомогательная функция в .NET Framework, подготавливающая код к первому выполнению. Это выполнение обычно включает в себя JIT-компиляцию, но не ограничивается ею. Для каждого метода C# **clr!ThePreStub** должна вызываться только один раз в течение процесса.

Если выполнение **clr!ThePreStub** при запросе занимает много времени, значит этот метод выполняется впервые. На загрузку первого метода требуется значительное время работы среды выполнения .NET Framework. Вы можете использовать процесс прогрева, выполняющий эту часть кода до предоставления к нему доступа пользователям, или запустить генератор образа в машинном коде (ngen.exe) в сборках.

### <a id="lockcontention"></a>Конфликт блокировки (clr!JITutil\_MonContention или clr!JITutil\_MonEnterWorker)

**clr!JITutil\_MonContention** или **clr!JITutil\_MonEnterWorker** указывает, что текущий поток ожидает снятия блокировки. Этот текст обычно отображается при выполнении команды **LOCK** языка C# путем вызова метода **Monitor.Enter** или метода с атрибутом **MethodImplOptions.Synchronized**. Конфликт блокировки обычно происходит при получении блокировки потоком _A_, а также при попытке получить ту же блокировку потоком _Б_ до ее снятия потоком _A_.

### <a id="ngencold"></a>Код загрузки ([COLD])

Если имя метода содержит **[COLD]** , например **mscorlib.ni![COLD]System.Reflection.CustomAttribute.IsDefined**, это значит, что в среде выполнения .NET Framework впервые выполняется код, который не был оптимизирован с помощью [профильной оптимизации](/cpp/build/profile-guided-optimizations). Для каждого метода он должен отображаться только один раз в течение процесса.

Если коду загрузки требуется значительное время на запрос, значит запрос впервые выполняет неоптимизированную часть метода. Вы можете использовать процесс прогрева, который выполняет эту часть кода до предоставления к нему доступа пользователям.

### <a id="httpclientsend"></a>Отправка HTTP-запроса

Методы, такие как **HttpClient.Send**, указывают на то, что код ожидает завершения HTTP-запроса.

### <a id="sqlcommand"></a>Операция с базой данных

Методы, такие как **SqlCommand.Execute**, указывают на то, что код ожидает завершения операции с базой данных.

### <a id="await"></a>Ожидание (AWAIT\_TIME)

**AWAIT\_TIME** указывает на то, что код ожидает завершения другой задачи. Задержка обычно осуществляется с помощью инструкции **AWAIT** языка C#. Когда код выполняет команду C# **AWAIT**, поток освобождается и возвращает управление пулу потоков, то есть ни один поток не блокируется в ожидании завершения **AWAIT**. Однако если рассуждать логически, то поток, который выполнил команду **AWAIT**, "заблокирован" и ожидает завершения операции. Команда **AWAIT\_TIME** указывает время блокировки в ожидании завершения задачи.

### <a id="block"></a>Время блокировки

**BLOCKED_TIME** указывает на то, что код ожидает, пока другой ресурс станет доступным. Например, он может ожидать объект синхронизации, или когда поток станет доступным, или когда завершится запрос.

### <a name="unmanaged-async"></a>Неуправляемый асинхронный

Платформа .NET Framework выдает события ETW и передает идентификаторы действий между потоками, чтобы асинхронные вызовы могли быть отслеживанились в потоках. Неуправляемый код (машинный код) и некоторые устаревшие стили асинхронного кода не имеют этих событий и идентификаторов действий, поэтому профилировщик не может определить, какой поток и какие функции выполняются в потоке. Он помечен как "неуправляемый асинхронный" в стеке вызовов. Если вы скачиваете файл трассировки событий Windows, вы можете использовать [PerfView](https://github.com/Microsoft/perfview/blob/master/documentation/Downloading.md) , чтобы получить более подробные сведения о происходящих.

### <a id="cpu"></a>Время ЦП

ЦП занят выполнением инструкций.

### <a id="disk"></a>Время работы диска

Приложение выполняет операции с диском.

### <a id="network"></a>Сетевое время

Приложение выполняет сетевые операции.

### <a id="when"></a>Столбец "Время"

Столбец **Когда** — это визуальное представление того, как со временем изменяются выборки INCLUSIVE, собранные для узла. Общий диапазон запроса состоит из 32 временных периодов. В них накапливаются включающие выборки для данного узла. Каждый период представляется в виде полосы. Высота полосы обозначает масштабированное значение. Для узлов, помеченных как **CPU_TIME** или **BLOCKED_TIME**, или когда существует очевидная связь с потреблением ресурсов (например, ЦП, диск или поток), в полосе представлено использование одного из этих ресурсов в контейнере. Для этих метрик можно получить значение, превышающее 100 процентов, за счет потребления нескольких ресурсов. Например, если в среднем за определенный интервал времени используется два процессора, то показатель достигнет 200 процентов.

## <a name="limitations"></a>Ограничения

Срок хранения данных по умолчанию — пять дней. Максимальный объем ежедневно обрабатываемых данных — 10 ГБ.

За использование службы профилировщика плата не взимается. Чтобы вы могли использовать ее, веб-приложение должно быть размещено по крайней мере на уровне "Базовый" функции веб-приложения Службы приложений Azure.

## <a name="overhead-and-sampling-algorithm"></a>Дополнительная нагрузка и алгоритм выборки

Раз в час профилировщик запускается случайным образом на две минуты на каждой виртуальной машине, где размещено приложение, для сбора трассировок которого настроен профилировщик. При запуске Profiler увеличивает нагрузку на ресурсы ЦП сервера на 5–15 процентов.

## <a name="next-steps"></a>Дальнейшие действия
Включение Application Insights Profiler для приложения Azure. См. также:
* [Службы приложений](profiler.md?toc=/azure/azure-monitor/toc.json)
* [Oблачныe службы Azure](profiler-cloudservice.md?toc=/azure/azure-monitor/toc.json)
* [Azure Service Fabric](profiler-servicefabric.md?toc=/azure/azure-monitor/toc.json)
* [Профилирование веб-приложений, работающих на виртуальной машине Azure или в масштабируемом наборе виртуальных машин, с помощью Application Insights Profiler](profiler-vm.md?toc=/azure/azure-monitor/toc.json)


[performance-blade]: ./media/profiler-overview/performance-blade-v2-examples.png
[trace-explorer]: ./media/profiler-overview/trace-explorer.png
