---
title: Оптимизация запросов журналов в Azure Monitor
description: Рекомендации по оптимизации запросов журналов в Azure Monitor.
ms.subservice: logs
ms.topic: conceptual
author: bwren
ms.author: bwren
ms.date: 02/28/2019
ms.openlocfilehash: 4fad7d1e3359264c647ffc2d5f67dc547c87a13a
ms.sourcegitcommit: 225a0b8a186687154c238305607192b75f1a8163
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/29/2020
ms.locfileid: "78196660"
---
# <a name="optimize-log-queries-in-azure-monitor"></a>Оптимизация запросов журналов в Azure Monitor
Azure Monitor журналы используют [Azure обозреватель данных (ADX)](/azure/data-explorer/) для хранения данных журнала и выполнения запросов для анализа этих данных. Он создает, управляет и обслуживает кластеры ADX, а также оптимизирует их для рабочей нагрузки анализа журналов. При выполнении запроса он оптимизирован и направляется в соответствующий кластер ADX, в котором хранятся данные рабочей области. В обоих журналах Azure Monitor и Azure обозреватель данных используется множество механизмов автоматического оптимизации запросов. Хотя автоматическая оптимизация обеспечивает значительное повышение производительности, в некоторых случаях можно значительно повысить производительность запросов. В этой статье описываются вопросы производительности и несколько способов их устранения.

Большинство методов являются общими для запросов, которые выполняются непосредственно в журналах обозреватель данных и Azure Monitor Azure, хотя существует несколько уникальных вопросов, касающихся журналов Azure Monitor, которые обсуждаются здесь. Дополнительные советы по оптимизации Azure обозреватель данных см. в разделе рекомендации по [запросам](/azure/kusto/query/best-practices).

Оптимизированные запросы будут:

- Ускорить выполнение, сократить общую длительность выполнения запроса.
- Меньше шансов на регулирование или отклонение.

Следует уделить особое внимание запросам, используемым для повторной и многовременных использования, таких как панели мониторинга, оповещения, Logic Apps и Power BI. Влияние неэффективного запроса в таких случаях существенно.

## <a name="query-performance-pane"></a>Панель производительности запросов
После выполнения запроса в Log Analytics щелкните стрелку вниз над результатами запроса, чтобы просмотреть панель производительности запросов, в которой отображаются результаты нескольких индикаторов производительности для запроса. Эти показатели производительности описаны в следующем разделе.

![Панель производительности запросов](media/query-optimization/query-performance-pane.png)


## <a name="query-performance-indicators"></a>Индикаторы производительности запросов

Для каждого выполняемого запроса доступны следующие индикаторы производительности запросов:

- [Общий ЦП](#total-cpu): Общее вычисление, используемое для обработки запроса на всех вычислительных узлах. Он представляет время, используемое для вычисления, анализа и выборки данных. 

- [Данные, используемые для обработки запроса](#data-used-for-processed-query): общие данные, к которым был получен доступ для обработки запроса. Зависит от размера целевой таблицы, используемого диапазона времени, примененных фильтров и количества столбцов, на которые имеются ссылки.

- [Интервал времени обработанного запроса](#time-span-of-the-processed-query): разрыв между последними и самыми старыми данными, которые были доступны для обработки запроса. Влияет на явный диапазон времени, указанный для запроса.

- [Возраст обработанных данных](#age-of-processed-data): разрыв между Now и самыми старыми данными, к которым осуществлялся доступ для обработки запроса. Это сильно влияет на эффективность выборки данных.

- [Число рабочих областей](#number-of-workspaces): сколько рабочих областей было обращено во время обработки запроса из-за неявного или неявного выбора.

- [Количество регионов](#number-of-regions). количество регионов, к которым осуществлялся доступ во время обработки запроса, из-за неявного или неявного выбора рабочих областей. Запросы в нескольких регионах гораздо менее эффективны, и индикаторы производительности представляют собой частичное покрытие.

- [Параллелизм](#parallelism). указывает, сколько система смогла выполнить этот запрос на нескольких узлах. Относится только к запросам с высоким потреблением ресурсов ЦП. Влияет на использование конкретных функций и операторов.


## <a name="total-cpu"></a>Всего ресурсов ЦП
Фактический вычислительный ЦП, который был инвестирован для обработки этого запроса на всех узлах обработки запросов. Так как большинство запросов выполняются на большом количестве узлов, обычно это будет намного больше, чем длительность выполнения запроса. 

Время обработки запроса затрачено на следующее:
- Получение данных. Извлечение старых данных будет потреблять больше времени, чем получение последних данных.
- Обработка данных — логика и вычисление данных. 

Кроме времени, затраченного на узлы обработки запросов, существует дополнительное время, затрачиваемое Azure Monitor журналов на: проверка подлинности пользователя и проверка того, что им разрешен доступ к этим данным, обнаружение хранилища данных, анализ запроса и выделение обработки запросов. узлами. Это время не включено в общее время ЦП запроса.

Некоторые команды и функции запросов сильно загружены ЦП. Это особенно справедливо для команд, которые анализируют JSON и XML или извлекают сложные регулярные выражения. Такой синтаксический анализ может выполняться явно с помощью функций [parse_json ()](/azure/kusto/query/parsejsonfunction) или [parse_xml ()](/azure/kusto/query/parse-xmlfunction) или неявно при ссылке на динамические столбцы.

Эти функции потребляют производительность ЦП пропорционально количеству обрабатываемых строк. Наиболее эффективная оптимизация заключается в том, чтобы добавить условия WHERE на раннем этапе запроса, которые могут отфильтровывать максимально возможное количество записей до выполнения функции с интенсивным использованием ЦП.

Например, следующие запросы выдают тот же результат, но второй из них гораздо эффективнее, чем условие [WHERE]() перед синтаксическим анализом исключает многие записи:

```Kusto
//less efficient
SecurityEvent
| extend Details = parse_xml(EventData)
| extend FilePath = tostring(Details.UserData.RuleAndFileData.FilePath)
| extend FileHash = tostring(Details.UserData.RuleAndFileData.FileHash)
| summarize count() by FileHash, FilePath
| where FileHash != "" and FilePath !startswith "%SYSTEM32"  // Problem: irrelevant results are filtered after all processing and parsing is done
```
```Kusto
//more efficient
SecurityEvent
| where EventID == 8002 //Only this event have FileHash
| where EventData !has "%SYSTEM32" //Early removal of unwanted records
| extend Details = parse_xml(EventData)
| extend FilePath = tostring(Details.UserData.RuleAndFileData.FilePath)
| extend FileHash = tostring(Details.UserData.RuleAndFileData.FileHash)
| summarize count() by FileHash, FilePath
```

Запросы, содержащие предложения [WHERE](/azure/kusto/query/whereoperator) для вычисляемого столбца, а не для столбцов, которые физически находятся в наборе данных, теряют эффективность. Фильтрация по вычисляемым столбцам предотвращает некоторые системные оптимизации при обработке больших наборов данных.
Например, следующие запросы дают тот же результат, но второй является более эффективным, так как условие [WHERE](/azure/kusto/query/whereoperator) ссылается на встроенный столбец.

```Kusto
//less efficient
Heartbeat 
| extend IPRegion = iif(RemoteIPLongitude  < -94,"WestCoast","EastCoast")
| where IPRegion == "WestCoast"
| summarize count() by Computer
```
```Kusto
//more efficient
Heartbeat 
| where RemoteIPLongitude  < -94
| extend IPRegion = iif(RemoteIPLongitude  < -94,"WestCoast","EastCoast")
| summarize count() by Computer
```

Хотя некоторые команды статистической обработки, такие как [Max ()](/azure/kusto/query/max-aggfunction), [Sum ()](/azure/kusto/query/sum-aggfunction), [Count ()](/azure/kusto/query/count-aggfunction)и [AVG ()](/azure/kusto/query/avg-aggfunction) , имеют низкую нагрузку на ЦП из-за их логики, другие являются более сложными и включают эвристику и оценки, которые позволяют эффективно выполнять их. Например, функция [DCount ()](/azure/kusto/query/dcount-aggfunction) использует алгоритм хиперлоглог, чтобы предоставить более четкое оценочное число больших наборов данных без фактического учета каждого значения. функции процентиля выполняют аналогичные приближения с использованием ближайшего алгоритма оценки процентиля. Некоторые команды включают необязательные параметры, которые снижают их влияние. Например, функция [make ()](/azure/kusto/query/makeset-aggfunction) имеет необязательный параметр, определяющий максимальный размер набора, который значительно влияет на ЦП и память.

Команды [Join](/azure/kusto/query/joinoperator?pivots=azuremonitor) и [обобщить](/azure/kusto/query/summarizeoperator) могут привести к высокой загрузке ЦП при обработке большого набора данных. Их сложность напрямую связана с количеством возможных значений, которые называются количеством *столбцов, которые*используются в качестве `by` в итогах или в качестве атрибутов объединения. Объяснение и оптимизация объединения и суммирования см. в документации и советах по оптимизации.

Например, следующие запросы создают точно такой же результат, так как **каунтерпас** всегда сопоставляется с **CounterName** и **objectname**. Второй из них более эффективен, так как размер статистического измерения меньше:

```Kusto
//less efficient
Perf
| summarize avg(CounterValue) 
by CounterName, CounterPath, ObjectName
```
```Kusto
//make the group expression more compact improve the performance
Perf
| summarize avg(CounterValue), any(CounterName), any(ObjectName) 
by CounterPath
```

Потребление ресурсов ЦП также может затронуть условием расположения или расширенными столбцами, требующими интенсивного вычисления. Все тривиальные сравнения строк, такие как [EQUAL = =](/azure/kusto/query/datatypes-string-operators) и [StartsWith](/azure/kusto/query/datatypes-string-operators) , имеют примерно одинаковое воздействие на ЦП, в то время как расширенные совпадения текста имеют больше влияния. В частности, оператор [имеет](/azure/kusto/query/datatypes-string-operators) более эффективный оператор [Contains](/azure/kusto/query/datatypes-string-operators) . Из-за методов обработки строк более эффективным является поиск строк, длина которых превышает четыре символа, чем короткие строки.

Например, следующие запросы дают аналогичные результаты, в зависимости от политики именования компьютеров, но второй из них является более эффективным:

```Kusto
//less efficient – due to filter based on contains
Heartbeat
| where Computer contains "Production" 
| summarize count() by ComputerIP 
```
```Kusto
//less efficient – due to filter based on extend
Heartbeat
| extend MyComputer = Computer
| where MyComputer startswith "Production" 
| summarize count() by ComputerIP 
```
```Kusto
//more efficient
Heartbeat
| where Computer startswith "Production" 
| summarize count() by ComputerIP 
```

> [!NOTE]
> Этот индикатор представляет только ЦП из мгновенного кластера. В многоязыковых запросах он будет представлять только один из регионов. В запросе с несколькими рабочими областями он может не включать все рабочие области.


## <a name="data-used-for-processed-query"></a>Данные, используемые для обработанного запроса

Важным фактором при обработке запроса является объем данных, которые просматриваются и используются для обработки запросов. Azure обозреватель данных использует агрессивные оптимизации, что значительно сокращает объем данных по сравнению с другими платформами данных. Тем не менее в запросе имеются критические факторы, которые могут повлиять на используемый объем данных.
В журналах Azure Monitor столбец **timegenerated** используется в качестве способа индексирования данных. Ограничение значений **timegenerated** таким образом, чтобы максимально сократить диапазон, может значительно повысить производительность запросов, значительно ограничивая объем данных, которые должны быть обработаны.

Другой фактор, увеличивающий объем обрабатываемых данных, — использование большого количества таблиц. Обычно это происходит при использовании команд `search *` и `union *`. Эти команды заставляют систему оценивать и проверять данные из всех таблиц в рабочей области. В некоторых случаях в рабочей области могут быть сотни таблиц. Старайтесь не столько, сколько возможно, используя "Поиск *" или любой поиск, не выполняя его с определенной таблицей.

Например, следующие запросы выдают точно такой же результат, но последний из них является наиболее эффективным:

```Kusto
// This version scans all tables though only Perf has this kind of data
search "Processor Time" 
| summarize count(), avg(CounterValue)  by Computer
```
```Kusto
// This version scans all strings in Perf tables – much more efficient
Perf
| search "Processor Time" 
| summarize count(), avg(CounterValue)  by Computer
```
```Kusto
// This is the most efficient version 
Perf 
| where CounterName == "% Processor Time"  
| summarize count(), avg(CounterValue)  by Computer
```

Другим методом уменьшения объема данных является [Размещение](/azure/kusto/query/whereoperator) условий в начале запроса. Платформа обозреватель данных Azure включает в себя кэш, позволяющий понять, какие секции содержат данные, относящиеся к конкретному условию WHERE. Например, если запрос содержит `where EventID == 4624` то он будет распределять запрос только на узлы, обрабатывающие секции с совпадающими событиями.

В следующем примере запросы выдаются точно так же, но второй из них более эффективен:

```Kusto
//less efficient
SecurityEvent
| summarize LoginSessions = dcount(LogonGuid) by Account
```
```Kusto
//more efficient
SecurityEvent
| where EventID == 4624 //Logon GUID is relevant only for logon event
| summarize LoginSessions = dcount(LogonGuid) by Account
```

Так как Azure обозреватель данных представляет собой хранилище данных по столбцам, извлечение всех столбцов не зависит от других. Число извлекаемых столбцов напрямую влияет на общий объем данных. Следует включать в выходные данные только те столбцы, которые необходимы для [суммирования](/azure/kusto/query/summarizeoperator) результатов или [проецирования](/azure/kusto/query/projectoperator) конкретных столбцов. Обозреватель данных Azure имеет несколько оптимизаций для уменьшения числа извлеченных столбцов. Если он определяет, что столбец не требуется, например если на него нет ссылки в команде [обобщить](/azure/kusto/query/summarizeoperator) , он не будет извлекать его.

Например, второй запрос может обрабатывать три раза больше данных, поскольку ему нужно получить не один столбец, но три:

```Kusto
//Less columns --> Less data
SecurityEvent
| summarize count() by Computer  
```
```Kusto
//More columns --> More data
SecurityEvent
| summarize count(), dcount(EventID), avg(Level) by Computer  
```

## <a name="time-span-of-the-processed-query"></a>Интервал времени обработанного запроса

Все журналы в журналах Azure Monitor секционированы в соответствии со столбцом **timegenerated** . Количество секций, к которым осуществляется доступ, напрямую связано с интервалом времени. Сокращение диапазона времени является наиболее эффективным способом подтверждения выполнения запроса.

Диапазон времени можно задать с помощью селектора диапазона времени на экране Log Analytics, как описано в разделе [область запроса журнала и диапазон времени в Azure Monitor log Analytics](scope.md#time-range). Это рекомендуемый метод, так как выбранный диапазон времени передается серверной части с помощью метаданных запроса. 

Альтернативным методом является явное включение в запрос условия [WHERE](/azure/kusto/query/whereoperator) для **timegenerated** . Этот метод следует использовать, так как он гарантирует, что временной диапазон является фиксированным, даже если запрос используется из другого интерфейса.
Необходимо убедиться, что все части запроса имеют фильтры **timegenerated** . Если запрос содержит вложенные запросы, извлекающие данные из различных таблиц или одной таблицы, каждая из них должна содержать собственное условие [WHERE](/azure/kusto/query/whereoperator) .

Например, в следующем запросе, в то время как таблица **производительности** будет проверяться только за последний день, таблица **пульса** будет проверяться на предмет всех ее журналов, что может быть не более двух лет:

```Kusto
Perf
| where TimeGenerated > ago(1d)
| summarize avg(CounterValue) by Computer, CounterName
| join kind=leftouter (
    Heartbeat
    //No time span filter in this part of the query
    | summarize IPs = makeset(ComputerIP, 10) by  Computer
) on Computer
```

Обычно такая ошибка возникает, когда [arg_max ()](/azure/kusto/query/arg-max-aggfunction) используется для поиска последнего вхождения. Пример:

```Kusto
Perf
| where TimeGenerated > ago(1d)
| summarize avg(CounterValue) by Computer, CounterName
| join kind=leftouter (
    Heartbeat
    //No time span filter in this part of the query
    | summarize arg_max(TimeGenerated, *), min(TimeGenerated)   
by Computer
) on Computer
```

Это можно легко исправить, добавив фильтр времени во внутренний запрос:

```Kusto
Perf
| where TimeGenerated > ago(1d)
| summarize avg(CounterValue) by Computer, CounterName
| join kind=leftouter (
    Heartbeat
    | where TimeGenerated > ago(1d) //filter for this part
    | summarize arg_max(TimeGenerated, *), min(TimeGenerated)   
by Computer
) on Computer
```

Еще один пример для этой ошибки — выполнение фильтрации области времени сразу после [объединения](/azure/kusto/query/unionoperator?pivots=azuremonitor) нескольких таблиц. При выполнении объединения каждый вложенный запрос должен быть ограничен. Для обеспечения согласованности области можно использовать инструкцию [let](/azure/kusto/query/letstatement) .

Например, следующий запрос проверит все данные в таблицах *пульса* и *производительности* , а не только за последний день:

```Kusto
Heartbeat 
| summarize arg_min(TimeGenerated,*) by Computer
| union (
    Perf 
    | summarize arg_min(TimeGenerated,*) by Computer) 
| where TimeGenerated > ago(1d)
| summarize min(TimeGenerated) by Computer
```

Этот запрос следует исправить следующим образом:

```Kusto
let MinTime = ago(1d);
Heartbeat 
| where TimeGenerated > MinTime
| summarize arg_min(TimeGenerated,*) by Computer
| union (
    Perf 
    | where TimeGenerated > MinTime
    | summarize arg_min(TimeGenerated,*) by Computer) 
| summarize min(TimeGenerated) by Computer
```

Измерение всегда будет больше указанного фактического времени. Например, если фильтр для запроса составляет 7 дней, система может проверить 7,5 или 8,1 дней. Это связано с тем, что система разделяет данные на фрагменты в переменной размере. Чтобы гарантировать сканирование всех соответствующих записей, оно сканирует весь раздел, который может охватывать несколько часов и даже более суток.

Существует несколько случаев, когда система не может обеспечить точное измерение диапазона времени. Это происходит в большинстве случаев, когда диапазон запроса меньше дня или в запросах из нескольких рабочих областей.


> [!IMPORTANT]
> Этот индикатор представляет только данные, обработанные в мгновенном кластере. В многоязыковых запросах он будет представлять только один из регионов. В запросе с несколькими рабочими областями он может не включать все рабочие области.

## <a name="age-of-processed-data"></a>Возраст обработанных данных
Azure обозреватель данных использует несколько уровней хранилища: в памяти, на локальных дисках SSD и в более медленных больших двоичных объектах Azure. Чем более новые данные, тем выше вероятность того, что она будет храниться на более производительном уровне с меньшими задержками, уменьшая длительность запроса и ЦП. Кроме самих данных, система также имеет кэш для метаданных. Чем выше данные, тем меньше вероятность того, что метаданные будут находиться в кэше.

Хотя некоторые запросы нуждаются в использовании старых данных, бывают случаи, когда старые данные используются по ошибке. Это происходит, когда запросы выполняются без предоставления диапазона времени в своих метаданных, а не все ссылки на таблицы включают фильтр по столбцу **timegenerated** . В таких случаях система проверит все данные, хранящиеся в этой таблице. Если срок хранения данных велик, он может охватывать длинные диапазоны времени и, таким образом, данные, которые являются старыми в качестве срока хранения данных.

Например, можно использовать следующие варианты:

- Не устанавливайте диапазон времени в Log Analytics с неограниченным вложенным запросом. пример выше.
- Использование API без необязательных параметров временного диапазона.
- Использование клиента, который не выполняет принудительный период времени, например Power BI соединителя.

См. примеры и примечания в разделе предыдущей, так как они также важны в этом случае.

## <a name="number-of-regions"></a>Число регионов
Существует несколько ситуаций, когда один запрос может выполняться в разных регионах:

- Если несколько рабочих областей указаны явно, они находятся в разных регионах.
- Когда запрос с областью действия ресурса извлекает данные, и данные хранятся в нескольких рабочих областях, расположенных в разных регионах.

Для выполнения запросов между регионами требуется, чтобы система была сериализована и передана в серверных больших фрагментах промежуточных данных, которые обычно гораздо больше, чем окончательные результаты запроса. Кроме того, она ограничивает способность системы выполнять оптимизацию, эвристику и использование кэшей.
Если нет реальной причины для проверки всех этих регионов, следует настроить область так, чтобы она охватывает меньшее количество регионов. Если область действия ресурса минимальна, но по-прежнему используется много регионов, это может произойти из-за ненужной настройки. Например, журналы аудита и параметры диагностики отправляются в разные рабочие области в разных регионах или несколько конфигураций параметров диагностики. 

> [!IMPORTANT]
> Если запрос выполняется в нескольких регионах, измерения ЦП и данных будут неточными и будут представлять измерение только в одном из регионов.

## <a name="number-of-workspaces"></a>Число рабочих областей
Рабочие области — это логические контейнеры, которые используются для разделения и администрирования данных журналов. Серверная часть оптимизирует размещение рабочих областей в физических кластерах в выбранном регионе.

Использование нескольких рабочих областей может быть результатом: 

- Если несколько рабочих областей указаны явно.
- Когда запрос с областью действия ресурса извлекает данные, и данные хранятся в нескольких рабочих областях.
 
Для выполнения запросов между регионами и между кластерами требуется, чтобы система была сериализована и передана в серверных больших фрагментах промежуточных данных, которые обычно гораздо больше, чем окончательные результаты запроса. Он также ограничивает возможности системы для выполнения оптимизации, эвристики и использования кэшей.

> [!IMPORTANT]
> В некоторых сценариях с несколькими рабочими областями ЦП и данные не будут точными и будут представлять измерение только для некоторых рабочих областей.

## <a name="parallelism"></a>Parallelism
Журналы Azure Monitor используют большие кластеры обозреватель данных Azure для выполнения запросов, и эти кластеры различаются в масштабе, что может привести к увеличению числа узлов вычислений. Система автоматически масштабирует кластеры в соответствии с логикой и емкостью размещения рабочей области.

Для эффективного выполнения запроса он секционируется и распределяется по вычислительным узлам на основе данных, необходимых для обработки. В некоторых ситуациях система не может эффективно сделать это. Это может привести к длительной длительности запроса. 

Варианты поведения запросов, которые могут сократить параллелизм, включают:

- Использование сериализации и оконных функций, таких как [оператор сериализации](/azure/kusto/query/serializeoperator), [Next ()](/azure/kusto/query/nextfunction), [prev ()](/azure/kusto/query/prevfunction)и функций [строк](/azure/kusto/query/rowcumsumfunction) . В некоторых случаях можно использовать временные ряды и функции анализа пользователей. Неэффективная сериализация также может возникнуть, если следующие операторы используются не в конце запроса: [Range](/azure/kusto/query/rangeoperator), [Sort](/azure/kusto/query/sortoperator), [Order](/azure/kusto/query/orderoperator), [Top](/azure/kusto/query/topoperator), [Top-hitters](/azure/kusto/query/tophittersoperator), [GetSchema](/azure/kusto/query/getschemaoperator).
-   Использование функции агрегирования [DCount ()](/azure/kusto/query/dcount-aggfunction) заставляет систему иметь центральную копию уникальных значений. Когда масштаб данных высок, рассмотрите возможность использования необязательных параметров функции DCount для снижения точности.
-   Во многих случаях оператор [Join](/azure/kusto/query/joinoperator?pivots=azuremonitor) снижает общий параллелизм. Изучите случайное соединение в качестве альтернативы при возникновении проблем с производительностью.
-   В запросах, выполняемых в контексте ресурсов, предварительные проверки RBAC могут быть ограничены в ситуациях, когда имеется очень большое количество назначений RBAC. Это может привести к более длинным проверкам, которые приведут к более низкому параллелизму. Например, запрос выполняется в подписке, в которой есть тысячи ресурсов, и каждый ресурс имеет много назначений ролей на уровне ресурса, а не в подписке или группе ресурсов.
-   Если запрос обрабатывает небольшие фрагменты данных, его параллелизм будет небольшим, так как система не будет распределять их между несколькими вычислительными узлами.



## <a name="next-steps"></a>Дальнейшие действия

- [Справочная документация по языку запросов Kusto](/azure/kusto/query/).
