---
title: Перенос таблиц базы данных SQL Azure в Azure CosmosDB с помощью фабрики данных Azure
description: Возьмите существующую нормализованную схему базы данных из базы данных SQL Azure и перенесите ее в Денормализованный контейнер Azure CosmosDB с помощью фабрики данных Azure.
services: data-factory
author: kromerm
ms.service: data-factory
ms.workload: data-services
ms.topic: conceptual
ms.date: 04/29/2020
ms.author: makromer
ms.openlocfilehash: 3d2ef6fb0cd7af444b9bff755eee4eee70d03d15
ms.sourcegitcommit: 366e95d58d5311ca4b62e6d0b2b47549e06a0d6d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/01/2020
ms.locfileid: "82691903"
---
# <a name="migrate-normalized-database-schema-from-azure-sql-database-to-azure-cosmosdb-denormalized-container"></a>Перенос нормализованной схемы базы данных из базы данных SQL Azure в Денормализованный контейнер Azure CosmosDB

В этом руководство объясняется, как взять существующую нормализованную схему базы данных в базе данных SQL Azure и преобразовать ее в денормализованную схему Azure CosmosDB для загрузки в Azure CosmosDB.

Схемы SQL обычно моделируются с помощью третьей нормальной формы, что приводит к нормализованным схемам, обеспечивающим высокий уровень целостности данных и меньшего количества повторяющихся значений данных. Запросы могут соединять сущности вместе между таблицами для чтения. CosmosDB оптимизирован для очень быстрых транзакций и запросов в коллекции или контейнере через денормализованные схемы с самодостаточными данными внутри документа.

С помощью фабрики данных Azure мы создадим конвейер, использующий единый поток данных сопоставления для чтения из двух нормализованных таблиц базы данных SQL Azure, содержащих первичные и внешние ключи в связи сущностей. ADF присоединяет эти таблицы к одному потоку с помощью подсистемы Spark потока данных, собирайте объединенные строки в массивы и создает отдельные очищенные документы для вставки в новый контейнер Azure CosmosDB.

В этом руководством будет создан новый контейнер с именем "заказы", который будет использовать таблицы ```SalesOrderHeader``` и ```SalesOrderDetail``` из образца базы данных SQL Server AdventureWorks. Эти таблицы представляют собой транзакции, Соединенные ```SalesOrderID```по продажам. Каждая уникальная запись сведений имеет собственный первичный ключ ```SalesOrderDetailID```. Отношение между заголовком и данными ```1:M```имеет значение. Мы будем присоединяться ```SalesOrderID``` к ADF, а затем перейдем каждую связанную детальную запись в массив с именем «Detail».

Репрезентативный SQL-запрос для этого руководство:

```
  SELECT
  o.SalesOrderID,
  o.OrderDate,
  o.Status,
  o.ShipDate,
  o.SalesOrderNumber,
  o.ShipMethod,
  o.SubTotal,
  (select SalesOrderDetailID, UnitPrice, OrderQty from SalesLT.SalesOrderDetail od where od.SalesOrderID = o.SalesOrderID for json auto) as OrderDetails
FROM SalesLT.SalesOrderHeader o;
```

Результирующий контейнер CosmosDB внедряет внутренний запрос в один документ и будет выглядеть следующим образом:

![Коллекция](media/data-flow/cosmosb3.png)

## <a name="create-a-pipeline"></a>Создание конвейера

1. Выберите **+ создать конвейер** , чтобы создать новый конвейер.

2. Добавление действия потока данных

3. В действии поток данных выберите **создать сопоставление поток данных**.

4. Эта диаграмма потока данных будет построена ниже

![Диаграмма потока данных](media/data-flow/cosmosb1.png)

5. Определите источник "Саурцеордердетаилс". Для набора данных создайте новый набор данных базы данных SQL Azure, указывающий ```SalesOrderDetail``` на таблицу.

6. Определите источник "Саурцеордерхеадер". Для набора данных создайте новый набор данных базы данных SQL Azure, указывающий ```SalesOrderHeader``` на таблицу.

7. В верхнем источнике добавьте преобразование «Производный столбец» после «Саурцеордердетаилс». Вызовите новое преобразование «приведение типа». Необходимо округлить ```UnitPrice``` столбец и привести его к типу данных Double для CosmosDB. Задайте формулу: ```toDouble(round(UnitPrice,2))```.

8. Добавьте еще один производный столбец и вызовите его «Макеструкт». Здесь мы создадим иерархическую структуру для хранения значений из таблицы Details. Помните, что сведения являются ```M:1``` отношением к заголовку. Назовите новую структуру ```orderdetailsstruct``` и создайте иерархию таким образом, задав каждому подстолбцу имя входящего столбца:

![Создание структуры](media/data-flow/cosmosb9.png)

9. Теперь давайте перейдем к источнику заголовка продаж. Добавьте преобразование «соединение». Для правой части выберите "Макеструкт". Оставьте значение внутреннее соединение и выберите ```SalesOrderID``` для обеих сторон условия объединения.

10. Щелкните вкладку Предварительный просмотр данных в новом добавленном соединении, чтобы просмотреть результаты до этой точки. Вы должны увидеть все строки заголовка, Соединенные со строками детализации. Это результат объединения, сформированного из ```SalesOrderID```. Далее мы будем объединять сведения из общих строк в структуру Details и объединять общие строки.

![Join](media/data-flow/cosmosb4.png)

11. Прежде чем создавать массивы для денормализации этих строк, необходимо удалить ненужные столбцы и убедиться, что значения данных будут соответствовать типам данных CosmosDB.

12. Добавьте преобразование «выбор» и задайте сопоставление поля следующим образом:

![Очистка столбца](media/data-flow/cosmosb5.png)

13. Теперь давайте снова приведите столбец валюты, на этот раз ```TotalDue```. Как мы делали на шаге 7, задайте формулу: ```toDouble(round(TotalDue,2))```.

14. Здесь мы будем денормализовать строки, группируя их по общему ключу ```SalesOrderID```. Добавьте преобразование «Статистическая обработка» и задайте для ```SalesOrderID```параметра Group By значение.

15. В статистической формуле добавьте новый столбец с именем "Details" (сведения) и используйте эту формулу для сбора значений в структуре, созданной ранее с названием ```orderdetailsstruct```: ```collect(orderdetailsstruct)```.

16. Преобразование «Статистическая обработка» будет выводить только столбцы, которые являются частью статистических выражений или группирования по формулам. Поэтому необходимо также включить столбцы из заголовка Sales. Для этого добавьте шаблон столбца в то же преобразование «Статистическая обработка». Этот шаблон будет включать все остальные столбцы в выходных данных:

```instr(name,'OrderQty')==0&&instr(name,'UnitPrice')==0&&instr(name,'SalesOrderID')==0```

17. Используйте синтаксис "this" в других свойствах, чтобы сохранить одни и те же имена столбцов и использовать ```first()``` функцию в качестве статистического выражения:

![Статистическое](media/data-flow/cosmosb6.png)

18. Мы готовы завершить процесс миграции, добавив преобразование приемника. Щелкните "создать" рядом с набором данных и добавьте набор данных CosmosDB, указывающий на базу данных CosmosDB. Для коллекции мы назовем «Orders», и она не будет иметь схемы и документов, так как она будет создана на лету.

19. В разделе параметры приемника, ключ ```\SalesOrderID``` секции и действие сбора — "повторное создание". Убедитесь, что вкладка Сопоставление выглядит следующим образом:

![Параметры приемника](media/data-flow/cosmosb7.png)

20. Щелкните Предварительный просмотр данных, чтобы убедиться, что следующие 32 строк отображаются в качестве новых документов в новом контейнере.

![Параметры приемника](media/data-flow/cosmosb8.png)

Если все выглядит хорошо, теперь все готово для создания нового конвейера, добавления этого действия потока данных в этот конвейер и его выполнения. Можно выполнить из отладки или запуска триггера. Через несколько минут в базе данных CosmosDB должен быть новый Денормализованный контейнер заказов, именуемый "заказы".

## <a name="next-steps"></a>Дальнейшие действия

* Создайте оставшуюся часть логики потока данных с помощью [преобразования потоков данных](concepts-data-flow-overview.md)сопоставления.
* [Скачайте шаблон завершенного конвейера](https://github.com/kromerm/adfdataflowdocs/blob/master/sampledata/SQL%20Orders%20to%20CosmosDB.zip) для этого руководства и импортируйте шаблон в фабрику.
