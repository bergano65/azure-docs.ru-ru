---
title: Профилирование приложений в рабочей среде Azure с помощью Application Insights Profiler | Документация Майкрософт
description: Определите критический путь в коде веб-сервера с помощью профилировщика небольшого размера.
services: application-insights
documentationcenter: ''
author: mrbullwinkle
manager: carmonm
ms.service: application-insights
ms.workload: tbd
ms.tgt_pltfrm: ibiza
ms.devlang: na
ms.topic: conceptual
ms.reviewer: cawa
ms.date: 08/06/2018
ms.author: mbullwin
ms.openlocfilehash: bba15ee901e7ccecc513f526339bde2fcc6277fa
ms.sourcegitcommit: 0f54b9dbcf82346417ad69cbef266bc7804a5f0e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/26/2018
ms.locfileid: "50142971"
---
# <a name="profile-production-applications-in-azure-with-application-insights"></a>Профилирование приложений в рабочей среде Azure с помощью Application Insights Profiler
## <a name="enable-profiler-for-your-application"></a>Включение профилировщика для приложений

Application Insights Profiler предоставляет трассировки производительности приложений, выполняющихся в рабочей среде Azure. Он автоматически выполняет сбор данных в большом масштабе, не осложняя работу пользователей. Профилировщик поможет найти критический путь кода, выполнение которого занимает больше всего времени при обработке отдельных веб-запросов. 

Профилировщик работает с приложениями .Net, развернутыми на следующие службах Azure. Конкретные инструкции по включению профилировщика для службы каждого типа вы найдете по приведенным ниже ссылкам.

* [Службы приложений](app-insights-profiler.md?toc=/azure/azure-monitor/toc.json)
* [Облачные службы](app-insights-profiler-cloudservice.md?toc=/azure/azure-monitor/toc.json)
* [Приложения Service Fabric](app-insights-profiler-servicefabric.md?toc=/azure/azure-monitor/toc.json)
* [Виртуальные машины и масштабируемые наборы виртуальных машин](app-insights-profiler-vm.md?toc=/azure/azure-monitor/toc.json)

Если вы уже включили Profiler, но трассировки не отображаются, проверьте [Руководство по устранению неполадок.](app-insights-profiler-troubleshooting.md?toc=/azure/azure-monitor/toc.json)

Выполнение Profiler на локальном компьютере официально не поддерживается, но вы можете попробовать запустить его, выполнив [эти инструкции](https://docs.microsoft.com/azure/application-insights/enable-profiler-compute#enable-profiler-on-on-premises-servers).

## <a name="view-profiler-data"></a>Просмотр данных профилировщика

Чтобы профилировщик смог отправлять трассировки, приложение должно активно обрабатывать запросы. Для эксперимента запросы к веб-приложению можно создать [в рамках тестирования производительности Application Insights](https://docs.microsoft.com/vsts/load-test/app-service-web-app-performance-test). Если вы только что включили Profiler, запустите короткий нагрузочный тест. Во время выполнения нагрузочного теста нажмите кнопку **Профилировать** на [**странице параметров профилировщика**](). После запуска профилировщик будет случайным образом выбирать время для сбора данных, примерно по две минуты один раз в час. Если приложение обрабатывает устойчивый поток запросов, Profiler отправляет трассировки каждый час.

После того как приложение получит некоторый объем трафика, а профилировщик — достаточное время для передачи трассировок, вы получите возможность их просмотреть. Этот процесс может занять от 5 до 10 минут. Чтобы просмотреть трассировки, откройте панель **Производительность**, перейдите к разделу **Take Actions** (Предпринять действия), чтобы просмотреть трассировки профилировщика, а затем нажмите кнопку **Profiler Traces** (Трассировки Profiler).

![Кнопка Profiler traces (Трассировки Profiler) в области Preview Performance (Производительность предварительной версии) Application Insights][performance-blade]

Выберите пример, чтобы отобразить классификацию на уровне кода по времени, затраченному на выполнение запроса.

![Обозреватель трассировки Application Insights][trace-explorer]

Обозреватель трассировки отображает следующие сведения:

* **Показать критический путь** — открывает основной листовой узел или хотя бы что-то с ним связанное. В большинстве случаев этот узел находится рядом с узким местом производительности.
* **Метка** — имя функции или события. В дереве отображается сочетание кода и возникающих событий (например, события SQL и HTTP). Основное событие предоставляет общую длительность запроса.
* **Истекло** — интервал времени между началом и завершением операции.
* **Когда** — время запуска функции или события по отношению к другим функциям.

## <a name="how-to-read-performance-data"></a>Чтение данных о производительности

Профилировщик службы Майкрософт использует метод выборки в сочетании с инструментированием для анализа производительности приложения. Во время подробной сборки профилировщик службы каждую миллисекунду проводит выборку указателя инструкций для всех ЦП компьютера. Каждый пример записывает полный стек вызовов выполняющегося потока. Он предоставляет подробные сведения об этом потоке на высоком и низком уровне абстракции. Профилировщик службы также собирает сведения о других событиях, включая события переключения контекста, библиотеки параллельных задач (TPL) и пула потоков, для отслеживания корреляции действий и причинно-следственных связей.

Стек вызовов, отображаемый в представлении временной шкалы, является результатом выборки и инструментирования. Так как каждый пример записывает полный стек вызовов потока, он содержит код из Microsoft .NET Framework, а также из других указанных вами платформ.

### <a id="jitnewobj"></a>Выделение объектов (clr!JIT\_New или clr!JIT\_Newarr1)

**clr!JIT\_New** и **clr!JIT\_Newarr1** — это вспомогательные функции в .NET Framework, выделяющие память из управляемой кучи. **clr!JIT\_New** вызывается при выделении объекта. **clr!JIT\_Newarr1** вызывается при выделении массива объектов. Обычно эти две функции выполняются быстро за относительно небольшое время. Если функции **clr!JIT\_New** или **clr!JIT\_Newarr1** занимают довольно много времени во временной шкале, это указывает на то, что код, возможно, выделяет несколько объектов и потребляет значительный объем памяти.

### <a id="theprestub"></a>Код загрузки (clr!ThePreStub)

**clr!ThePreStub** — это вспомогательная функция в .NET Framework, подготавливающая код к первому выполнению. Как правило, она включает в себя JIT-компиляцию, но не ограничивается ею. Для каждого метода C# **clr!ThePreStub** должна вызываться только один раз в течение всего времени существования процесса.

Если выполнение **clr!ThePreStub** при запросе занимает много времени, значит этот метод выполняется впервые. На загрузку первого метода требуется значительное время работы среды выполнения .NET Framework. Вы можете использовать процесс прогрева, выполняющий эту часть кода до предоставления к нему доступа пользователям, или запустить генератор образа в машинном коде (ngen.exe) в сборках.

### <a id="lockcontention"></a>Конфликт блокировки (clr!JITutil\_MonContention или clr!JITutil\_MonEnterWorker)

**clr!JITutil\_MonContention** или **clr!JITutil\_MonEnterWorker** указывает, что текущий поток ожидает снятия блокировки. Этот текст обычно отображается при выполнении команды **LOCK** языка C# путем вызова метода **Monitor.Enter** или метода с атрибутом **MethodImplOptions.Synchronized**. Конфликт блокировки обычно происходит при получении блокировки потоком _A_, а также при попытке получить ту же блокировку потоком _Б_ до ее снятия потоком _A_.

### <a id="ngencold"></a>Код загрузки ([COLD])

Если имя метода содержит **[COLD]**, например **mscorlib.ni![COLD]System.Reflection.CustomAttribute.IsDefined**, это значит, что в среде выполнения .NET Framework впервые выполняется код, оптимизация которого не осуществилась с помощью <a href="https://msdn.microsoft.com/library/e7k32f4k.aspx">профильной оптимизации</a>. Для каждого метода он должен отображаться только один раз в течение всего времени существования процесса.

Если коду загрузки требуется значительное время на запрос, это значит, что запрос впервые выполняет неоптимизированную часть метода. Вы можете использовать процесс прогрева, который выполняет эту часть кода до предоставления к нему доступа пользователям.

### <a id="httpclientsend"></a>Отправка HTTP-запроса

Методы, такие как **HttpClient.Send**, указывают на то, что код ожидает завершения HTTP-запроса.

### <a id="sqlcommand"></a>Операция с базой данных

Методы, такие как **SqlCommand.Execute**, указывают на то, что код ожидает завершения операции с базой данных.

### <a id="await"></a>Ожидание (AWAIT\_TIME)

**AWAIT\_TIME** указывает на то, что код ожидает завершения другой задачи. Обычно это осуществляется с помощью команды **AWAIT** языка C#. Когда код выполняет команду C# **AWAIT**, поток освобождается и возвращает управление пулу потоков, то есть ни один поток не блокируется в ожидании завершения **AWAIT**. Однако если рассуждать логически, то поток, который выполнил команду **AWAIT**, "заблокирован" и ожидает завершения операции. Команда **AWAIT\_TIME** указывает время блокировки в ожидании завершения задачи.

### <a id="block"></a>Время блокировки

**BLOCKED_TIME** указывает на то, что код ожидает, пока другой ресурс станет доступным. Например, он может ожидать объект синхронизации, или когда поток станет доступным, или когда завершится запрос.

### <a id="cpu"></a>Время ЦП

ЦП занят выполнением инструкций.

### <a id="disk"></a>Время работы диска

Приложение выполняет операции с диском.

### <a id="network"></a>Сетевое время

Приложение выполняет сетевые операции.

### <a id="when"></a>Столбец "Время"

Столбец **Когда** — это визуальное представление того, как со временем изменяются выборки INCLUSIVE, собранные для узла. Общий диапазон запроса состоит из 32 временных периодов. В них накапливаются включающие выборки для данного узла. Каждый период представляется в виде полосы. Высота полосы обозначает масштабированное значение. Для узлов, помеченных как **CPU_TIME** или **BLOCKED_TIME**, или когда существует очевидная связь с потреблением ресурсов (например, ЦП, диск или поток), в полосе представлено использование одного из этих ресурсов за определенный период времени. Для этих метрик можно получить значение, превышающее 100 процентов, за счет потребления нескольких ресурсов. Например, если в среднем за определенный интервал времени используется два процессора, то показатель достигнет 200 процентов.

## <a name="limitations"></a>Ограничения

Срок хранения данных по умолчанию — пять дней. Максимальный объем ежедневно обрабатываемых данных — 10 ГБ.

За использование службы профилировщика плата не взимается. Для использования службы профилировщика веб-приложение должно быть размещено по крайней мере на уровне "Базовый" компонента "Веб-приложения".

## <a name="overhead-and-sampling-algorithm"></a>Дополнительная нагрузка и алгоритм выборки

Раз в час профилировщик запускается случайным образом на две минуты на каждой виртуальной машине, где размещено приложение, для сбора трассировок которого настроен профилировщик. При запуске профилировщик увеличивает нагрузку на ресурсы ЦП сервера на 5–15 процентов.

## <a name="next-steps"></a>Дальнейшие действия
Включите Application Insights Profiler для приложения Azure
* [Службы приложений](app-insights-profiler.md?toc=/azure/azure-monitor/toc.json)
* [Облачные службы](app-insights-profiler-cloudservice.md?toc=/azure/azure-monitor/toc.json)
* [Приложения Service Fabric](app-insights-profiler-servicefabric.md?toc=/azure/azure-monitor/toc.json)
* [Виртуальные машины и масштабируемые наборы виртуальных машин](app-insights-profiler-vm.md?toc=/azure/azure-monitor/toc.json)


[performance-blade]: ./media/app-insights-profiler/performance-blade-v2-examples.png
[trace-explorer]: ./media/app-insights-profiler/trace-explorer.png
