---
title: Типы проблем производительности запросов в базе данных SQL Azure
description: В этой статье вы узнаете о типах проблем производительности запросов в базе данных SQL Azure, а также о том, как определить и устранить запросы с этими проблемами.
services: sql-database
ms.service: sql-database
ms.subservice: performance
ms.custom: ''
ms.devlang: ''
ms.topic: troubleshooting
author: jovanpop-msft
ms.author: jovanpop
ms.reviewer: jrasnick, sstein
ms.date: 03/10/2020
ms.openlocfilehash: ce5bf86073b2c478108e264010bb3c213c214368
ms.sourcegitcommit: 400f473e8aa6301539179d4b320ffbe7dfae42fe
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/28/2020
ms.locfileid: "92791755"
---
# <a name="detectable-types-of-query-performance-bottlenecks-in-azure-sql-database"></a>Обнаруживаемые типы узких мест производительности запросов в базе данных SQL Azure
[!INCLUDE[appliesto-sqldb-sqlmi](includes/appliesto-sqldb-sqlmi.md)]

При попытке устранить узкие места производительности Начните с определения того, возникает ли узкие места, пока запрос находится в состоянии выполнения или состоянии ожидания. В зависимости от этого определения применяются различные решения. Используйте следующую схему, чтобы понять факторы, которые могут вызвать проблему, связанную с выполнением, или проблему, связанную с ожиданием. В этой статье рассматриваются проблемы и способы их устранения.

Для выявления узких мест производительности можно использовать базу данных SQL Azure [Intelligent Insights](database/intelligent-insights-troubleshoot-performance.md#detectable-database-performance-patterns) или SQL Server динамические [административные представления](database/monitoring-with-dmvs.md) .

![Состояния рабочей нагрузки](./media/identify-query-performance-issues/workload-states.png)

**Проблемы, связанные с выполнением** . связанные с выполнением проблемы обычно связаны с проблемами компиляции, что приводит к неоптимальному плану запроса или проблемам выполнения, связанным с недостаточными или избыточными ресурсами.
**Проблемы, связанные с ожиданием** : проблемы, связанные с ожиданием, обычно связаны с:

- блокировки;
- Ввод-вывод
- Состязание, связанное с использованием TempDB
- ожидание временно предоставляемого буфера памяти.

## <a name="compilation-problems-resulting-in-a-suboptimal-query-plan"></a>Проблемы компиляции, приводящие к неоптимальному плану запроса

Неоптимальный план, созданный оптимизатором SQL-запросов, может быть причиной снижения производительности запросов. Оптимизатор SQL-запросов может создать неоптимальный план из-за отсутствующего индекса, устаревшей статистики, неверной оценки количества строк для обработки или неточной оценки требуемой памяти. Если вы знаете, что запрос выполнялся быстрее или в другом экземпляре, Сравните фактические планы выполнения, чтобы определить, различаются ли они.

- Выявление отсутствующих индексов с помощью одного из следующих методов:

  - Используйте [Intelligent Insights](database/intelligent-insights-troubleshoot-performance.md#missing-index).
  - [Помощник по базам данных](database/database-advisor-implement-performance-recommendations.md) для баз данных в одной и в составе пула.
  - Динамических административных представлений. В этом примере показано влияние отсутствующего индекса, обнаружение [отсутствующих индексов](database/performance-guidance.md#identifying-and-adding-missing-indexes) с помощью динамических административных представлений и влияние реализации рекомендации по отсутствующим индексам.
- Попробуйте применить [указания запросов](/sql/t-sql/queries/hints-transact-sql-query), [Обновить статистику](/sql/t-sql/statements/update-statistics-transact-sql)или [перестроить индексы](/sql/relational-databases/indexes/reorganize-and-rebuild-indexes) , чтобы получить более подходящий план. Включите [Автоматическое исправление плана](../azure-sql/database/automatic-tuning-overview.md) в базе данных SQL Azure, чтобы автоматически устранить эти проблемы.

  В этом [примере](database/performance-guidance.md#query-tuning-and-hinting) показано влияние неоптимального плана запроса на выполнение параметризованного запроса, определение этого состояния и использование подсказки запроса для разрешения.

- Попробуйте изменить уровень совместимости базы данных и реализовать интеллектуальную обработку запросов. Оптимизатор SQL-запросов может создать другой план запроса в зависимости от уровня совместимости базы данных. Более высокие уровни совместимости обеспечивают более [интеллектуальные возможности обработки запросов](/sql/relational-databases/performance/intelligent-query-processing).

  - Дополнительные сведения об обработке запросов см. в разделе [руководств по архитектуре обработки запросов](/sql/relational-databases/query-processing-architecture-guide).
  - Чтобы изменить уровни совместимости базы данных и прочесть дополнительные сведения о различиях между уровнями совместимости, см. раздел [ALTER DATABASE](/sql/t-sql/statements/alter-database-transact-sql-compatibility-level).
  - Дополнительные сведения об оценке количества элементов см. в статье [Оценка количества элементов](/sql/relational-databases/performance/cardinality-estimation-sql-server) .

## <a name="resolving-queries-with-suboptimal-query-execution-plans"></a>Разрешение запросов с неоптимальными планами выполнения запросов

В следующих разделах описывается, как разрешать запросы с неоптимальным планом выполнения запроса.

### <a name="queries-that-have-parameter-sensitive-plan-psp-problems"></a><a name="ParamSniffing"></a> Запросы с проблемами плана с учетом параметров (PSP)

Проблема с зависящим от параметра планом (PSP) возникает, когда оптимизатор запросов формирует план выполнения запроса, оптимальный только для определенного значения параметра (или набора значений), а кэшированный план не оптимальен для значений параметров, используемых в последовательных выполнениях. Неоптимальные планы могут привести к проблемам с производительностью запросов и снизить общую пропускную способность рабочей нагрузки.

Дополнительные сведения о перехвате параметров и обработке запросов см. в разделе [руководств по архитектуре обработки запросов](/sql/relational-databases/query-processing-architecture-guide#ParamSniffing).

Несколько обходных путей могут устранить проблемы PSP. Каждое решение имеет связанные компромиссы и недостатки.

- Использование указания запроса [RECOMPILE](/sql/t-sql/queries/hints-transact-sql-query) при каждом выполнении запроса. Этот метод позволяет заменить время компиляции и увеличение загрузки ЦП на улучшение качества плана. `RECOMPILE`Параметр часто невозможен для рабочих нагрузок, требующих высокой пропускной способности.
- Используйте указание запроса [Option (оптимизировать для...)](/sql/t-sql/queries/hints-transact-sql-query) , чтобы переопределить фактическое значение параметра, используя стандартное значение параметра, которое создает план, который достаточно подходит для большинства возможностей для значений параметров. Для этого варианта требуется хорошее понимание оптимальных значений параметров и связанных с ними характеристик плана.
- Используйте указание запроса [Option (оптимизация для НЕизвестного)](/sql/t-sql/queries/hints-transact-sql-query) , чтобы переопределить фактическое значение параметра, а вместо этого используйте средний вектор плотности. Это также можно сделать, записывая значения входящих параметров в локальных переменных, а затем используя локальные переменные в предикатах вместо самих параметров. Для этого исправления средняя плотность должна быть *достаточно высокой* .
- Полностью отключите сканирование параметров, используя указание запроса [DISABLE_PARAMETER_SNIFFING](/sql/t-sql/queries/hints-transact-sql-query) .
- Используйте указание запроса [кипфикседплан](/sql/t-sql/queries/hints-transact-sql-query) для предотвращения перекомпиляций в кэше. В этом временном решении предполагается, что в кэше уже есть наиболее подходящий общий план. Можно также отключить автоматическое обновление статистики, чтобы снизить вероятность того, что хороший план будет удален, и будет скомпилирован новый недопустимый план.
- Принудительно применяйте план, явно используя указание запроса [USE PLAN](/sql/t-sql/queries/hints-transact-sql-query) , переписав запрос и добавив указание в текст запроса. Или задайте конкретный план с помощью хранилища запросов или включите [автоматическую настройку](../azure-sql/database/automatic-tuning-overview.md).
- Замена одной процедуры вложенным набором процедур, каждая из которых может использоваться на основе условной логики и связанных значений параметров.
- Создание альтернатив выполнения динамической строки для статического определения процедуры.

Дополнительные сведения об устранении проблем PSP см. в следующих записях блога:

- [Я запахю параметр](/archive/blogs/queryoptteam/i-smell-a-parameter)
- [Сравнение Конор с динамическим SQL и процедурами и качества плана для параметризованных запросов](/archive/blogs/conor_cunningham_msft/conor-vs-dynamic-sql-vs-procedures-vs-plan-quality-for-parameterized-queries)
- [Методы оптимизации запросов SQL в SQL Server: перехват параметров](https://www.sqlshack.com/query-optimization-techniques-in-sql-server-parameter-sniffing/)

### <a name="compile-activity-caused-by-improper-parameterization"></a>Действие компиляции вызвано неправильной параметризации

Если запрос содержит литералы, то либо ядро СУБД автоматически параметризовать инструкцию, либо пользователь явным образом выдает инструкцию, чтобы сократить число компиляций. Большое количество компиляций для запроса, использующее один и тот же шаблон, но разные литеральные значения, могут привести к высокой загрузке ЦП. Аналогичным образом, если только частично параметризовать запрос, который по-своему не содержит литералов, ядро СУБД не будет выполнять дальнейшую параметризацию запроса.

Ниже приведен пример частично параметризованного запроса:

```sql
SELECT *
FROM t1 JOIN t2 ON t1.c1 = t2.c1
WHERE t1.c1 = @p1 AND t2.c2 = '961C3970-0E54-4E8E-82B6-5545BE897F8F'
```

В этом примере `t1.c1` принимает `@p1` , но не принимает `t2.c2` идентификатор GUID в качестве литерала. В этом случае, если изменить значение для `c2` , запрос рассматривается как другой запрос, и произойдет новая компиляция. Чтобы сократить число компиляций в этом примере, можно также параметризовать идентификатор GUID.

Следующий запрос показывает число запросов по хэшу запроса, чтобы определить, правильно ли параметризован запрос:

```sql
SELECT TOP 10
  q.query_hash
  , count (distinct p.query_id ) AS number_of_distinct_query_ids
  , min(qt.query_sql_text) AS sampled_query_text
FROM sys.query_store_query_text AS qt
  JOIN sys.query_store_query AS q
     ON qt.query_text_id = q.query_text_id
  JOIN sys.query_store_plan AS p
     ON q.query_id = p.query_id
  JOIN sys.query_store_runtime_stats AS rs
     ON rs.plan_id = p.plan_id
  JOIN sys.query_store_runtime_stats_interval AS rsi
     ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id
WHERE
  rsi.start_time >= DATEADD(hour, -2, GETUTCDATE())
  AND query_parameterization_type_desc IN ('User', 'None')
GROUP BY q.query_hash
ORDER BY count (distinct p.query_id) DESC
```

### <a name="factors-that-affect-query-plan-changes"></a>Факторы, влияющие на изменения плана запроса

Повторная компиляция плана выполнения запроса может привести к созданию плана запроса, который отличается от первоначального кэшированного плана. Существующий исходный план может автоматически перекомпилироваться по различным причинам:

- На изменения в схеме ссылается запрос
- Запрос ссылается на изменения данных в таблицах
- Параметры контекста запроса были изменены

Скомпилированный план может быть извлечен из кэша по различным причинам, например:

- Перезапуски экземпляра
- Изменения конфигурации уровня базы данных
- нехватка памяти;
- Явные запросы на очистку кэша

Если вы используете Указание RECOMPILE, план не будет кэшироваться.

Повторная компиляция (или новая компиляция после вытеснения кэша) по-прежнему может привести к созданию плана выполнения запроса, идентичного исходному. При изменении плана с прошлого или исходного плана, скорее всего, эти объяснения:

- **Измененная физическая структура** . Например, вновь созданные индексы более эффективно охватывают требования запроса. Новые индексы могут использоваться для новой компиляции, если оптимизатор запросов решает, что использование нового индекса является более оптимальным, чем использование структуры данных, которая была изначально выбрана для первой версии выполнения запроса. Любые физические изменения объектов, на которые имеются ссылки, могут привести к выбору нового плана во время компиляции.

- **Различия в ресурсах сервера** . Если план в одной системе отличается от плана в другой системе, доступность ресурсов, например количество доступных процессоров, может повлиять на создаваемый план. Например, если в одной системе больше процессоров, можно выбрать параллельный план.

- **Другая статистика** . Статистика, связанная с упоминаемыми объектами, могла быть изменена или может отличаться от статистики исходной системы. Если изменение статистики и повторная компиляция происходят, оптимизатор запросов использует статистические данные, начиная с изменения. Пересмотренные статистические данные и частоты распределения данных могут отличаться от измененных в исходной компиляции. Эти изменения используются для создания оценки количества элементов. ( *Оценка количества элементов* — это количество строк, которые должны проходить через дерево логических запросов.) Изменения в оценке количества элементов могут привести к выбору различных физических операторов и связанных с ними заказов операций. Даже небольшие изменения статистики могут привести к изменению плана выполнения запроса.

- **Измененный уровень совместимости базы данных или версия средства оценки количества элементов** . изменения уровня совместимости базы данных могут включать новые стратегии и функции, которые могут привести к другому плану выполнения запроса. Помимо уровня совместимости базы данных, отключенный или включенный флаг трассировки 4199 или измененное состояние QUERY_OPTIMIZER_HOTFIXES конфигурации уровня базы данных также может влиять на выбор плана выполнения запроса во время компиляции. Флаги трассировки 9481 (принудительно использовать устаревшие версии CE) и 2312 (принудительно по умолчанию CE) также влияют на план.

## <a name="resource-limits-issues"></a>Проблемы с ограничениями ресурсов

Медленная производительность запросов, не связанная с неоптимальными планами запросов и отсутствующими индексами, обычно связана с недостаточными или слишком часто используемыми ресурсами. Если план запроса является оптимальным, то запрос (и база данных) может быть связан с ограничениями ресурсов для базы данных, эластичного пула или управляемого экземпляра. Примером может быть чрезмерная пропускная способность записи журнала для уровня обслуживания.

- Обнаружение проблем с ресурсами с помощью портал Azure. сведения о проблемах с ограничениями ресурсов см. в статье [мониторинг ресурсов базы данных SQL](database/monitor-tune-overview.md#azure-sql-database-and-azure-sql-managed-instance-resource-monitoring). Сведения об отдельных базах данных и пулах эластичных БД см. в разделе [Помощник по базам данных рекомендации по производительности](database/database-advisor-implement-performance-recommendations.md) и анализ [производительности запросов](database/query-performance-insight-use.md).
- Определение ограничений ресурсов с помощью [Intelligent Insights](database/intelligent-insights-troubleshoot-performance.md#reaching-resource-limits)
- Обнаружение проблем с ресурсами с помощью [динамических административных представлений](database/monitoring-with-dmvs.md):

  - [Sys.dm_db_resource_stats](database/monitoring-with-dmvs.md#monitor-resource-use) динамическое административное представление возвращает сведения о ЦП, вводе-выводе и использовании памяти для базы данных. Одна строка существует каждые 15 секунд, даже если в базе данных нет действий. Исторические данные хранятся в течение одного часа.
  - [Sys.resource_stats](database/monitoring-with-dmvs.md#monitor-resource-use) динамическое административное представление возвращает сведения об использовании ЦП и данных хранилища для базы данных SQL Azure. Данные собираются и суммируются через пять минут.
  - [Множество отдельных запросов, которые кумулятивно потребляют высокую загрузку ЦП](database/monitoring-with-dmvs.md#many-individual-queries-that-cumulatively-consume-high-cpu)

Если Вы выявляете проблему как недостаточный ресурс, вы можете обновить ресурсы, чтобы увеличить емкость базы данных, чтобы уменьшить требования к ЦП. Дополнительные сведения см. в статье [масштабирование отдельных ресурсов базы данных в базе данных SQL Azure](database/single-database-scale.md) и [масштабирование ресурсов эластичного пула в базе данных SQL Azure](database/elastic-pool-scale.md). Дополнительные сведения о масштабировании управляемого экземпляра см. в разделе [ограничения ресурсов уровня службы](managed-instance/resource-limits.md#service-tier-characteristics) .

## <a name="performance-problems-caused-by-increased-workload-volume"></a>Проблемы с производительностью, вызванные увеличением объема рабочей нагрузки

Увеличение объема трафика приложения и рабочей нагрузки может привести к повышению загрузки ЦП. Но следует быть внимательным, чтобы правильно диагностировать эту проблему. При возникновении проблем с высокой производительностью ЦП ответьте на эти вопросы, чтобы определить, вызваны ли изменения в томе рабочей нагрузки.

- Являются ли запросы из приложения причиной проблемы с высокой производительностью ЦП?
- Для [запросов с наибольшим потреблением ресурсов ЦП, которые можно выявление](database/monitoring-with-dmvs.md#the-cpu-issue-occurred-in-the-past):

  - Связаны ли несколько планов выполнения с одним и тем же запросом? Если да, почему?
  - Для запросов с одним и тем же планом выполнения были выполнены единообразные времена выполнения? Увеличится ли количество выполнений? В таком случае увеличение рабочей нагрузки, скорее всего, приведет к проблемам с производительностью.

Если план выполнения запроса не выполнялся по-разному, но загрузка ЦП увеличилась вместе со счетчиком выполнения, то проблема с производительностью скорее всего связана с увеличением рабочей нагрузки.

Не всегда легко выявление изменения тома рабочей нагрузки, которое приводит к возникновению проблемы с ЦП. Учитывайте следующие факторы:

- **Измененное использование ресурсов** . Например, рассмотрим ситуацию, когда загрузка ЦП увеличилась до 80% в течение продолжительного периода времени. Только загрузка ЦП не означает, что том рабочей нагрузки изменился. Регрессия в плане выполнения запроса и изменения в распределении данных могут также повысить уровень использования ресурсов, даже если приложение выполняет ту же рабочую нагрузку.

- **Внешний вид нового запроса** : приложение может создавать новый набор запросов в разное время.

- **Увеличение или уменьшение количества запросов** : Этот сценарий является наиболее очевидным показателем рабочей нагрузки. Количество запросов не всегда соответствует дополнительному использованию ресурсов. Однако эта метрика по-прежнему является важным сигналом, при условии, что другие факторы не меняются.

Используйте Intelligent Insights для определения [увеличения рабочей нагрузки](database/intelligent-insights-troubleshoot-performance.md#workload-increase) и [планирования регрессии](database/intelligent-insights-troubleshoot-performance.md#plan-regression).

## <a name="waiting-related-problems"></a>Проблемы, связанные с ожиданием

После устранения неоптимального плана и проблем с *ожиданием* , связанных с проблемами выполнения, проблема с производительностью обычно заключается в том, что запросы ожидают некоторого ресурса. Проблемы, связанные с ожиданием, могут быть вызваны следующими причинами.

- **Блокировка** :

  Один запрос может сохранить блокировку объектов в базе данных, тогда как другие пытаются получить доступ к тем же объектам. Можно выявление блокирующих запросов с помощью [динамических административных представлений](database/monitoring-with-dmvs.md#monitoring-blocked-queries) или [Intelligent Insights](database/intelligent-insights-troubleshoot-performance.md#locking).
- **Проблемы ввода-вывода**

  Запросы могут ожидать записи страниц в файлы данных или журналов. В этом случае проверьте `INSTANCE_LOG_RATE_GOVERNOR` `WRITE_LOG` `PAGEIOLATCH_*` статистику ожидания в динамическом административном элементе, или. См. раздел Использование динамических административных представлений для [обнаружения проблем производительности операций ввода-вывода](database/monitoring-with-dmvs.md#identify-io-performance-issues).
- **Проблемы TempDB**

  Если Рабочая нагрузка использует временные таблицы или в планах есть сбросы базы данных TempDB, то в запросах может возникнуть проблема с пропускной способностью TempDB. См. раздел Использование динамических административных представлений для [идентификации проблем tempdb](database/monitoring-with-dmvs.md#identify-tempdb-performance-issues).
- **Проблемы, связанные с памятью**

  Если в рабочей нагрузке недостаточно памяти, может быть выведено ожидаемое время существования страницы, иначе запросы могут оказаться меньше памяти, чем требуется. В некоторых случаях встроенная аналитика в оптимизаторе запросов устраняет проблемы, связанные с памятью. См. раздел Использование динамических административных представлений для [обнаружения проблем с предоставлением памяти](database/monitoring-with-dmvs.md#identify-memory-grant-wait-performance-issues).

### <a name="methods-to-show-top-wait-categories"></a>Методы для отображения основных категорий ожидания

Эти методы обычно используются для отображения основных категорий типов ожидания:

- Использование Intelligent Insights для обнаружения запросов с ухудшением производительности из-за [увеличенного числа ожиданий](database/intelligent-insights-troubleshoot-performance.md#increased-wait-statistic)
- Используйте [хранилище запросов](/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store) , чтобы найти статистику ожидания для каждого запроса с течением времени. В хранилище запросов типы времени ожидания объединены в категории ожидания. Сопоставление категорий ожидания можно найти в [sys.query_store_wait_stats](/sql/relational-databases/system-catalog-views/sys-query-store-wait-stats-transact-sql#wait-categories-mapping-table)типы ожидания.
- Используйте [sys.dm_db_wait_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-wait-stats-azure-sql-database) , чтобы получить сведения обо всех ожиданиях, обнаруженных потоками, которые выполнялись во время операции запроса. Это агрегированное представление можно использовать для диагностики проблем с производительностью базы данных SQL Azure, а также с конкретными запросами и пакетами. Запросы могут ожидать ресурсы, ожидания очереди или внешние ожидания.
- Используйте [sys.dm_os_waiting_tasks](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-waiting-tasks-transact-sql) , чтобы получить сведения о очереди задач, ожидающих некоторого ресурса.

В сценариях с высоким уровнем загрузки ЦП хранилище запросов и статистика ожидания могут не отражать загрузку ЦП, если:

- Запросы с высоким потреблением ЦП все еще выполняются.
- Запросы высокой загрузки ЦП выполнялись при отработке отказа.

Динамические административные представления, которые следят за хранилищем запросов и статистикой ожидания, показывают результаты только для успешно завершенных и истечения времени ожидания запросов. Они не отображают данные для выполняемых в данный момент инструкций до завершения операторов. Используйте динамическое административное представление [sys.dm_exec_requests](/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-requests-transact-sql) для трассировки выполняющихся в данный момент запросов и связанного времени рабочего процесса.

> [!TIP]
> Дополнительные инструменты:
>
> - [Тижертулбокс ожидания и кратковременные блокировки](https://github.com/Microsoft/tigertoolbox/tree/master/Waits-and-Latches)
> - [Тижертулбокс usp_whatsup](https://github.com/Microsoft/tigertoolbox/tree/master/usp_WhatsUp)

## <a name="next-steps"></a>Дальнейшие действия

[Общие сведения о мониторинге и настройке базы данных SQL](database/monitor-tune-overview.md)