---
title: Управление историческими данными в временных таблицах
description: Узнайте, как использовать политику темпорального хранения для постоянного контроля над историческими данными.
services: sql-database
ms.service: sql-db-mi
ms.subservice: development
ms.custom: sqldbrb=2
ms.devlang: ''
ms.topic: how-to
author: bonova
ms.author: bonova
ms.reviewer: sstein
ms.date: 09/25/2018
ms.openlocfilehash: 1d68163a9fba3ba3bcd4c0c0f3fb5f442296e781
ms.sourcegitcommit: 4bebbf664e69361f13cfe83020b2e87ed4dc8fa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/01/2020
ms.locfileid: "91619395"
---
# <a name="manage-historical-data-in-temporal-tables-with-retention-policy"></a>Управление историческими данными в временных таблицах с помощью политики хранения
[!INCLUDE[appliesto-sqldb-sqlmi](../includes/appliesto-sqldb-sqlmi.md)]

Временные таблицы могут увеличить размер базы данных более чем на обычные таблицы, особенно если данные журнала сохранены в течение более длительного периода времени. Поэтому политика хранения для исторических данных является важной составляющей управления жизненным циклом любой темпоральной таблицы. Временные таблицы в базе данных SQL Azure и Azure SQL Управляемый экземпляр поставляются с простым в использовании механизмом хранения, который помогает выполнить эту задачу.

Хранение темпоральных журналов можно настроить на уровне отдельных таблиц, что позволит пользователям создавать гибкие политики устаревания. Применять темпоральные журналы легко: для настройки во время создания таблицы или изменения схемы требуется только один параметр.

После определения политики хранения база данных SQL Azure и Управляемый экземпляр Azure SQL будут регулярно проверяться, если существуют строки с предысторией, которые могут быть доступны для автоматической очистки данных. Идентификация совпадающих строк и их удаление из таблицы журналов осуществляется прозрачно, в рамках фоновой задачи, которая планируются и выполняются системой. Условие устаревания строк в таблицах журналов проверяется по столбцу, представляющему окончание периода SYSTEM_TIME. Например, если срок хранения составляет шесть месяцев, для очистки подходят строки, отвечающие следующему условию:

```sql
ValidTo < DATEADD (MONTH, -6, SYSUTCDATETIME())
```

В предыдущем примере предполагается, что столбец **ValidTo** соответствует концу SYSTEM_TIME периода.

## <a name="how-to-configure-retention-policy"></a>Настройка политики хранения

Перед настройкой политики хранения для темпоральной таблицы сначала установите флажок, независимо от того, включено ли временное хранение с предысторией *на уровне базы данных*.

```sql
SELECT is_temporal_history_retention_enabled, name
FROM sys.databases
```

Флаг базы данных **is_temporal_history_retention_enabled** по умолчанию установлен, однако пользователи могут его изменить с помощью инструкции ALTER DATABASE. Он также автоматически устанавливается в состояние OFF после операции [восстановления на момент времени](recovery-using-backups.md) . Чтобы включить очистку хранения журналов для базы данных, выполните следующую инструкцию:

```sql
ALTER DATABASE <myDB>
SET TEMPORAL_HISTORY_RETENTION  ON
```

> [!IMPORTANT]
> Срок хранения для темпоральных таблиц можно настроить, даже если флаг **is_temporal_history_retention_enabled** имеет значение OFF, но в этом случае не будет активироваться автоматическая очистка для устаревших строк.

Политика хранения настраивается во время создания таблицы путем указания значения для параметра HISTORY_RETENTION_PERIOD:

```sql
CREATE TABLE dbo.WebsiteUserInfo
(  
    [UserID] int NOT NULL PRIMARY KEY CLUSTERED
  , [UserName] nvarchar(100) NOT NULL
  , [PagesVisited] int NOT NULL
  , [ValidFrom] datetime2 (0) GENERATED ALWAYS AS ROW START
  , [ValidTo] datetime2 (0) GENERATED ALWAYS AS ROW END
  , PERIOD FOR SYSTEM_TIME (ValidFrom, ValidTo)
 )  
 WITH
 (
     SYSTEM_VERSIONING = ON
     (
        HISTORY_TABLE = dbo.WebsiteUserInfoHistory,
        HISTORY_RETENTION_PERIOD = 6 MONTHS
     )
 );
```

База данных SQL Azure и Управляемый экземпляр Azure SQL позволяют указать срок хранения, используя разные единицы времени: дни, недели, месяцы и годы. Если параметр HISTORY_RETENTION_PERIOD опущен, это означает, что срок хранения НЕ ОГРАНИЧЕН (INFINITE). Кроме того, ключевое слово INFINITE можно использовать явным образом.

В некоторых сценариях настройка хранения может потребоваться после создания таблицы либо для того, чтобы изменить значение, заданное ранее. В этом случае используйте инструкцию ALTER TABLE:

```sql
ALTER TABLE dbo.WebsiteUserInfo
SET (SYSTEM_VERSIONING = ON (HISTORY_RETENTION_PERIOD = 9 MONTHS));
```

> [!IMPORTANT]
> Если для параметра SYSTEM_VERSIONING задать значение OFF, значение срока хранения *не сохраняется*. Если для параметра SYSTEM_VERSIONING задать значение ON, не указывая явно значение HISTORY_RETENTION_PERIOD, будет установлен неограниченный (INFINITE) срок хранения.

Чтобы узнать текущее состояние политики хранения, выполните указанный ниже запрос, объединяющий флаг включения временного хранения на уровне базы данных со сроками хранения для отдельных таблиц:

```sql
SELECT DB.is_temporal_history_retention_enabled,
SCHEMA_NAME(T1.schema_id) AS TemporalTableSchema,
T1.name as TemporalTableName,  SCHEMA_NAME(T2.schema_id) AS HistoryTableSchema,
T2.name as HistoryTableName,T1.history_retention_period,
T1.history_retention_period_unit_desc
FROM sys.tables T1  
OUTER APPLY (select is_temporal_history_retention_enabled from sys.databases
where name = DB_NAME()) AS DB
LEFT JOIN sys.tables T2
ON T1.history_table_id = T2.object_id WHERE T1.temporal_type = 2
```

## <a name="how-ages-rows-are-deleted"></a>Удаление строк в сбоях

Процесс очистки зависит от макета индекса таблицы журналов. Следует отметить, что *ограниченный срок хранения можно настроить только для таблиц журналов с кластеризованным индексом (columnstore или сбалансированным деревом)* . Для очистки устаревших данных во всех темпоральных таблицах с ограниченным периодом хранения создается фоновая задача.
Логика очистки для кластеризованного индекса типа rowstore (сбалансированное дерево) удаляет устаревшие строки мелкими фрагментами (не более 10 000), чтобы свести к минимуму нагрузку на журнал базы данных и подсистему ввода-вывода. Несмотря на то что в логике очистки используется индекс сбалансированного дерева, порядок удаления строк, возраст которых превышает срок хранения, может не соблюдаться. В связи с этим *не включайте в приложения никакие зависимости от порядка очистки*.

Задача очистки для кластеризованного columnstore удаляет целые [группы строк](/sql/relational-databases/indexes/columnstore-indexes-overview) одновременно (обычно содержит 1 000 000 по строкам), что очень эффективно, особенно при создании исторических данных в высоком темпе.

![Кластеризованный период удержания columnstore](./media/temporal-tables-retention-policy/cciretention.png)

Превосходное сжатие данных и эффективная очистка хранилища делают кластеризованный индекс columnstore наиболее подходящим для случаев, когда рабочая нагрузка вызывает быстрое образование большого количества исторических данных. Этот шаблон является типичным для ресурсоемких [рабочих нагрузок обработки транзакций, использующих временные таблицы](/sql/relational-databases/tables/temporal-table-usage-scenarios) для отслеживания изменений и аудита, анализа тенденций или приема данных IOT.

## <a name="index-considerations"></a>Рекомендации по выбору индекса

Задача очистки для таблиц с кластеризованным индексом rowstore требует, чтобы индекс начинался со столбца, соответствующего окончанию периода SYSTEM_TIME. Если такого индекса не существует, вы не сможете настроить хранение с ограниченным сроком.

*Сообщение 13765, уровень 16, состояние 1. <br> </br> Установка конечного срока хранения завершилась сбоем в темпоральной таблице с версией системы "temporalstagetestdb. dbo. WebsiteUserInfo", так как таблица журнала "temporalstagetestdb. dbo. WebsiteUserInfoHistory" не содержит необходимый кластеризованный индекс. Рассмотрите возможность создания кластеризованного индекса columnstore или сбалансированного дерева, начинающегося со столбца, который соответствует концу SYSTEM_TIME периода, в таблице журнала.*

Важно отметить, что таблица журнала по умолчанию, созданная базой данных SQL Azure и Azure SQL Управляемый экземпляр, уже имеет кластеризованный индекс, соответствующий политике хранения. При попытке удаления такого индекса для таблицы с ограниченным сроком хранения операция завершается следующей ошибкой:

*Сообщение 13766, уровень 16, состояние 1 <br> </br> не может удалить кластеризованный индекс "WebsiteUserInfoHistory. IX_WebsiteUserInfoHistory", так как он используется для автоматической очистки устаревших данных. Если необходимо удалить этот индекс, попробуйте задать для параметра HISTORY_RETENTION_PERIOD значение INFINITE в соответствующей темпоральной таблице с системным управлением версиями.*

Очистка в кластеризованном индексе columnstore работает лучше всего, если строки исторических данных вставляются в порядке возрастания (с сортировкой по столбцу окончания периода). Это условие выполняется всегда, если таблицы исторических данных заполняются исключительно с помощью механизма SYSTEM_VERSIONIOING. Если строки в исторической таблице не упорядочены по столбцу окончания периода (это возможно, если выполнялась миграция существующих исторических данных), нужно заново создать кластеризованный индекс columnstore. Для оптимальной производительности создавайте его поверх правильно отсортированного индекса сбалансированного дерева rowstore.

Старайтесь не перестраивать кластеризованный индекс columnstore для таблицы исторических данных с ограниченным сроком хранения, так как это может изменить порядок групп строк, естественным образом созданный в результате работы системы управления версиями. Если необходимо перестроить кластеризованный индекс columnstore для таблицы исторических данных, создавайте его поверх правильного индекса сбалансированного дерева, чтобы сохранить в группах строк порядок, необходимый для регулярной очистки данных. Аналогичный подход следует применять и при создании темпоральной таблицы из существующей таблицы исторических данных с кластеризованным индексом столбцов, но без гарантированного порядка данных:

```sql
/*Create B-tree ordered by the end of period column*/
CREATE CLUSTERED INDEX IX_WebsiteUserInfoHistory ON WebsiteUserInfoHistory (ValidTo)
WITH (DROP_EXISTING = ON);
GO
/*Re-create clustered columnstore index*/
CREATE CLUSTERED COLUMNSTORE INDEX IX_WebsiteUserInfoHistory ON WebsiteUserInfoHistory
WITH (DROP_EXISTING = ON);
```

Если вы настроите ограниченный срок хранения для таблицы исторических данных с кластеризованным индексом columnstore, вы не сможете создавать дополнительные некластеризованные индексы сбалансированного дерева для этой таблицы:

```sql
CREATE NONCLUSTERED INDEX IX_WebHistNCI ON WebsiteUserInfoHistory ([UserName])
```

Попытка выполнить приведенную выше инструкцию завершится следующей ошибкой.

*MSG 13772, уровень 16, состояние 1 <br> </br> не может создать некластеризованный индекс для темпоральной таблицы журнала "WebsiteUserInfoHistory", так как он содержит конечный срок хранения и определенный кластеризованный индекс columnstore.*

## <a name="querying-tables-with-retention-policy"></a>Запросы к таблицам с политикой хранения

Все запросы к темпоральным таблицам автоматически фильтруют строки исторических данных в соответствии с политикой ограниченного срока хранения. Это позволяет избежать непредсказуемости и несогласованности результатов, так как задача очистки может удалять устаревшие строки *в любой момент времени и в произвольном порядке*.

На следующем рисунке показан план для простого запроса.

```sql
SELECT * FROM dbo.WebsiteUserInfo FOR SYSTEM_TIME ALL;
```

План запроса содержит дополнительный фильтр, применяемый к столбцу окончания периода (ValidTo) в операторе "Clustered Index Scan" (Сканирование кластеризованного индекса) в таблице исторических данных (выделено). В этом примере предполагается, что для таблицы WebsiteUserInfo задан срок хранения "1 MONTH" (1 месяц).

![Фильтр для запроса хранения](./media/temporal-tables-retention-policy/queryexecplanwithretention.png)

Но если вы будете запрашивать таблицы исторических данных напрямую, результат может включать строки старше указанного периода хранения. При этом нет никаких гарантий, что повторные запросы вернут такие же результаты. На следующем рисунке показан план выполнения для запроса в таблице исторических данных без применения дополнительных фильтров.

![Запрос по историческим данным без фильтра хранения](./media/temporal-tables-retention-policy/queryexecplanhistorytable.png)

Не следует основывать бизнес-логику приложения на считывании таблицы исторических данных по окончании срока хранения. В таком случае вы можете получить несогласованные или непредвиденные результаты. Мы рекомендуем использовать для анализа данных в темпоральных таблицах только темпоральные запросы с предложением FOR SYSTEM_TIME.

## <a name="point-in-time-restore-considerations"></a>Рекомендации по восстановлению до точки во времени

При создании новой базы данных путем [восстановления базы данных до определенной точки во времени](recovery-using-backups.md) темпоральное хранение отключается на уровне базы данных. (Флаг **is_temporal_history_retention_enabled** получает значение OFF.) Эта функция позволяет изучить все строки исторических данных после восстановления, не беспокоясь, что устаревшие строки будут удалены еще до отправки запроса к ним. Используйте этот режим для *изучения исторических данных по окончании установленного срока хранения*.

Предположим, что для темпоральной таблицы задан срок хранения в 1 месяц. Если база данных создана на уровне службы "Премиум", вы сможете создать копию базы данных с состоянием базы данных за последние 35 дней. Это фактически позволит вам анализировать строки исторических данных за период до 65 дней с помощью прямых запросов к таблице исторических данных.

Если вы хотите активировать очистку темпорального хранения, выполните следующую инструкцию Transact-SQL после восстановления до точки во времени:

```sql
ALTER DATABASE <myDB>
SET TEMPORAL_HISTORY_RETENTION  ON
```

## <a name="next-steps"></a>Дальнейшие действия

Чтобы узнать, как использовать временные таблицы в приложениях, изучите [Начало работы с временными таблицами](../temporal-tables.md).

Посетите канал 9, чтобы услышать [историю успеха реализации клиента](https://channel9.msdn.com/Blogs/jsturtevant/Azure-SQL-Temporal-Tables-with-RockStep-Solutions) , и просмотрите [действующую временную демонстрацию](https://channel9.msdn.com/Shows/Data-Exposed/Temporal-in-SQL-Server-2016).

Подробные сведения о временных таблицах см. в [таблице временных таблиц](/sql/relational-databases/tables/temporal-tables).
